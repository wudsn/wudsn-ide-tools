Mad-Assembler 1.9.2

Tebe / Madteam (25/01/2011)

    INTRODUCTION
        Admission
        Compilation
        Differences and similarities between XASM and MADS
            Similarities
            Differences and new possibilities

    DIRECTIONS
        Assembler switches
        Output Codes
        The structure of the file. LST
        The structure of the file. LAB
        The structure of the file. H

    Sparta DOS X
        Construction of Sparta DOS X-Files, Atari DOS
        Programming Sparta DOS X

    Mnemonics
        6502
        6502 illegal
        65816

    CPU DETECTION

    MEMORY BANKS
        Virtual
        Hardware

    CODE RELOKOWALNY
        Block relokowalny
        External Symbols
        Public Symbols
        Linking
    TYPES
        Structural
            Declaration of a structural
            Defining the structural data
        Enumeration
            Enumeration type declaration
            Defining the data enumerated

    HISTORY



    SYNOPSIS
        Comments
        Combining multiple rows into one row
        Combine multiple mnemonics
        Expressions
            Numbers
            Operators
        Labels
            Local
            Global
            Temporary
            Local style IEA
        Control assemble
            Change options assemble
            Conditional assembling
            Interrupt assemble
            Assembling at zero
        Macro commands
        Pseudo orders
            Defining block SDX
            Defining the symbol SDX
            Defining data
        Directive
            Defining replicates (. REPT)
            Defining the symbol SDX (. SYMBOL)
            Defining segments (. SEGDEF)
        Directive generating code 6502
            Define iterations (# WHILE)
            Define the decision (# IF)
            # CYCLE
        Tables
            Array declaration
        Macros
            Declaration Macros
            Calling macros
        Procedures
            The declaration procedure
            Procedure call
            Procedure Parameters
        Local Area
            Declaration of local area

INTRODUCTION
Admission

Mad-Assembler (MADS) is a 32 bit, written in Delphi. Most assemblers written in C, so in order not to repeat, I used Delphi 7.0;).

The assumption of MADS is directed to users of QA XASM, FA. QA was derived from the syntax of XASM some macro commands and syntax changes, the FA support for syntax Sparta DOS X (SDX). Has enabled the use of additional characters in the names of the labels. Besides, adds support CPU 65816, macros, procedures, allocation of virtual memory banks, multi-dimensional label names.

The maximum number of labels and macros is limited amount of memory your PC. Specifically, you can make a 2147483647 (INTEGER) array of dynamic entries. I am sure that this amount is enough:)
Arithmetic operations are performed on the values ??of type Int64 (signed 64 bit), the result is represented on the values ??of type CARDINAL (unsigned 32 bit).

One line may have a length of 65535 bytes, this length may also be the name of the label. But I had no opportunity to check the labels and such long lines:)

With the free compiler Free Pascal Compiler is possible to build the MADS-and for other platforms such as Linux, Mac, OS / 2, etc. For more information on compiling in Chapter Compilation.
If your system is the correct version of Free Pascal, which means that you can use the MADS-a.

Home XASM-a: http://atariarea.krap.pl/x-asm/


Compilation

To compile the source of the MADS-and you can use a compiler with Delphi, if someone has just installed the Delphi environment 7.0 or later.

Another way, more multi platformowym is to use the compiler package Free Pascal Compiler (FPC), which can be downloaded from http://www.freepascal.org/
Run the installer, select the directory where you installed FP. It is important not to use the directory name exclamation mark "!" or other non-standard characters. If we fail to compile any file, probably should not be a standard path name. The command line that launches the compilation could look like this (capitalization in the names of the parameters is important):

fpc-Mdelphi-v mads.pas

-Mdelphi allows you to compile the file in Delphi
-V displays all error messages and warnings
-O3 makes code optimization

Compared with the Delphi compiler, the code generated by the FPC is longer, but the speed of the MADS-compiled it and much more, even for a few seconds. MADS.EXE attached file is compiled using the FPC.


DIFFERENCES AND SIMILARITIES BETWEEN XASM I MADS
Similarities
the same syntax
the same exit codes
the same macro commands


Differences and new possibilities
ORG small difference in, for example, 'ORG [[expression]] address [, Address2]'
XASM does not like "white space", MADS tolerate and accept them for logical expressions, arithmetic, fixed and variable definitions
MADS allows the placement of the expressions between parentheses (), [], XASM only between []
MADS provides definitions of fixed and variable local, global, temporary, XASM only global
MADS does not accept and ORG: ORG address and f: address
MADS provides a record of real numbers by the Directive. FL. FL real, XASM by the pseudo R-DTA DTA command R (real)
MADS offers a more extensive support for pseudo-ordered INS
MADS does not accept the syntax of type 'lda (203), 0'
MADS allows you to write programs for the Sparta DOS X
MADS allows you to generate code relokowalnego in your own format
if we use when addressing the character, eg

  lda # ''
  lda # ""

MADS would distinguish a single apostrophe (ATASCII code) and a double apostrophe (code INTERNAL) XASM both types equally treats apostrophes (code ATASCII). Of course, for the DTA apostrophes are not distinguished by MADS.
index in either a '+' or '-' increases or decreases the registry, eg

 lda $ 2000, x + -> lda $ 2000, x
                       INX

but if you put a value for the character '+' or '-' then change the value of the main argument (works only in the absolute index), for example:

 lda $ 2000, x 2 -> lda $ 2002, x


DIRECTIONS
Assembler switches

Syntax: mads source [switches]

-B: Generate address binary file at specific address
C Label case sensitivity
D: label = value Define a label
CPU-f command at first column
-Hc [: filename] Header file for CC65
-Hm [: filename] Header file for MADS
-I: Additional include directories path
-L [: filename] Generate listing
-M: filename File with macro definition
-O: Set object filename file name
-P Print file fully qualified names in listing and error messages
-S Silent mode
-T [: filename] List the label table
-X Exclude unreferenced Procedures
Vu Verify code inside unreferenced Procedures
-U Warn of unused labels

The default file names are:
source.lst
source.obx
source.lab
source.h
source.hea
source.mac

If you do not specify a file extension for the source, then the default MADS accept the extension. ASM.
Parameters can be administered in any order previously preceded by a '/' or '-' case does not matter. Parameters can be combined, eg:

mads-lptd: label = value-d: Label2 = value source.asm
mads-l-p-t source
mads source.asm-lpt
mads.exe "% 1"-ltpi: "d: \! atari \ macro \"
mads-i: "c: \ atari \ macros \"-c-lpt source.asm

By default, after assembling MADS save file with the extension '. OBX', we can change the level of BAT:

mads "% 1"-o:% ~ n1.xex

More about the providers we can learn by doing "CALL /?" from the Microsoft DOS.

-B: address
Using the-b switch allows you to assemble to give a new address for a file which does not assemble specified address (the address is defined using the assemble command pseudo ORG).

-C
Using the-c switch causes a case-sensitive names labels, variables, constants. Assembler directive and orders the CPU 6502, 65,816 are always recognized regardless of case.

D: label = value
Use the-d switch allows you to enter a new label to the memory of the MADS-and from the command line. Switch can be used repeatedly during a single call to the MADS-a, can be useful when assembles using batch files (BAT).

F
Using the-f switch allows you to place orders the CPU from the first column of a row and their proper recognition by the assembler as commands and not just as a label.

-Hc [: filename]
Switch-hc record includes a file with headers for the compiler CC65. It also allows you specify a new name for the file. The default name for the header file is *. H-CC65

-Hm [: filename]
The switch turns on a record-hm file with headers for the MADS-a. It also allows you specify a new name for the file. The default file name for the MADS-header and it *. HEA. Such a file contains information about the labels assigned to banks and their values. In addition, the labels are sorted by type CONSTANS, VARIABLES, PROCEDURES.

-I: path
The switch-i is used to determine search paths for ICL and INS operations. Switch can be used repeatedly during a single call to the MADS-and, for example:

 -I: "c: \ program files"-i: c: \ temp-i: "d: \ atari project"

-L: filename
The switch-l includes a record of the file listing. It also allows you specify a new name for the file.

-M: filename
The-m switch to specify a file with declarations of macros. In the case of the use of MADS assembles the file before the main file. ASM

-O: filename
Switch-on allows you to specify a new name for an executable file or DOS Atari Atari Sparta DOS X, which arises after the process of assembling.

-P
The-p switch is useful in conjunction with the Code Genie. When an error occurs during assembling, the Output window editor Bar Code Genie prompted MADS generated by, for example:

D: \! Delphi \ MASM \ test.asm (29) ERROR: Missing. PROC

Now simply double-click the message line, and cursor editor, set in line with an error.

-S
Use the-s switch will activate the so-called. mode 'Silent mode', ie no messages will not be displayed at the most error messages (ERROR) and warning (WARNING).

-T [: filename]
The switch-t turns on file with the record labels that used definitions. It also allows you specify a new name for the file.

-X
The-x switch allows you to skip the process of assembling procedures declared Directive. PROC for which there was no reference in the program.

-Vu
Switch-vu enforces additional test code in the blocks. PROC despite the fact that such a bloc. PROC is not saved in the output file, often useful when using switch-x

-U
The switch-in will display the labels that were not used in the program.


Output Codes

3 = bad parameters, not started assembling
2 = Error occurred
0 = no errors

Warning messages do not change the value of the output code.


LST File Structure

Listing format does not differ from that known from XASM, the only change is the addition before the address, the number of virtual memory bank (provided that the bank <> 0). More about virtual banks in the memory banks section.

     3
     4 = 01.9033 painting equ $ 9033
     5 = 01.00 scr1 A0 equ $ a0
     6
     7
     8 01.2000 EA main nop


LAB File Structure

Like XASM, in the *. LAB stores information about the labels that have occurred in the program.
In total, there are three columns:

The first column is a virtual bank number assigned to the label (if the bank <> 0)
The second column is the value of the label.
The third column is the name of the label.

Virtual bank numbers assigned to the label with values> = $ FFF9 have special meanings:

 $ FFF9 label parameter in the procedure defined by the Directive. PROC
 $ FFFA label array defined by the Directive. ARRAY
 $ FFFB structural data label defined by a pseudo command STRUCT_LABEL DTA
 $ FFFC label symbol of Sparta DOS X - SMB
 $ Fffd macro label defined by the Directive. MACRO
 $ FFFE label structure defined by the Directive. STRUCT
 $ FFFF label procedure defined by the Directive. PROC

Special significance in the names of the labels are characters:

label defined in a macro (two colons):
dot "." separates the name of the structure (. MACRO. PROC. LOCAL. STRUCT) from the field name in the structure

A numeric value that occurs after: mean number of calls to the macro.

Mad-Assembler v1.4.2beta by Tebe / Madteam
Label table:
00 0400 @ STACK_ADDRESS
00 00FF @ STACK_POINTER
00 2000 MAIN
2019 LOOP 00
00 201C LOOP:: 1
00 201C LHEX
00 0080 LHEX.HLP
00 204C LHEX.THEX
00 205C HEX
00 205C HEX. @ GETPAR0.LOOP
00 2079 HEX. @ GETPAR1.LOOP


File structure H

I'm not sure if all of this file is OK, but Eru wanted something that was so it is:) It is to be useful when combining ASM and the CC65, which is a small port C for Atari. Its contents might look like this (sample file TEST.ASM):

# Ifndef _TEST_ASM_H_
# Define _TEST_ASM_H_

# Define TEST_CPU65816 0x200F
0x2017 # define TEST_CPU6502
# Define TEST_TEXT6502 0x201F
0x2024 # define TEST_TEXT65816

# Endif


MACRO COMMANDS

 REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS

 SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS

 JEQ, jne, JPL, JMI, JCC, JCS, JVC, JVS

 ADD, SUB

 ADB, SBB

 ADW, SBW

 PHR, PLR

 INW, INL, IND, DEW, DEL DED

 MVA, MVX, MVY

 MWA, MWX, MWY

 CPB, CPW, CPL, CPD

The task of macro commands is to shorten the time of writing the program and the same listing. Macro commands replace the group often repeated mnemonic.

REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS

W / in macro commands refer to the names of their respective mnemonics 6502, respectively BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS. Have the additional property that is the jump to the previously asemblowanej instructions, such as:

   lda: cmp: req 20 -> lda 20
                            -> Wait cmp 20
                            -> BEQ wait

   ldx # 0 -> ldx # 0
   mva: AD $ 500 x $ 600, x + -> loop lda $ 500, x
                            -> Sta $ 600, x
                            -> INX
                            -> Bne loop


SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS

W / in macro commands refer to the names of their respective mnemonics 6502, respectively BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS. Have the additional property that is the jump to the next asemblowanej instructions, such as:

   lda # 40 -> lda # 40
   add: sta $ 80 -> clc
   scc: inc $ 81 -> adc $ 80
                   -> Sta $ 80
                   -> Bcc skip
                   -> Inc $ 81
                   -> Skip


JEQ, jne, JPL, JMI, JCC, JCS, JVC, JVS

W / in macro commands refer to the names of their respective mnemonics 6502, respectively BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS. Have the additional property that is the conditional jump to a specified address, with their help, we can not just jump in -128 .. 127 bytes but in the whole range 64kB example:

 jne dest -> BEQ * 4
            -> Jmp dest

If the pitch is short (range -128 .. 127) then uses a short stroke MADS, respectively BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS.


ADD, SUB

W / in macro commands implement appropriate increase / decrease the byte of memory without saving it (the result in the battery CPU).

  ADD -> CLC SUB -> SEC
      -> ADC ... -> SBC ...


ADB, SBB

W / in macro commands implement appropriate increase / decrease the byte of memory storing the result.

  ADB SRC # $ 40 -> LDA SRC ADB A B C -> LDA A
               -> CLC -> CLC
               -> ADC # $ 40 -> ADC B
               -> SRC STA -> STA C

  SBB SRC # $ 80 -> LDA SRC SBB A, B, C -> LDA A
               -> SEC -> SEC
               -> SBC # $ 80 -> SBC B
               -> SRC STA -> STA C


ADW, SBW

W / in macro commands implement appropriate increase / decrease in memory word of saving the result.

  ADW SRC # $ 40 -> CLC ADW A B C -> CLC
               -> LDA SRC -> LDA A
               -> ADC # $ 40 -> ADC B
               -> SRC STA -> STA C
               -> SCC -> LDA A 1
               -> SRC INC 1 -> ADC B 1
                                             -> STA C +1

  ADW SRC SRC # $ 40 -> CLC
                   -> LDA SRC
                   -> ADC # $ 40
                   -> STA SRC
                   -> LDA SRC 1
                   -> ADC # $ 00
                   -> STA SRC 1
                                             
  SBW SRC # $ 4080 -> SEC SBW A B C -> SEC
                 -> LDA SRC -> LDA A
                 -> SBC <$ 4080 -> SBC B
                 -> SRC STA -> STA C
                 -> LDA SRC +1 -> LDA A 1
                 -> SBC> $ 4080 -> SBC B +1
                 -> STA SRC 1 -> STA C +1


PHR, PLR

W / in macro commands refer to the names of their respective mnemonics 6502, respectively PHA, PLA, carry out the deposition on the stack and remove from the stack the registers A, X, Y.

  PHR -> PHA PLR -> PLA
       -> TXA -> TAY
       -> PHA -> PLA
       -> Yeah -> TAX
       -> PHA -> PLA


INW, INL, IND, DEW, DEL DED

Macro commands INW, INL, IND implement more appropriate words of memory (. WORD), long word memory (. LONG), double word memory (. DWORD).

Macro commands DEW, DEL DED perform adequately reduce the memory word (. WORD), long word memory (. LONG), double word memory (. DWORD) and use for this purpose CPU battery (battery content is changed after the macro commands DEW, DEL DED).

    inv dest -> inc dest -> dest inc
              -> Bne skip -> sne
              -> Inc dest +1 -> dest inc 1
              -> Skip ->

    dew dest -> lda dest -> dest lda
              -> Bne skip -> sne
              -> Dest dec 1 -> dest dec 1
              -> Skip dec dest -> dest dec


MVA, MVX, MVY

Macro commands MVA, MVX, MVY are used to transfer bytes (. BYTE) of memory using the CPU registers, respectively A, X, Y. If you use OPT R + allows you to potentially reduce the object code for successive macro commands MVA, MVX, MVY.

    lda src -> dst src mva
    sta dst ->

    ldy $ 10, x -> MVY $ 10 x $ a0, x
    January $ a0, x ->

    ldx # $ 10 -> MVX # $ 10 dst
    stx dst ->


MWA, MWX, MWY

Macro commands MWA, MWX, MWY words are used to transfer (. WORD) of memory using the CPU registers, respectively A, X, Y. If you use OPT R + allows you to potentially reduce the object code for successive macro commands MWA, MWX, MWY.

    ldx # MWX <adr -> dst addr
    stx dst ->
    ldx> addr ->
    dst stx 1 ->

    mwa # 0 $ 80 -> lda # 0 mwy # $ 3040 $ 80 -> ldy <$ 3040
                -> Sta $ 80 -> January $ 80
                -> Sta $ 81 -> ldy> $ 3040
                                                     -> January $ 81

    mwa ($ 80), y $ A000, x -> lda ($ 80), y
                         -> Sta $ A000, x
                         -> Ins
                         -> Lda ($ 80), y
                         -> Sta $ A001, x


CPB, CPW, CPL, CPD

Macro commands CPB, CPW, CPL, CPD perform comparison of the respective types, respectively. BYTE. WORD. LONG. DWORD.

 CPW temp # $ 4080
 skip bcc

 cpd v0 v1
 BEQ skip


PSEUDO COMMANDS

 IFT [. IF] expression
 ELS [. ELSE]
 ELI [. ELSEIF] expression
 EIF [. Endif]
 
 ERT ERT 'string' ["string"] | ERT expression

 EQU address label
 label = address

 EXT address label

 OPT [bcfhlmorst ][+-]
 ORG [[expression]] address [, Address2]
 INS 'filename' ['filename "][*][+- ][,+- value offset [, length]]
 ICL 'filename' ['filename']
 DTA [abfghltv] (value1, value2 ...)[( value1, value2 ...)]
 DTA [cd] 'string' ["string"]
 RUN address
 INI address
 END [. EN]

 SIN (center, amp, size [, first, last])
 RND (min, max, length)

 : Repeat

 BLK N [they] X
 BLK D [os] X
 BLK S [Part] X
 BLK R [eloc] M [ain] | E [Xtended]
 BLK E [mpty] X M [ain] | E [Xtended]
 BLK U [PDATE] S [ymbols]
 BLK U [PDATE] E [xternal]
 BLK U [PDATE] A [dress]
 BLK U [PDATE] N [ew] X 'string'

 SMB label 'string'

 NMB
 RMB
 LMB # value

So most of the old way, although few changes had taken place. In the case of quotes you can use '' or "." Both types of quotation marks are treated equally with the exception of addressing (the''value will be calculated ATASCII sign for "" will be calculated the value INTERNAL sign).

BLK

 BLK N [they] X - block without captions, program counter set to X

 BLK D [os] X - block DOS $ FFFF with a header or without header when
                                   previous same program counter set to X

 BLK S [Part] X - a block of addresses fixed charge of $ header FFFA,
                                   program counter set to X

 BLK R [eloc] M [ain] | E [Xtended] - relokowalny block is placed in memory or EXTENDED MAIN

 BLK E [mpty] XM [ain] | E [Xtended] - block booking relokowalny X bytes in memory or EXTENDED MAIN
                                   NOTE: The program counter is immediately incremented by X bytes

 BLK U [PDATE] S [ymbols] - block updating in the previous blocks or SPARTA
                                   Reloc addresses, symbols, SDX

 BLK U [PDATE] E [xternal] - block updater addresses external label (header $ FFEE)
                                   NOTE: Not applicable Sparta DOS X, is an extension to the MADS-and

 BLK U [PDATE] A [dress] - updated block of addresses in blocks reloc

 BLK U [PDATE] N [ew] X 'string' - block declaring a new symbol 'string' in the block reloc
                                   X. When the address of the symbol name is preceded by an @,
                                   and the address is of primary memory is such a symbol may be
                                   called from command.com

More information about the blocks in Sparta DOS X-Files Building in chapter X and DOS SPARTA SPARTA DOS Programming X.


SMB label 'string'

Declaration label as a symbol of SDX. The symbol may have a maximum length of 8 and in character. Thus after using BLK UPDATE SYMBOLS assembler will generate the correct symbols block updates. For example:

       pf smb 'printf'
           jsr pf
           ...

that after the user makes JSR SDX system inserts the address of the symbol.

Note: This declaration is not transitive, it means that this example will cause errors during compilation:

       cm smb 'COMTAB'
       wp equ cm-1 (error!)

           constant wp

Instead, use:

       cm smb 'COMTAB'

           hundred cm-1 (ok!)

Note: All declarations of symbols should be used before the label declarations as well as the right program!

: Repeat

Example:
           4 asl @
           2 dta a (*)
           256 dta # / 8

The ':' specifies the number of repetitions of the line (in the case of macro parameter specifies the number provided that the numerical value is stored in decimal system). The number of repetitions should be in the range <0 .2147483647>. In repeating the line ': repeat' it is possible to use the loop counter - a hash sign '#'.

If we use the character ':' in a macro in the sense of the number of repetitions of lines, eg:

. Macro test
 2 LSR @
. Endm

Then for w / in the example the character ':' is interpreted as the second parameter to the macro. To prevent such an interpretation by the MADS, is after the colon character ':' to put a sign that does nothing, such as the plus sign '+'.

. Macro test
 : +2 LSR @
. Endm

Now, a colon ':' will be correctly interpreted as: repeat

OPT
OPT pseudo command allows to activate / deactivate additional options when assembling.

 b + bank on sensitive
 b-sensitive bank off (default)
 c + includes support for CPU 65816 (16bit)
 c-enables support for the CPU 6502 (8bit) (default)
 f + resulting file as a single block (useful for carta)
 f-the resulting file as a block (default)
 h + writes a header file for DOS (default)
 h-does not save the header file for DOS
 l + writes to a file listing (LST)
 l-does not save Listing (LST) (default)
 m + saves the entire macro in Listing
 m-stores in the listing only that portion of the macro that is executed (default)
 + writes the result to assemble the output file (OBX) (default)
 o-assemble as a result does not save the output file (OBX)
 r + optimized code length for the MVA, MVX, MVY, MWA, MWX, MWY
 r-without optimizing the code length for the MVA, MVX, MVY, MWA, MWX, MWY (default)
 s + prints a listing on screen
 s-listing does not print on the screen (default)
 t + REP SEP track on (65816 CPU)
 t-track off SEP REP (65816 CPU) (default)
 ? + Labels with a '? " at the beginning are local (IEA style)
 ? - A label with a '? " at the beginning are temporary (default)

Example:
 
 OPT c + c - l + s +
 OPT h
 OPT, o +

All the options we can use OPT anywhere in listing, eg, we can turn on the record listing in line 12 and line 20 off, etc., then the listing file will contain only the lines of the 12th .20.
If you want to use the 65816 addressing modes, we need to inform the assembler by the 'OPT C +'.

If you use Codega we can use 'OPT S +', so that we do not have to go to the listing file, because the listing is printed in the lower pane (the Output Bar).

ORG
ORG pseudo command sets a new address assemble, and hence the location of zasemblowanych data in RAM.

 Assemble at address adr ADR, set the address in the header file for ADR
 adr, adr2 Assemble at address ADR, set the address in the header file ADR2
 [B ($ ff, $ fe)], change the header at $ FFFE (2 bytes are generated)
 [$ Ff, $ fe], addr change the header at $ FFFE, set the address in the header file for ADR
 [$ D0, $ fe], addr, adr2 change the header on $ D0FE, Assemble at address ADR, set the address in the header file ADR2
 [A ($ FFFA)], addr $ SpartaDOS faff header, set the address in the header file for ADR

Example:

 h-opt
 ORG [a ($ ffff), d'atari 'c'ble', 20,30,40], addr, adr2

Square brackets [] are designed to identify a new header, which can be any length. Other values ??for the closing bracket ']', separated by commas ',' mean, respectively, assemble the address, the address in the header file.
Example of a header for the file in a single block, asemblowanego from address $ 2000, in the header of the specified start address and end address block.

Example:

 opt h-f +
 ORG [a (start), and (over-1)], $ 2000

start
 nop
 . Ds 128
 nop
over


INS 'filename' ['filename "][*][+- ][,+- value offset [, length]]
Pseudo INS command allows adding a binary file. Included file does not need to be in the same directory as the main assemble the file. Just that, properly pointed out these MADS-search path by using the / i (see switch assembly).
Additionally, you can perform on the attached binary file operations:

* Inverse bytes of binary
+-VALUE to increase / decrease the value of bytes of the binary expression for value VALUE

+ Offset byte offset to bypass the beginning of a binary file (SEEK offset)
-Offset reading binary file from its end (SEEK FileLength-offset)

LENGTH LENGTH bytes to read binary file

If the value of LENGTH is not specified, the default binary file will be read to the end.


ICL 'filename' ['filename']

Pseudo ICL command allows you to attach an additional source file and its assembly. Included file does not need to be in the same directory as the main assemble the file. Just that, properly pointed out these MADS-search path by using the / i (see switch assembly).

DTA
Pseudo DTA command data definition is for a specific type. If the type is not specified then the default is set to BYTE type (b).

   b value of type BYTE
   a value of type WORD
   v value of type WORD, relokowalna
   l byte value (BYTE)
   h byte value (BYTE)
   t value of type LONG (24bit)
   e value of type LONG (24bit)
   f DWORD (32bit)
   g DWORD (32bit) in reverse order
   c string ATASCII limited quotes''or "" character * at the end will
       inverse string value, eg c'abecadlo dta '*
   d string INTERNAL limited quotes''or "" character * at the end will
       inverse string value, such as ABC d'dta '*

Example:

  dta 1, 2, 4
  dta a ($ 2320, $ 4444)
  dta d'sasasa ', 4, and (200), h ($ 4000)
  dta c 'file', $ 9b
  dta c'invers' *


SIN (center, amp, size [, first, last])

where:

center is a number Which is added to every sine value
amp is the sine amplitude
size is the sine period
first, last define range of values ??in the table. They are optional.
           Default are 0, size-1.

Example: dta a (sin (0,1000,256,0,63))
         Defines table of 64 words Representing a quarter of a sine with
         amplitude of the 1000th


RND (min, max, length)
This command allows you to generate pseudo-random value of LENGTH <MIN..MAX> interval.

Example: dta b (rnd (0,33,256))


IFT, ELS, ELI, EIF

 IFT [. IF] expression
 ELS [. ELSE]
 ELI [. ELSEIF] expression
 EIF [. Endif]

W / in pseudo orders and directives affect the course of assembling (you can use them interchangeably.)

DIRECTIVE

 . ALIGN N ??[, fill]
 
 . ARRAY index label type [= default_value]
 . ENDA [. AEND]

 . DEF label [= expression]

 . ENUM label
 . Ende, [. Eend]

 . ERROR [ERT] 'string' ["string"] or. ERROR [ERT] expression

 . EXTRN label [, Label2 type ,...]

 . IF [IFT] expression
 . ELSE [ELS]
 . ELSEIF [ELI] expression
 . ENDIF [EIF]

 . IFDEF label
 . Ifndef label

 . LOCAL label
 . Endl, [. LEND]

 . LINK 'filename'
 
 . MACRO label
 . ENDM [. MENDE]
 :[%%] Parameter
 . EXITM [. EXIT]

 . Nowarn

 . PRINT [. ECHO] 'string1', 'string2'..., value1, value2, ...

 . PAGES [expression]
 . ENDPG [. PGEND]

 . PUBLIC [. GLOBAL], [. GLOBL] label [, ,...] Label2

 . PROC label
 . ENDP [. PEND]
 . REG. VAR

 . REPT expression [, parameter1, parameter2, ...]
 . Endre [. Rend]
 . R

 . Reloc [. BYTE |. WORD]

 . STRUCT label
 . ENDS [. SEND]

 . SYMBOL label
 
 . SEGDEF address label length [bank]
 . SEGMENT label
 . ENDSEG
 
 . USING [. USE] proc_name, local_name

 . VAR var1 [= value], var2 [= value] ... (. BYTE |. WORD |. LONG |. DWORD)
 . ZPVAR var1, var2 ... (. BYTE |. WORD |. LONG |. DWORD)

 . END

 . EN

 . BYTE
 . WORD
 . LONG
 . DWORD

 . OR
 . AND
 . XOR
 . NOT

 . LO (expression)
 . HI (expression)

 . DB
 . DW
 . DS expression

 . BY [+ byte] bytes and / or ASCII
 . WO words
 . HE hex bytes
 . SB [+ byte] bytes and / or ASCII
 . CB [+ byte] bytes and / or ASCII
 . FL floating point numbers

 . ADR label
 . LEN label

 . GET [index] 'filename' ['filename "][*][+- ][,+- value offset [, length]]
 . PUT [index] = value
 . SAV [index] ['filename'] length


. SYMBOL label

Directive. SYMBOL command is equivalent to the pseudo-SMB with the difference that they do not need to specify a symbol, a symbol of the label is the label. Directive. SYMBOL can be placed anywhere on the block relokowalnego SDX (BLK reloc) in contrast to the SMB.

If there was a directive. SYMBOL block will generate the appropriate update:

UPDATE BLK NEW LABEL 'LABEL'

More on the declarations of symbols SDX symbol in chapter Defining an SMB.


. ALIGN N ??[, fill]
Directive. ALIGN align address allows you to assemble a set value N, and potentially fill the memory FILL preset value. It is possible to assemble an address alignment code relokowalnego provided that we give the value of the memory fill FILL.

The default values ??are: N = $ 0100, FILL = 0

Example:

 . Align

 . Align $ 400
 
 . Align $ 100, $ ff


. REPT expression [, parameter1, parameter2, ...]
The Directive is a development REPT: repeat, except that no one line is repeated, only the selected program block. Beginning of a block is defined in the Directive. REPT, it must occur when the value or arithmetic expression specifying the number of repetitions of the range <0 .2147483647>, the number of repetitions can occur optional parameters. In contrast to the macro parameters. REPT always are first calculated and only the result is substituted (this feature can be used to define new labels). The parameters in the block. REPT use as parameters in the block. MACRO. The end of the block. REPT directive defines. Endre, before which there should be no label.

Additionally, in the block marked by. REPT and. Endre we can have a hash sign '#' (or directive. R), which returns the current value of the loop counter. REPT (as well as for repeat).

Example:

 . Rept 12 # * 2 # * 3; blocks. REPT we can connect with: rept
 : 4 dta: 1;: 4 to distinguish a repeat count of parameter: 4
 : 4 dta: 2
 . Endre

 . Rept 9, #, we define nine labels label8 label0 ..
Label: 1 mva # 0 $ D012 + #
 . Endre


. PAGES [expression]
Directive. PAGES allows you to specify the number of memory pages which should fit into our piece of code delimited by <. PAGES .. . ENDPG> (the default is set to 1). If the code exceeds the declared number of memory page then it will generate an error message The error at ????.

These directives can help us when we want to fragment the program ranged from one memory page, or when we write a program housed in the additional memory banks (64 memory page), eg:

Example:

 org $ 4000
 
 . Pages $ 40
  ...
  ...
 . Endpg


. SEGDEF address label length [attrib] [bank]
. SEGMENT label
. ENDSEG

Directive. SEGDEF LABEL defines a new segment starting address and length ADDRESS LENGTH, additionally it is possible to define an attribute for the segment (R-read, In-rite, RW-ReadWrite - default) and assign a virtual bank number BANK (BANK default = 0).

Directive. SEGMENT activates recording LABEL object code segment. If you exceed the set length of the segment will generate an error segment error at ADDRESS LABEL.

Directive. ENDSEG end segment to the current record, restores the record to the main program block.

Example:

. Segdef sData adr0 $ 100
. Segdef adr1 test $ 40

org $ 2000

nop

. Cb 'ALA'

. SData segment

nop

. Endseg

lda # 0

. Segment test
ldx # 0
clc

dta c'ATARI '

. Endseg

adr0. ds $ 100
adr1. ds $ 40


. END
Directive. END may be used interchangeably with the directives. ENDP. ENDM. ENDS. ENDA. Endl. Endre. ENDPG. ENDW. ENDT


. VAR var1 [= value1], var2 [= value2] ... (. BYTE |. WORD |. LONG |. DWORD) [= address]
Directive. VAR is used for declaration and initialization of variables in the main program block and the blocks. PROC and. LOCAL. MADS does not use the information on these variables in further operations involving the pseudo-and macro commands. Acceptable types of variables is. BYTE. WORD. LONG. DWORD and their multiples, as well as the type declared by. STRUCT and. ENUM for example:

Example:

 . Var a, b, c, d. Word, 4-type variables. WORD
 . Var a, b, f: 256. Byte; 3 variables each with a size of 256 bytes
 . Var c = 5, d = 2, f = $ 123,344. Dword; 3 variables. DWORD values ??of 5, 2, $ 123,344

 . Var. Byte i = 1, j = 3, 2-type variables. BYTE with values ??1, 3

 . Var a, b, c, d. Byte = $ A000, 4-type variables. Byte of the address sequence $ A000, $ A001, $ A002, $ A003
 
 . Var. Byte a, b, c, d = $ a0, 4 variables of type byte, the last zmiennna 'D' with a value of $ A0
                                 ;! for such recording is not possible to specify an allocation of variables

  . Proc name
  . Var. Word p1, p2, p3; declaration of three variables. WORD
  . Endp

 . Local
  . Var a, b, c. Byte
  lda and
  ldx b
  ldy c
 . Endl

 . Struct Point, a new type of structured data POINT
 x. byte
 y. byte
 . Ends

  . Var a, b Point; declaration of structural variables
  . Var Point c, d, equivalent to the syntax 'label DTA POINT'

So declared variables are physically allocated until the end of the block in which it was declared after the directive. ENDP. Endl (. END). The exception is the block. PROC where the variables declared by. VARs are always allocated from the Directive. ENDP whether the block procedure, there are any additional blocks. LOCAL variables declared by. VAR


. ZPVAR var1, var2 ... (. BYTE |. WORD |. LONG |. DWORD) [= address]
Directive. ZPVAR used to zero the variable declarations in the main program block and the blocks. PROC and. LOCAL. Trying to assign values ??(initiation of this fire) this variable will generate a warning message Uninitialized variable. MADS does not use the information on these variables in further operations involving the pseudo-and macro commands. Acceptable types of variables is. BYTE. WORD. LONG. DWORD and their multiples, as well as the type declared by. STRUCT and. ENUM for example:

Example:

 . Zpvar abcd. Word = $ 80; 4 variables type. WORD of the address of the initial $ 0080
 . Zpvar ij. Byte, two additional variables from the address $ 0080 8

 . Zpvar. Word a, b, 2 type variables. WORD
                                ;! for this syntax is not possible to determine the address variables

 . Struct Point, a new type of structured data POINT
 x. byte
 y. byte
 . Ends

  . Zpvar a, b Point; declaration of structural variables
  . Zpvar Point c, d, equivalent to the syntax 'label DTA POINT'

So declared the variable of zero will be assigned addresses only at the end of the block in which it was declared after the directive. ENDP. Endl (. END). The exception is the block. PROC where alternating declared by. ZPVAR addresses are assigned before the Directive. ENDP whether the block procedure, there are any additional blocks. LOCAL variables declared by. ZPVAR.

On first use of the Directive. ZPVAR be zaincjowac what will be assigned to address another variable (default address is $ 0080).

Example:

 . Zpvar = $ 40

With each variable, this address is automatically incremented by the MADS-and, if the addresses of variables, repeated a warning message is generated Access violations at address $ xxxx. In case of exceeding the scope of the zero is generated error message Value out of range.


. PRINT [. ECHO]
To print the parameter values ??specified as a string expression or a limited quotes '' or "", eg:

Example:

 . Print "End: ",*,'..',$ 8000 -*
 . Echo "End: ",*,'..',$ 8000 -*


. ERROR [ERT] 'string' ["string"] |. ERROR [ERT] expression
Directive. ERROR ERT and pseudo orders have the same meaning. Stop assembling the program and displays the message given as parameter, limited quotes '' or "." If the parameter is a boolean expression, then assembling is stopped when the logical expression is true (User error message), eg:

Example:

 ert "halt" ERROR: halt
 . Error "halt"

 ert *> $ 7FFF; ERROR: User error
 . Error *> $ 7FFF


. BYTE. WORD. LONG. DWORD
W / in the directive are used to determine the acceptable parameter types in the parameter declaration procedure (. BYTE. WORD. LONG. DWORD). It is also possible to use them for data definition, the pseudo command replacing the DTA.

Example:

. Proc test (. Word tmp, a, b. Byte value)

 . Byte "atari", 5.22
 . Word 12, $ FFFF
 . Long $ 34518F
 . Dword $ 11223344


. DB
BYTE data type definition, the equivalent of pseudo-B order DTA or directive. BYTE


. DW
Definition of data type WORD, the equivalent of a pseudo-DTA command or directive. WORD


. DS expression
This directive was derived from MAC'65, you reserve memory without prior initialization. This is equivalent to a pseudo command ORG + expression. Directive. DS can not be used in code relokowalnym like ORG-a.

purpose: Reserves space for data space without initializing it then any Particular value (s).

usage: [label]. DS expression

Using. "DS expression" is exactly equivalent of using "ORG * + expression." That is, the label
(If it is given) is set equal to the current value of the location counter. Then then value
of the expression is then added the location counter.

Example: BUFFERLEN. DS 1; reserve a single byte
         BUFFER. DS 256; reserve 256 bytes


. BY [+ byte] bytes and / or ASCII

Store byte values ??in memory. ASCII strings can be Specified by enclosing the string in single or double Either quotes.
If the first character of the operand field is a '+', then the byte Following Will Be used as a constant and added to all Remaining bytes of the instruction.

Example:
      . BY + $ 80 1 $ 10 10 'Hello' $ 9B

will generate:
        8A 81 90 C8 E5 EF 1B EC EC

Values ??in. BY statements May also be separated with commas for compatibility with other assemblers. Spaces are allowed since They Are easier to type.


. WO words
Stores words in memory. Multiple words can be Entered.


. HE hex bytes
Store hex bytes in memory. This is a convenient method to enter strings of hex bytes, since it does not require the use of the '$' character. The bytes are still separated by spaces however, which i feel makes a much more readable layout than the 'all run together' form of hex That statement some other assemblers use.

Example:. HE 0 55 AA FF

. SB [+ byte] bytes and / or ASCII
This is in the same format as the. BY pseudo-op, except That it will convert bytes into ATASCII all codes screen before Storing Them. The conversion is done ATASCII before any constant is added with the '+' modifier.


. CB [+ byte] bytes and / or ASCII
This is in the same format as the. BY pseudo-op, except the last character That on the line will be EOR'ed with $ 80


. FL floating point numbers
Stores 6-byte BCD floating point numbers for use with the OS FP ROM routines.


. EN
Directive. EN is equivalent to the pseudo-command END marks the end of the block asemblowanego program.

This is an optional pseudo-op to mark the end of assembly. It Can Be Placed before the end of your source file to Prevent a portion of it from being assembled.


. ADR label
Directive. ADR LABEL returns before the change of address, assemble (you can put a name label LABEL between parentheses or square), for example:

 org $ 2000

. Percent tb, $ 1000
tmp lda # 0
. Endp

 lda. tb.tmp addr; = $ 2000
 lda tb.tmp; = $ 1000


. LEN label
Directive. LEN returns the length (expressed in bytes) of the block. PROC. ARRAY. LOCAL. STRUCT. LABEL label is the name of the block. PROC. ARRAY. LOCAL or. STRUCT (it is possible to put a name label LABEL between parentheses or square), for example:

label. array [255]. dword
      . Enda

      dta a (. len label) = $ 400

. Proc wait
 lda: cmp: req 20
 rts
. Endp

 dta. len wait; = 7


. DEF label [= expression]
Directive. DEF allows you to check the presence of the definition of LABEL, or define it. If the label is defined which returns a TRUE, otherwise it returns 0 or FALSE. It is possible to put a name label LABEL between parentheses or square, for example:

 ift. not (. def label)
 . Def label
 e and f

This unary operator Whether the tests has been Following label defined yet, returning TRUE or FALSE as appropriate.

CAUTION: Defining a label AFTER the use of a. DEF Which references it can be dangerous, particularly if the. DEF is used in a. IF directive.

. IFDEF label
Directive. IFDEF is a shorter equivalent condition. IF. DEF LABEL

Example:

. Ifdef label
       jsr proc1
. Else
       jsr proc2
. Endif


. Ifndef label
Directive. Ifndef condition is shorter counterpart. IF. NOT. DEF LABEL

Example:

. Ifndef label
      clc
. Else
      sec
. Endif

For n / in the example of assembling the block. Ifndef (. IF) will take place only in the first pass, if you put in that block any program code certainly will not be generated to a file, definitions of the labels will be carried out only in the first pass, if there are any errors associated with their defining we learn about them only when you try to appeal to such labels, this is the error message label LABEL_NAME Undeclared

 . Ifndef label
 . Def label
 lda # 0; this order will not be zasemblowany, only the last course of assembling generates code
 temp = 100; label TEMP is defined in only one course of assembling
 . Endif


. Nowarn
Directive. Nowarn off warning message for the current row asemblowanego program.

Example:

. Nowarn. Proc temp, no warning will be generated 'Unreferenced procedure TEMP'
        . Endp


. USING [. USE]
Directive. USING (. USE) allows you to specify an additional path to search for the names of labels. Action. USING (. USE) is valid in the current namespace and containing the following in this space.

Example:

. Local move

tmp lda # 0
hlp sta $ A000

. Local move2

tmp2 ldx # 0
hlp2 stx $ B000

. Endl

. Endl

. Local main

. Move.move2 use

       lda tmp2
 
. Use move

       lda tmp

. Endl


. GET [index] 'filename' ... [. BYTE. WORD. LONG. DWORD]
This is equivalent to Pseudo INS command (like syntax), except that the file is not included in asemblowanego file loaded into memory only the MADS-a. This directive allows you to load the specified file to the memory of the MADS-a and refer to the bytes of the file as the one-dimensional array.

Example:

 . Get 'file'; load the file into an array and the MADS-
 . See [5] 'file'; load the file into an array and the MADS-index = 5

 . Get 'file', 0.3, load it to an array of MADS-and three-four values

 lda #. See [7], 7 byte read from the array and the MADS-
 address =. See [2] +. See [3] <<8, 2 and 3 of byte in the file header contains information about the DOS boot address

By means of directives. GET. PUT can be read eg Theta Music Composer module (TMC) and make his relocation. This implements attached to the MADS-and macro directory .. / EXAMPLES / MSX / TMC_PLAYER / tmc_relocator.mac.

The permitted range of values ??for INDEX = <0 .65535>. The values ??read by. Are of type GET BYTE.


. PUT [index] = value
Directive. PUT can refer to a one-dimensional array in memory and the MADS-and save it a value of type BYTE. This is the same array to which the Directive. GET saves the file.

The permitted range of values ??for INDEX = <0 .65535>.

Example:

 . Put [5] = 12; save the value 12 in the MADS-talicy and at 5 o'clock


. SAV [index] ['filename'] length
Directive. SAV allows you to save the buffer used by the Directive. GET. PUT to an external file, or join the currently asemblowanego.

Example:

 . Sav? Length, attach to the contents of the file asemblowanego buffer [0.? Length-1]
 . Sav [200] 256; join asemblowanego file buffer contents [200th +256-1 .200]
 . Sav [6] 'filename', 32, and save the file FILENAME into the buffer [6th .6 +32-1]

The permitted range of values ??for INDEX = <0 .65535>.


. OR. AND. XOR. NOT
W / in the directive are counterparts of the logical operators | | (. OR) & & (. AND), ^ (. XOR),! (. NOT.)


. LO (expression). HI (expression)
W / in the directive is properly equivalent operators '<' (low byte) and '>' (high byte).


. IF. ELSE. ELSEIF. ENDIF

 . IF [IFT] expression
 . ELSE [ELS]
 . ELSEIF [ELI] expression
 . ENDIF [EIF]

W / in the Directive and pseudo orders influence the course of assembling (you can use them interchangeably), for example:

Example:

 . IF. NOT. DEF LABEL_NAME
   LABEL_NAME = 1
 . ENDIF

 . IF [. NOT. LABEL_NAME DEF]. AND [. NOT. Label_name2 DEF]
   LABEL_NAME = 1
   label_name2 = 2
 . ENDIF

W / in the example, parentheses (square or round) are a necessity, they would not have that for the first Directive. DEF parameter name labels would label_name.AND.NOT.DEFlabel_name2 (spaces are ignored and accepted a full stop in the name of the label).

DIRECTIVE OF GENERATING CODE 6502

 # IF type expression [. OR type expression] [. AND type expression]
 # ELSE
 # END

 # WHILE type expression [. OR type expression] [. AND type expression]
 # END

 # CYCLE # N
 

# IF type expression [. OR type expression] [. AND type expression]
The # IF statement is IF modest equivalent of higher-level languages ??(C, Pascal).

Directive # IF, # ELSE and # END allow to generate machine code the CPU 6502 IF conditional statement for a designated block of the program, they may be nesting. All types are acceptable. BYTE. WORD. LONG. DWORD, it is possible to combine more conditions by means of directives. OR and. AND, it is not possible to determine the order of evaluation by parentheses.

Implementation of the Directive # if starts with a simple calculation of the expression ie one which consists of two operands and one operator (expression, we can combine directives. OR or. AND).

If the expression has a nonzero value (TRUE), then the program will be executed block occurs when the # IF. Block such a program is automatically terminated instruction 'JMP' executing a jump to the next instruction program for Directive # END block if there are # ELSE.
If the expression is zero (FALSE), then the code is executing the program occurring after the # ELSE # ELSE directive when there is no control is transferred to the next instruction program for # END directive, eg:

# If. Byte label> # 10. Or. Byte label <# 5
# End

# If. Byte label> # 100

# Else

 # If. Byte label <# 200
 # End
 
# End

# If. Byte label> # 100. And. Byte label <# 200. Or. Word lab = temp
# End

# If. Byte @
# End
# WHILE type expression [. OR type expression] [. AND type expression]
The # WHILE WHILE statement is the equivalent of higher-level languages ??(C, Pascal).

Directive # # END WHILE and allow you to generate machine code the CPU 6502 for the designated block of the loop of the program, they may be nesting. All types are acceptable. BYTE. WORD. LONG. DWORD, it is possible to combine more conditions by means of directives. OR and. AND, it is not possible to determine the order of evaluation by parentheses.

The sequence of actions to implement Directive # WHILE statement is as follows:

    1st Calculate the value of the expression and make sure it is equal to zero (FALSE).
        if so, skip step 2;
        if not (TRUE), go to step 2
    2nd Follow the program block bounded directives # and # END WHILE, then go to step 1

If the first valuation expression shows that it is zero, the program block is never executed and control passes to the next instruction program for Directive # END

# While. Byte label> # 10. Or. Byte label <# 5
# End

# While. Byte label> # 100
 # While. Byte Label2 <# 200
 # End
# End

# While. Byte label> # 100. And. Byte label <# 200. Or. Word lab = temp
# End


# CYCLE # N

The # CYCLE 6502 code allows to generate a given number of cycles. The generated code does not modify any memory cell, or CPU register.

# Cycle # 17; pha 3 cycle
            ; Beach 4 cycle
            ; Pha 3 cycle
            ; Beach 4 cycle
            ; Cmp $ 00 3 cycle
                      ---------
                      17 cycle


Assembling at zero

In contrast to the two-przebiegowych assemblers such as QA and XASM, MADS is a multi-pass mode. What gives?
Let us take an example:

 org $ 00
 
 lda tmp 1
 
tmp lda # $ 00

Two-pass mode without knowing assembler label values ??TMP adopts by default, that its value will be a two-byte, or WORD, and generate orders LDA W.

MADS politely while the zero-order to generate LDA Z. And this is actually the main and simplest to explain the jurisdiction of more runs.
Now someone will say that the will of the order referring to the zero is in the form of LDA W. No problem, just that it will expand the mnemonic:

 org $ 00
 
 lda.w tmp 1
 
tmp lda # $ 00

They are allowed three extensions mnemonics

 . B [. Z]
 . In [. And] [. Q]
 . L [. T]

respectively the BYTE, WORD, LONG (TRIPLE). Of which latter generates 24bit value and refers to the memory of 65,816 and a continuous area (I doubt if ever you use this command.) For more information on mnemonics CPU 6502, 65816 and their allowable extensions in Chapter mnemonics.

Another way to enforce a zero-order page is to use curly braces {}, eg

 dta {00} $ lda, $ 80; lda $ 80

The MADS we can do the same, but after that, the last course do the trick for us:) The problem is now to place such a piece of code in computer memory. We can try to load the program directly to page zero and if the target area is located in the border $ 80. $ FF OS is probably survive below this area will be harder.

Therefore, MADS allows such a thing:

 org $ 20, $ 3080
 
 lda tmp 1
 
tmp lda # $ 00

So Assemble at address $ 0020, but the address reload $ 3080th Of course, the subsequent transfer of code to the right place (in our example $ 0020) belongs to the programmer's task.

In summary:

 org Address1, Address2

Address1 assembles the address, put the address in memory Address2. The ORG will always create a new block in the file, which saved an additional four bytes of the header of the new block.
If you do not care about the new address placement of data in memory address location data has to be current address then you can use the properties of the blocks. LOCAL and. PROC, header bytes are not written in such a case, for example:

     1
     2 org $ 2000
     3
     4 FFFF> 2000-200D> A9 00 lda # 0
     5 2002 EA nop
     6
     7 0060. Local temp, $ 60
     8
     9 0060 BD FF FF lda $ ffff, x
    0063 BE 10 FF FF ldx $ ffff, y
    11
    12. Endl
    13
    14 2009 A5 60 lda temp
    200B 15 AD 03 20 lda. Addr temp
    16

For w / in Example program block will zasemblowany TEMP to the new address = $ 60 and placed in memory at $ 2003. After ending the directive block (. Endl. ENDP. END) restore the pre-assemble the block address plus the length yet so zasemblowanego block in our example the address of which will continue after the end of assembling the block. LOCAL address will be $ 2009.

Then, using the directive. ADR and. LEN can be made to copy the block to the right place, for example:

      ldy # 0
mva copy. adr (temp), temp y, y +
      CpY #. len temp
      bne copy

For more information on the operation of the Directives. ADR and. LEN.


TYPES

MADS provides the possibility of declarations of the two types of data: structured. STRUCT and enumeration. ENUM

STRUCTURAL TYPE, STRUCTURE
If programowaliscie in C, you probably have already met with the structures. In general, MADS defines the structure of a virtual array, a one-dimensional fields of different types. BYTE. WORD. LONG. DWORD and their multiples. Virtual because it exists as yet only in the memory assembly.

The fields of this structure contain information about ofsecie to the beginning of the structure.

Declaration of structure (. STRUCT)

Structures of the n / a directive:

name. STRUCT
     . STRUCT name
     . ENDS [. SEND] [. END]

name. STRUCT
Declaration of the structure name with the Directive. STRUCT. The name of the structure is required and necessary, its absence will generate an error. The names of structures can not use the names of mnemonics and pseudo orders. If the name is reserved for an error with the message word Reserved.

Example of structure declaration:

. STRUCT name

  x. word; lda # name.x = 0
  y. word; lda # name.y = 2
  with. long; lda # name.z = 4
  v. dword; lda # name.v = 7

  q: 3. byte; lda # name.q = 11

. ENDS; lda # name = 14 (length)

The fields defined by the structure name and field type (. BYTE. WORD. LONG. DWORD). The field name may be preceded by "white space". In the area bounded by the directives. STRUCT and. ENDS can not use mnemonics CPU if you use them or we use other illegal characters with an error message syntax Improper or Illegal instruction.

In summary, the label name contains information about the structure of total length (in bytes). Other labels describing the fields contain information about ofsecie to the beginning of the structure.
Declaration can not be nested structure, already declared to be nested structure (in order of occurrence does not matter), eg:

. STRUCT temp

x. word
y. word
v. byte
with. word

. ENDS


. STRUCT test

tmp temp

. ENDS

 lda # temp.v
 lda # test.tmp.x
 lda # test.tmp.z

What may be useful for the structure?

Suppose we have an array of different types of fields, such fields can be read using an array of pre-defined offset value. But when we add an extra field to the table, or modify it in another way, we will have to improve the program code that used the prescribed values ??of offsets. When we define such an array using the structure we will be able to read its fields using the offsets stored in the declaration of the structure, which always will read the appropriate box regardless of the changes that have taken place in the array.

Another example of the structures was described in chapter external symbols, such as use of external symbols and structures. STRUCT.


Defining the structural data, the appeal

Defining the structural data is to assign a new label with a specific structure of the pseudo command DTA or without this pseudo-command. The result of this assignment is reserved memory, it is no longer a virtual creature.

DTA struct_name label [count] (data1, data2, data3 ...) (data1, data2, data3 ...) ...

label struct_name

COUNT specifies the number from the interval <0. COUNT>, which defines the maximum value of one-dimensional array index, and thus also the number of postponed in a structured data storage.
Example declaration of the structure and definition of structured data:

;----------------------;
; Statement structure;
;----------------------;
. STRUCT temp

x. word
y. word
v. byte
with. word

. ENDS

;---------------------;
; Defining data;
;---------------------;

dta data temp [12] (1,20,200,32000) (19,2,122,42700)

dta date2 temp [0]

data3 temp / / shorter counterpart date2

After the name of the structure in square brackets must be a value from the interval <0 .2147483647>, which defines the maximum value of one-dimensional array index, while the number of postponed in a structured data storage.

After the brackets may optionally list of initial values ??(limited parentheses), if there is not the default values ??are zero-field structure. In turn, if the list of initial values ??is less than the number of fields declared, then the remaining fields are initialized to the last values ??that were given, eg

dta data temp [12] (1,20,200,32000)

Such a declaration will make all the fields will be ignited 1,20,200,32000 values, not just the first field data [0].

If the list of initial values ??will be greater or less than the number of field structure, then there is an error with the message Constant expression violates subrange bounds.
To refer to this emerging field of data should give their name, be the index in square brackets and the field name after a dot, eg:

 lda data [4]. y
 ldx # data [0]. v

No square bracket with an index label [index] end in an error message Undeclared label.

Enumeration type, the calculations

Calculations to the n / a directive:

name. ENUM
     . Ende [. Eend] [. END]

Example:

. Enum PORTB
 rom_off = $ fe
 rom_on = $ ff
. Ende

. Enum test
 a, a = 0
 b b = 1
 c = 5 c = 5
 d, d = 6
. Ende

Declaration of the calculation is done using directives. ENUM and. Ende. The name of the calculation is required and necessary, its absence will generate an error. To the names of the calculations can not use the names of mnemonics and pseudo orders. If the name is reserved for an error with the message word Reserved.
The values ??of the next label is automatically incremented by 1 starting from the default value 0, value labels, you can define yourself, or leave it automatowi.

Label enumeration referenced using the syntax:

 enum_name (field)

or directly as in the case of appeals to the blocks. LOCAL. PROC, or the type name separated by dots are another field, such as:

 lda # PORTB (rom_off)

 dta portb.rom_on, portb.rom_off

Calculations we can use to declare the structure fields. STRUCT, the allocation of variables Directive. VAR, for example:

bank PORTB / / BANK variable allocation size of 1 byte
. Var bank PORTB / / BANK variable allocation size of 1 byte

. Struct test
 and PORTB
 b PORTB
. Ends

Size of an enumeration is dependent on the maximum value of the label they adopt another calculation, eg:

    . Enum Estate
        DONE DIRECTORY_SEARCH = $ ff, INIT_LOADING, LOADING
    . Ende

For w / variable allocation in the example of "Estate" will be the size of two bytes (WORD).

Size can be checked using the directive. LEN, the result will be a value of 1 .4 (1-byte, 2 = WORD, 3-LONG, 4-DWORD) eg:

 . Print. Len Estate


TABLES
Declaration of a vector (. ARRAY)
Tablets of the n / a directive:

name. ARRAY index type [= default_value]
     . ARRAY name count type [= default_value]
     . ENDA [. AEND] [. END]

Available data types are. BYTE. WORD. LONG. DWORD.

INDEX specifies the maximum value of the index array [0. INDEX], this value can be constant or expression, should be from the interval <0 .65535>. In the absence of administration INDEX-in will be determined based on the number entered values.
In the area bounded by the directives. ARRAY and. ENDA is not possible to use mnemonics CPU if you use them or we use other illegal characters, then there is an error with the message Improper syntax.

It is permissible to define an index from which you enter values ??for other fields of the array. The new value of this index is defined by placing at the beginning of a new line in square brackets expression [expression]. You can specify more indexes, including indexes to further breakdown of a colon ':'. Then enter values ??for the array after the equal sign '=', eg:

. Array tab. Byte; table TAB in advance for an indefinite number of fields
 1.3, [0] = 1, [1] = 3
 5; [2] = 5
 [12] = 1; [12] = 1
 [3]: [7]: [11] = 9.11, [3] = 9, [4] = 11, [7] = 9, [8] = 11, [11] = 9, [12] = 11
. Enda

This solution may seem strange, and its use limited, but there are occasions when it may be useful, for example, an array which translates the code of the pressed key code ATASCII or INTERNAL.

. Array TAB [255]. Byte = $ ff; allocate 256 bytes [0 .255] with initial value $ FF

 [63] [127] = 'A'; assign new values ??TAB [63] = 'A', TAB [127] = 'A'
 [21] [85] = "B"
 [18] [82] = 'C'
 [58] [122] = 'D'
 [42] [106] = "E"
 [56] [120] = "F"
 [61] [125] = 'G'
 [57] [121] = "H"
 [13] [77] = "I"
 [1]: [65] = "J"
 [5]: [69] = "K"
 [0]: [64] = "L"
 [37] [101] = 'M'
 [35] [99] = 'N'
 [8] [72] = "O"
 [10]: [74] = 'P'
 [47] [111] = "Q"
 [40] [104] = "R"
 [62] [126] = "S"
 [45] [109] = 'T'
 [11] [75] = 'U'
 [16] [80] = 'V'
 [46] [110] = "W"
 [22] [86] = "X"
 [43] [107] = "Y"
 [23] [87] = 'Z'
 [33] [97] = ""

 [52] [180] = $ 7e
 [12] [76] = $ 9b

. Enda

W / in the example we have created an array of size 256 TAB bytes [0 .255], the type of data. BYTE and filled the field value = $ FF, also saved the letter codes INTERNAL positions (array indices) equal to the code key is pressed (without SHIFT and from the Shift-and-em, the big and small letters).
The colon ':' separates the different indexes of the array.

Another example might be to keep the string centered, for example:

 org $ bc40

. Array txt 39. Byte
 [17] = "ATARI"
. Enda

In summary, the Directive. ARRAY allows you to create a one-dimensional array and filling it with values ??declared type.
For this we refer to the table created as follows:

 lda table, y
 lda table [23], x
 ldx tab [200]

If we give in square brackets in excess of the declared value of the index for the array, then there is an error with the message Constant expression violates subrange bounds.


MACROS

Macros help us perform repetitive tasks, automate them. There are only a memory assembly, only when calls are assemble. With their help, MADS can put on and take off from a software stack parameters for the procedures declared Directive. PROC switch banks, and expanded memory mode SENSITIVE BANK (OPT B +).

Declaration Macros

Macros to the n / a pseudo orders and directives:

name. MACRO ['separator'] ['separator']
     . MACRO name ['separator'] ['separator']
     . EXITM [. EXIT]
     . ENDM [. MENDE]
     :[%%] Parameter

name. MACRO ['separator'] ['separator']
Declaration of the macro named name with the Directive. MACRO. Macro name is required and necessary, its absence will generate an error. Macro names can not use the names and pseudo-instruction mnemonic (Reserved word error).

At the end of a macro declaration may occur at the same time the declaration of the separator and the mode of passing parameters to the macro (single apostrophe unchanged, smashing a double apostrophe with the parameters and argument addressing mode).

The default separator, separating the parameters passed to the macro is a comma ',' and space ''.

name. MACRO 'separator'

Between the single quotes''we can put the separator character that will be used to separate parameters when invoking the macro (only to serve single apostrophes).

name. MACRO "separator"

Between double quotes "" We can also put the separator character that will be used to separate parameters when calling the macro. In addition, use a double apostrophe indicates that these MADS-decomposed parameters passed on two elements: addressing mode and an argument, eg:

 Test # 12 200 <30

test. macro ""
. Endm

Macro Test is declared separator-space using the apostrophe ', or after calling the macro parameters are spread over two elements, and addressing mode argument.

 # 12 -> addressing mode '#' argument 12
 200 -> addressing mode '' argument 200
 <30 -> addressing mode '#' argument 0 (the calculated value of the expression "<30")

 test '#' 12 '' 200 '#' 0

UAWAGA # 1: Parameters of the sign operator '<', '>' are calculated and only the result is passed to the macro (the parameter is substituted.)

UAWAGA # 2: If a macro parameter is the loop counter '#', '. R' (! Single character '#' or a directive. 'R' and not an expression involving this character, this directive!) Then the macro counter value is passed the loop (substituted for the parameter).
This property can be used to create a "samopiszacego" the code when you need to create new labels like "label0", "label1", "Label2", "label3" ... etc., eg:

 32 find #

find. macro
      ift. def label: 1
      dta a (label: 1)
      e and f
     . Endm

W / in the example writes the address label, provided that such a label exists (is defined).


. EXITM [. EXIT]
End the macro. Causing the absolute end of the macro.

. ENDM [. MENDE]
With the help of the Directive. ENDM or. MENDE finish the declaration of the current macro. It is not possible to use the directive. END as it does for other areas declared by the Directive. LOCAL. PROC. ARRAY. STRUCT. REPT

:[%%] Parameter
The parameter is the number of decimal positive (> = 0), followed by a colon ':' or two percent signs'%%'. If the macro you want to sign ':' defined number of repetitions and not simply the number of parameters that the next character after the colon will not be in the range '0 '.. '9', just for example:

 $ 2 nop
 : +2 Nop
 :% 10 nop

Parameter: 0 (%% 0) has a special meaning, contains the number of parameters passed. With his help we can check whether the required number of parameters was passed to the macro, for example:

  . IF: 0 <2 | | 0> 5
    . ERROR "Wrong number of arguments"
  . ENDIF

  IFT%% 0 <2. Or: 0> 5
    ERT "Wrong number of arguments"
  EIF

Example macro:

. Macro load_word

   lda <1
   sta: 2
   lda>: 1
   sta: 2 +1
 . Endm

 AD test
 eq test

. Macro test
  b%% a skip
. Endm

Calling macros

The macro call by its name, it may occur after the macro parameters, separated by a separator which is by default a comma ',' or spaces ''. The number of parameters depends on the memory PC. If you pass the number of parameters is less than the number of parameters used in the macro, then the missing parameters will be substituted with a value of -1 ($ FFFFFFFF). This property can be used to check whether the parameter was passed or not, but easier to do this with parameter zero%% 0th

 macro_name [Par1, PAR2, Par3, 'Par4', "string1" "string2" ...]

The parameter can be a value expression or a string limited apostrophe''single or double "."
Single quotes '' will be passed to the macro together with the marks located between
double quotes "" means string and only the string located between the quotes will be passed to the macro

All definitions of the labels within macros are local.
If you are looking for assembler label did not occur in the macro, then it will look in the local area (if you have experienced the Directive. LOCAL), then the procedure (if the procedure is currently being processed), at the end of the main program.

Example of macro call:

 macro_name 'a', a,> $ A000, cmp; for the default separator ','
 macro_name 'a'_a_> $ a000_cmp; for declared separator' _ '
 macro_name 'a' a> $ A000 cmp; for the default separator ''

It is possible to call macros from a macro and call recursive macros. In the latter case you should be careful because it can lead to stack overflow MADS-a. MADS is protected by recursion macros without end, and stops when the number of requests assembling the macro exceeds 4095 (Infinite recursion error).

An example of a macro that will cause a stack overflow MADS-a:

jump. macro

      jump

     . Endm

Example program that passes parameters to a pseudo procedures .. \ EXAMPLES \ MACRO.ASM:

 org $ 2000
 
 putchar percent, 'a'-64; PROC macro call, as a parameter
 putchar percent, 'a'-64; name of the procedure which will be called by the JSR
 putchar percent, 'R'-64, and an argument (character code INTERNAL)
 putchar percent, 'E'-64
 putchar percent, 'a'-64

 percent Color, $ 23; call another procedurki changing background color

; ---

jmp loop loop, loop endlessly to see the effect of

; ---

percent. macro, macros, PROC statement
 push = 1, 2, 3, 4, call the macro on the stack PUSH putting away the arguments
                        ; = 1 calculates the memory bank
 
 jsr: 1; jump to the procedure (procedure name in the first parameter)
 
 lmb # 0; Load Memory Bank, the bank sets the value of 0
 . Endm; end macro PROC

; ---

push. macro, the macro declaration PUSH

  lmb #: 1; sets up a virtual memory bank

 . F: 2 <= $ FFFF; if passed argument is less than equal to $ FFFF is
  lda <: 2; set it on the stack
  sta Stack
  lda>: 2
  a constant stack
 . Endif

 . F: 3 <= $ FFFF
  lda <3
  sta Stack 2
  lda>: 3
  sta Stack 3
 . Endif

 . F: 4 <= $ FFFF
  lda <: 4
  sta stack 4
  lda>: 4
  sta Stack 5
 . Endif
 
 . Endm
 

* ------------ *; Procedure COLOR
* PROC * Color
* ------------ *
 lmb # 1, setting the virtual bank number to 1
                            And all definitions of the labels will now belong to the bank
org * 256 stack, a stack for procedure COLOR
color stack equ

Color; procedure code COLOUR
 lda color
 sta 712
 rts

 
* -------------- *; Procedure putchar
* PROC putchar *
* -------------- *
 lmb # 2, set the virtual bank number to 2
                            And all definitions of the labels will now belong to the bank
org * 256 stack, a stack for procedure putchar
char stack equ

Putchar; procedure code putchar
 lda char
 sta $ bc40
scr equ *- 2

 scr inc
 rts

Of course, the stack in this example is a software program. In the case of 65816, you could use the hardware stack. Thanks to the defined variables are assigned to a specific number of the bank, you can create a structure or procedure call functions similar to those of higher-level languages.

However, more simply and more efficiently use the declaration procedure. PROC which allows MADS. More about the declaration of procedures and operations relating to him in Chapter Procedures.

PROCEDURES. PROC
MADS introduces new opportunities to use procedures with parameters. New capabilities that resemble those of known mechanism of high-level languages ??and are just as easy for the programmer.

Currently attached to the MADS-and macro declarations (@ CALL.MAC, @ PULL.MAC, @ EXIT.MAC) provide support for the program stack size of 256 bytes, which is the same size as a stack of hardware, provide a mechanism for removing the software stack and deposition on software stack parameters needed when calling procedures, and exit from such procedures. MADS includes the possibility of recursion such procedures.

The programmer is not involved in this mechanism, it can focus on your program. Only needs to remember the need to define the appropriate label and attaching the appropriate macros when assembling the program.
Additionally, there is the possibility to omit the "mechanism" software stack MADS-a and use the classical method of transmission, using the CPU registers (the Directive. REG) or variable (the Directive. VAR).

Another feature of the procedures. PROC is the ability to skip them when you assemble if there has been no appeal to them, that have been defined but not used. There will then prompt Unreferenced procedure ????. Omission of this procedure when it is possible to assemble by specifying a parameter to the MADS-a command line-x 'Exclude unreferenced Procedures. "

All labels defined in the procedure. PROC are local coverage, it can also be defined as global labels locally defined random access because you can refer to them what is not normal in other programming languages.

Under the procedure. PROC it is possible to define a global label (see Labels global).

If we want to get to the labels defined in the procedure from outside the procedure, then addressed with a dot '.', For example:

 lda test.pole

. Percent test

nop field

. Endp

If you are looking for assembler label did not occur in the procedure. PROC, MADS then it will look in the lower until it reaches the global area. To read immediately label value from the global procedure. PROC (or other local area) is preceded by the label name with a colon ':'.

MADS required for procedures using the software stack, the three global definition of labels with specific names (the address of the stack, the stack pointer, the address parameters in the procedure):

@ PROC_VARS_ADR
@ STACK_ADDRESS
@ STACK_POINTER

Lack of definition of / at the labels and try to use the block. PROC uses a software stack that MADS will adopt its default values ??of these labels: @ PROC_VARS_ADR = $ 0500, @ STACK_ADDRESS = $ 0600, @ STACK_POINTER = $ FE
MADS for procedures using software stack also requires a declaration macros for specific names. Attached to the MADS-and declarations of these macros are in the files:

@ CALL .. \ EXAMPLES \ MACROS \ @ CALL.MAC
@ PUSH .. \ EXAMPLES \ MACROS \ @ CALL.MAC
@ PULL .. \ EXAMPLES \ MACROS \ @ PULL.MAC
@ EXIT .. \ EXAMPLES \ MACROS \ @ EXIT.MAC

W / in macros implement the transfer and deposition parameters on the software stack, and the removal and deposition parameters for procedures using the software stack and triggered from other procedures using the software stack.

The declaration procedure. PROC

Procedures apply to the n / a directive:

 name. PROC [(. TYPE PAR1. ...)] PAR2 TYPE [. REG] [. VAR]
 . PROC name [, address] [(. TYPE PAR1. ...)] PAR2 TYPE [. REG] [. VAR]
 . ENDP [. PEND] [. END]

name. PROC [(. TYPE Par1, PAR2. Par3 ...)] TYPE [. REG] [. VAR]
The declaration procedure name with the Directive. PROC. Name of the procedure is required and necessary, its absence will generate an error. The names of procedures can not use the names of mnemonics and pseudo orders. If the name is reserved for an error with the message word Reserved.

If you want to use one of the mechanisms of MADS-and to pass parameters to procedures, we must declare them before. Declaration of parameters in the procedure is between parentheses (). There are four types of parameters:

. BYTE (8-bit) relokowalne
. WORD (16-bit) relokowalne
. LONG (24-bit) nierelokowalne
. DWORD (32-bit) nierelokowalne

In the current version of the MADS-and there is no possibility of passing parameters by means of structures. STRUCT.

Immediately after the declaration of the type, separated by a minimum of one space, followed by the name of the parameter. If you declare more parameters of the same type, we can separate the names by commas ','.

Example declarations of procedures using software stack:

name. PROC (. WORD PAR1. par2 BYTE)
name. PROC (. BYTE PAR1, par2. par3 LONG)
name. PROC (. DWORD p1, p2, p3, p4, p5, p6, p7, p8)

In addition, by using the directives. REG or. VAR, we can determine the manner and method of passing parameters to procedures MADS-a. By the CPU registers (. REG) or variable (. VAR). Directive providing for the transfer of the parameters inserted at the end of our declaration of the procedure. PROC
Example declarations of procedures using CPU registers:

name. PROC (. BYTE x, y, and. BYTE.) REG
name. PROC (. WORD xa. BYTE y). REG
name. PROC (. LONG axy). REG

Directive. REG requires that the parameter names consist of letters 'A', 'X', 'Y' or a combination thereof. These points correspond to the names of CPU registers and affect the order of the use of registers. A limitation in the number of parameters passed is the number of CPU registers, so we can pass to the procedure for a total maximum of 3 bytes. The advantage of this method while jes speed and low consumption of RAM.
Example declaration of procedure variables using:

name. PROC (. BYTE x1, x2, y1, y2). VAR
name. PROC (. WORD inputPointer, outputPointer). VAR
name. PROC (. WORD src +1, dst +1). VAR

For. VAR parameter names, variable names to indicate which parameters passed will be loaded. This method is slower than. REG but still faster than the method with a stack of software.

The procedure we leave in the usual way, ie using the RTS command. The addition of the RTS command in the body of the procedure at the exit of each track is the responsibility of programming, not the assembler.
As in the case of the block. LOCAL, we can determine the new address to assemble the block. PROC, for example:

. PROC label, $ 8000
. ENDP

. PROC Label2, $ A000 (. Word ax.) Reg
. ENDP

In procedures using software stack after the procedure. ENDP MADS invokes the macro @ EXIT, whose task is to modify the software stack pointer @ STACK_POINTER, it is necessary for the proper functioning of the software stack. The user can design their own macro @ EXIT, or use the attached to the MADS-a (file .. \ EXAMPLES \ MACROS \ @ EXIT.MAC), it is now as follows:

. Macro @ EXIT

 ift: 1 <> 0

  ift: 1 = 1
   dec @ stack_pointer

  where: 1 = 2
   dec @ stack_pointer
   dec @ stack_pointer

  els
   pha
   lda @ stack_pointer
   sub #: 1
   fixed @ stack_pointer
   pla

  e and f

 e and f

. Endm

@ EXIT macro should not alter the contents of CPU registers, if we want to preserve the possibility of returning a result of the procedure. PROC through CPU registers.

. ENDP
Directive. ENDP statement ends the block procedure.

Procedure call

The procedure call by its name (same as macro), followed by the parameters may occur, separated by a separator in the form of a comma ',' or spaces '' (it is not possible to declare other separators).
If the parameter type will not agree with the type declared in the declaration procedure, there is an error Incompatible types.

If you pass the number of parameters differs from the number of parameters declared in the declaration of a procedure error occurs Improper number of actual parameters. The exception is the procedure to which the parameters are transmitted by the CPU registers (. REG) or variable (. VAR), in such cases we omit the parameters, implicitly they are already loaded into the appropriate registers and variables.

There are three ways to transfer the parameter:
'#' By the value
'' By the value from the address (without the preceding character)
'@' By the battery (type parameters. BYTE)
"String" of string, eg "label, x"

An example of the procedure call:

 name @ # $ 166, $ A400; for the software stack
 name, @, # $ 3f; for. REG or. VAR
 name "(hlp), y" "tab, y 'for. VAR or software stack (stack software uses regX)

MADS after encountering the procedure call that uses the software stack forces the execution of the macro @ CALL. However, if the procedure does not use the software stack, instead of the macro @ CALL will wynegerowany plain JSR PROCEDURE command.
To the macro @ CALL MADS passes parameters calculated on the basis of the declaration procedure (crashes each parameter into three components: addressing mode, parameter type, parameter value).

@ CALL_INIT 3 \ @ PUSH_INIT 3 \ @ CALL'@',' B ', 0 \ @ CALL'#',' W', 358 \ @ CALL '' W, '$ A400 "\ @ CALL_END PROC_NAME

Macro @ CALL hangs on the contents of the battery stack, then the value of $ 166 (358 dec), then the value from the address $ A400. For more information on how to pass parameters to macro (meaning single quotes''and "") in Chapter Calling macro.

The parameter passed by the battery '@' should always be the first parameter passed to the procedure, if it does occur elsewhere in the accumulator content is modified (default macro @ CALL impose such a restriction.) Of course you can change this by writing his version of the macro @ CALL. In the case of the procedures. REG or. VAR of order parameter '@' does not matter.
Output from the procedure. PROC followed by the RTS command. After returning from the procedure invokes the macro MADS @ EXIT that contains the program modifies the value of stack pointer @ STACK_POINTER, it is necessary for the proper operation of the software stack. Since the stack pointer is subtracted from the number of bytes that were transferred for the procedure, the number of bytes is passed to the macro as a parameter.

The addition of the RTS command in the body of the procedure at the exit of each track is the responsibility of programming, not the assembler.

Parameters of the procedure, the appeal
References to the parameters of the procedure from the procedure does not require additional operations from the programmer, for example:

@ Stack_address equ $ 400
@ Stack_pointer equ $ ff
@ Proc_vars_adr equ $ 80

name. PROC (. WORD PAR1, par2)

 lda PAR1
 clc
 adc par2
 sta PAR1
 
 lda PAR1 a
 1 par2 adc
 a constant PAR1

. Endp

 icl '@ call.mac'
 icl '@ pull.mac'
 icl '@ exit.mac'

MADS at the time the declaration. PROC with parameters, automatically makes the definition of these parameters by assigning values ??based on @ PROC_VARS_ADR. In w / in Example MADS will automatically define parameters = @ PROC_VARS_ADR PAR1, PAR2 = @ PROC_VARS_ADR + 2

The programmer refers to these parameters after the name that has been attributed to them in the declaration process, which is similar to that in higher-level languages. The MADS is possible to access parameters in the procedure from outside the procedure, which is no longer normal in higher-level languages. We can read the a / example PAR1 content, such as:

 lda name.par1
 sta $ A000
 lda name.par1 1
 sta $ A000 a

The value of PAR1 has been rewritten to the address $ A000, a PAR1 value to the address $ A000 1. Of course, we can only do this immediately after the end of this particular procedure. It must be remembered that the parameters of such procedures will be placed under a common address @ PROC_VARS_ADR, so with each new procedure call stack using programowowy content area <@ PROC_VARS_ADR .. @ PROC_VARS_ADR + $ FF> changing.

If the procedure is no declared type parameters. REG programmer should take care of it to remember them, or actually use before they are modified by procedure code. In the case of type parameters. VARs do not have to worry about anything because the parameters are saved to a specific memory cells from which we can always read them.


LOCAL AREA
The main task of the local area in MADS is to create a new namespace for labels.

All labels defined in the local area. LOCAL is the local coverage, it can also be defined as global labels locally defined random access because you can refer to them what is not normal in other programming languages.

In the local area. LOCAL is possible to define a global label (see Labels global).

If you are looking for assembler label did not occur in the local area. LOCAL, then it will look MADS in the lower until it reaches the global area. To read immediately label value from the global local area. LOCAL (or other local area) is preceded by the label name with a colon ':'.

Declaration of the local area. LOCAL

Local areas to the n / a directive:

 [Name]. LOCAL [, address]
 . LOCAL [name] [, address]
 . Endl [. LEND] [. END]

[Name]. LOCAL [, address]

Declaration of a local area called name with the Directive. LOCAL. Name of the area is not required and is not necessary. For names of local areas can not use the names of mnemonics and pseudo orders. If the name is reserved for an error with the message word Reserved.

After the name of the local area (or the Directive. LOCAL), we can give a new address block assemble locally. Upon completion of this block (. Endl) is restored assemble previous address incremented by the length of local block.

label. local, $ 4000
. Endl

. Local Label2, $ 8000
. Endl

. Local
. Endl

. Local label3
. Endl

All definitions of the labels in the area. LOCAL is the local type. To refer to the global label of the same name as the label it must be preceded by local colon ':', eg:

lab equ 1

. Local

lab equ 2

 lda # lab
 ldx #: lab

. Endl

W / in the example in the register A is loaded with a value of 2, while the register X value to 1

If you are looking for assembler label has not occurred in the area. LOCAL, then the search will take place in the macro (if it is currently being processed), then the procedure (if the procedure is currently being processed), at the end of the main program.
In the area declared a local all definitions of labels are distinguished by the name of the local area. To reach the defined labels in the local area outside the local area we need to know the name and label it occurring, eg:

 lda # name.lab1
 ldx # name.lab2

. Local name

LAB1 = 1
lab2 = 2

. Endl

So we use a dot "." in addressing such a structure. LOCAL.

Local areas can be nested, they can be placed in the body of the procedures declared by the Directive. PROC. Local areas are additive, ie, there may be many local areas of the same name, all the symbols occurring in these areas will belong to a common namespace.
. Endl

Directive. Endl declaration ends with the local area.
Example declaration of a local area:

 org $ 2000
 
tmp ldx # 0 <------------- label in the global
                          |
 lda obszar.pole <--- | reference to the local area
                     | |
. Local area | | Declaration of local area
                     | |
 lda tmp <--- | |
              | | |
 lda: tmp | | <--- reference to the area of ??global
              | |
tmp nop <--- | definition in the local area
                     |
Golf lda # 0 <--- <--- definition of the local area
                            |
 lda <----------------- reference field in the local area

. Endl end of the declaration of the local area


SYNOPSIS
MADS accept a similar syntax as QA, XASM. However, it is less tolerant of the comments appearing at the end of the line (comments should be preceded by the appropriate sign) or a more tolerant in the case of white space and in cases of non-argument for CPU command mnemonics, such as:

   asl -> asl @
   lda # -> lda # 0

MADS accepts no white space separating the mnemonic and argument, provided that the character argument can not begin with '@' used in the names of labels or signs '%', ':' used to determine the parameter number in macros (%% number: number) example:

   lda $ 44
   lda #
   lda (80), y

Comments
Signs of single-line comment should be preceded by a ';' or '*'. To determine the safest single-line comment is, however, use a semicolon ';' because the character '*' has another meaning, may mean a multiplication operation, or the current address during assemble. The semicolon and is dedicated exclusively for comments.

To mark a single-line comment is also possible to use characters for multiline'//', and characters '/ * * /'.

 * This is a comment
                 , This is a comment
 lda # 0; this is a comment
 dta 1, 3 * Invalid COMMENT, WILL misinterpreted

 org $ 2000 + 1 Wrong COMMENT, WILL misinterpreted

 nop / / this is a comment

 / / This is a comment

 dta 1.2, / * comment * / 3.4

 lda / * comment * / # 0

/ *
  ...
  This is a multiline comment
  ...
* /

/*************************************
  This comment is also a multi
**************************************/

Signs denoting multiline comment "/ * * / 'and the signs indicating a one-line comment' / / 'can be used without restrictions.

Combining / Splitting multiple rows in one line listing

Any number of lines of code listing, we can combine (split) in one row with the character '\', eg:

 lda 20 \ cmp 20 \ BEQ *- 2
 
    lda 20 \ cmp 20 \ BEQ *- 2
 
  lda # 0 \ lop sta $ A000, y \ ins \ bne lop; comment only at the end of this line

If the character '\' do not put a space, then the mnemonic or another string may be interpreted as a label, remember that the character '\' means the beginning of a new line.

MADS process ends with the line, until it encounters the end of the comment or string, so comments can be placed only at the end of such a multi-line.
WARNING! Placing the character '\' at the end of the line means for MADS-a willingness to continue the current line from the next line, eg:

 lda \
 # \
 12

For w / in the example we get an order 'LDA # 12'.


Combine multiple mnemonics

The possibility of combining two mnemonics using the colon character ':' is known already XASM-a. The MADS this opportunity was extended to linking any number of known MADS-these mnemonics, such as:

 lda: cmp: req 20

 lda: ins: sta: ins $ 600, y

EXPRESSIONS
The term expression is the sequence of operators and operands (arguments), which specifies the operations, ie the nature and sequence of calculations. Compound expression is called an expression in which there is two or more operators. Operators that affect only one operand, called jednoargumentowymi (unarnymi). Binary operators are called binary.

Evaluating the expression goes in the order set out the priority of operators in the direction specified by direction of the bond operators.

Numbers

MADS accept record numbers in decimal format, hexadecimal, binary codes and ATASCII and INTERNAL.
write decimal:

 -100
 -2437325
 1743

write hexadecimal:

 $ 100
 $ E430
 $ 000,001
 
 0x12
 0xa000
 0xaabbccdd

write binary:

 % 0001001010
 $ 000000001
 $ 001,000

ATASCII write codes:

 'A'
 'Fds'
 'W' *

INTERNAL entry codes:

 "B"
 "FDSFSD"
 "." *

Only the first character ATASCII, INTERNAL is significant. The '*' for the closing apostrophe causes inverse sign.

In addition, there are still two operations '+' and '-' for strings, which increase / decrease in restricted character codes quotes.

 "FDttrteSFSD" -12
 'FDSFdsldksla' 2


Operators

Binary operators:

+ Addition
- Subtraction
* Multiplication
/ Division
% Remainder
& Bitwise and
| Bitwise or
^ Bitwise xor
<<Arithmetic shift left
>> Arithmetic shift right
= Equal
== Equal (same as =)
<> Not equal
! = Not equal (same as <>)
<Less than
> Greater Than
<= Less or equal
> = Greater or equal
& & Logical and
| | Logical or


Unary operators:

+ Plus (does nothing)
- Minus (changes sign)
~ Bitwise not (complements all bits)
! Logical not (changes to true is false and vice versa)
<Low (extracts the low byte)
> High (extracts high byte)
^ High 24bit (extracts high byte)
= Extracts memory bank
: Extracts global variable value


Operator precedence:

first [] (brackets)
 + - ~ <> (Unary)
 * /% & <<>> (Binary)
 + - | ^ (Binary)
 = == <>! = <> <=> = (Binary)
 ! (Unary)
 & & (Binary)
last | | (binary)


LABELS

The labels defined in the program may have a range of local or global, depending on the place in which they were defined. In addition, you can define a temporary label, which may also have local or global scope.

Global label means that it is visible from anywhere in the program, whether it is macro. MACRO, the procedure. PROC or local area. LOCAL.

Reach local labels means that it is visible only in specifically defined area, such as the directive:. MACRO. PROC. LOCAL.

labels must begin with ['A' .. 'Z', 'a' .. 'z','_','?','@']
Other acceptable characters are labels ['A' .. 'Z', 'a' .. 'z', '0 '.. '9','_','?','@']
Labels are always at the beginning of the line
preceded by the label "white space" should end with a ':' in order to avoid misinterpretation of such a label as a macro
in addressing the label may be preceded by a ':' This tells the assembler that we refer to the label in the main block of the program (refer to the global label)

Example definitions of the labels:

? Name EQU $ A000; definition of a global temporary labels
name = *, the definition of a global label
name2 = 12; the definition of a global label
@? Name EQU 'a' 32, the definition of a global label
  name: equ 12; no global definition of the label that starts with the first character of line
         name: = 'v', the definition of global labels are not starting with the first character of line

Compared to the QA / XASM came the ability to use a question mark "?" and "monkeys" '@' in the names of the labels.
Use a dot "." in the name of the label is acceptable, but not recommended. The dot is reserved for the determination of the extension mnemonics, assembler directives to indicate the addressing of new structures of the MADS-a.

The dot "." at the beginning of the name of the label suggests that this is the assembler directive, while the question mark "?" at the beginning of the temporary label means a label, so the value of which may change several times during assemble.

Local Labels

Any definition of the labels within a macro. MACRO, procedures. PROC or local area. LOCAL default is the local coverage, in other words, it is local. Such labels you do not need extra mean.
Local labels are defined using the n / a pseudo-equivalent commands:

 EQU
  =

To have access to a global label (that is defined outside a macro. MACRO, procedure. PROC, the local area. LOCAL) and the same names as local, use the operator ':', eg:

lp ldx # 0; definition of a global label LP

     test
     test
 
test. macro

      lda: lp; character ':' before the label will read the label value of global LP

      constant lp +1; appeal to the local label LP in the macro
lp lda # 0; definition of local label LP in the macro

     . Endm

W / in the example are definitions of the labels of the same name (LP), but each has a different value and other coverage.


Global Labels

Any definition of the labels carried in the main block of the program outside the macro. MACRO, procedures. PROC or local area. LOCAL coverage is global, in other words, is global.
Labels are defined using the global n / a pseudo-equivalent commands:

 EQU
  =

or directive. DEF syntax:

 . DEF: label [= expression]

Directive. DEF to define labels in the current local area, the character ':' at the beginning of the label indicates the label global. Using the directive syntax. DEF: label allows you to define global labels without the current level of localness.
The colon ':' at the beginning of the label has a special meaning, indicates that we refer to the global labels, ie labels of the main block of the program without all the levels of locality.

For more information on using the directive. DEF section directive. DEF

An example of the definition of global labels:

lab equ *
   lab2 equ $ 4000

? Tmp = 0
? Tmp + = 40
 
. Proc name

      . Def:? Name = $ A000
           . Def name = 20

      . Local lok1
        . Def: @? Name = 'a' 32
      . Endl

. Endp

An example application of the definition of a global temporary labels include macro @ CALL (file .. \ EXAMPLES \ MACROS \ @ CALL.MAC), which is the definition of temporary labels? @ STACK_OFFSET. It is later used by other macros from a macro called @ CALL, and to optimize the parameters for putting away the software stack.

@ CALL. Macro

  . Def? @ Stack_offset = 0; definition of a global temporary labels? @ Stack_offset
 
  ...
  ...
 
 
@ CALL_ @. Macro

  fixed @ stack_address &? @ stack_offset, x
  . Def? @ Stack_offset =? @ Stack_offset + 1; modified labels? @ Stack_offset

 . Endm


Labels temporary

The definition of temporary labels have the property that its value may change frequently, even during the course of assembling one. Normally, an attempt to re-definition of the label ends with the message Label Declared twice. It will not be the message if it is a temporary label.

The range of temporary labels is dependent on the area in which the label is defined. Temporary labels can have local scope (local label) or global (global labels.)
Temporary label defines the user by placing the label name at the beginning of a question mark '?', Eg:

 ? Label

Temporary labels should not use the names of procedures. PROC, macro. MACRO, the local area. LOCAL structures. STRUCT, tables. ARRAY.

Define a temporary label with n / a pseudo-equivalent commands:

 EQU
  =

Additionally, you can modify them using familiar with C operators:

 -= Expression
 + = Expression
 -
 + +

W / in modifying operators apply only temporary labels, try to use them for other types of labels runs Improper syntax error message.

Example of use of temporary tags:

? Loc = $ 567
? Loc2 =? Loc + $ 2000

lda? loc
sta? loc2

? Loc = $ 123

lda? loc


Local labels in the style of the IEA

Option OPT? + Labels to inform the MADS starting with '? " interpreted as a local label, as does the IEA. By default, the labels that begin with '? " are treated by MADS as a temporary label Labels temporary.
Example of use of local labels in the style of the IEA:

       opt? +
       org $ 2000

local1 ldx # 7
? Lop sta $ A000, x
       dex
       bpl? lop

local2 ldx # 7
? Lop $ B000 constant, x
       dex
       bpl? lop


Sparta DOS X
Construction of Sparta DOS X-Files, Atari DOS

Reprinted with Serious Magazine, author Qcyk / Dial.

The file itself is only worth a little collection of bytes. Lots of numbers that can mean everything and nothing at the same time, if you do not know how to interpret them. Most of the files fitted for this reason, in a variety of headings, which are stored information about what the file contains, possibly as he was then treated for the reading. These also include executables, binary, or simply intended to be loaded from the DOS'u. Indeed, the DOS is a program and how everyone else is entitled to expect the data to a specific known him structure.

Traditional binary files, recognized by all DOS'y for Atari XL / XE, have block structure, where each block has its own header. There are two types of headers:

 1st dta a ($ ffff), and (str_adr) and (end_adr)

 2nd dta a (str_adr) and (end_adr)

str_adr - the address that will load the first byte of data

end_adr - the address from which you loaded the last byte

The first block in the header file must have a $ ffff, the remaining blocks arbitrarily. The headline, of course, should be included in the amount of data:

   (End_adr-str_adr) +1

So much by way of reminder. The creators of the system Sparta DOS X retained the above standard, while adding several new types of headers. So I still have to deal with a file divided into blocks, except that the types of blocks is now a lot more. Here they are:

1st Block nierelokowalny (loaded into permanent address in memory):

    dta a ($ fffa) and (str_adr) and (end_adr)

This is the same as block $ ffff - no matter that will be used. $ Fffa will, however, clearly indicate that the program is designed for SDX - another DOS can not read the file.

2nd Block relokowalny (MEMLO loaded into the indicated memory type):

    dta a ($ fffe), b (blk_num), b (blk_id)
    dta a (blk_off) and (blk_len)

blk_num - block number in the file. Each block relokowalny should have its own number. Because the loading address blocks are not known, the blocks are identified just by their numbers. They may be in the range 0-7, except that in practice it is usual numbers from 1 upwards.

blk_id - bits 1-5 are the index of memory to which the block is to be loaded. I met with two values:

 $ 00 - the basic memory
 $ 02 - Extended memory

Additionally setting bit 7 indicates no data block. SDX does not charge anything then, but reserves the memory.

blk_off - so called. offset addresses in the block, which is simply the address that was the assembly code. This is needed for updating addresses, referring to the contents of the block.

blk_len - the length of the block. So much data should be a header, unless it is reserving a block of memory if the data does not exist.
Writing code relokowalny keep in mind several limitations imposed by the idea of ??"przemieszczalnego" code. All addresses that refer to an area of ??such a program must be updated during charging, therefore, can not use a sequence like:

       lda something
       ...
      something equ *
       ...
    Instead, the remains such as:
       lda _cos
       ldx _cos 1
       ...
      _cos dta a (something)
       ...
      something equ *


3rd Block updating of addresses relating to the block relokowalnego:

    dta a ($ fffd), b (blk_num) and (blk_len)

blk_num - block number, to which the updated addresses.

blk_len - update block length (without header). It is ignored.

Addresses are updated by adding to an existing difference between the address at which the block was loaded relokowalny indicated, and the value blk_off (assemble at) this block. This can be represented by the formula:

       ADR = ADR + (blk_adr-blk_off)

"Body" are indicators of a block upgrade to poprawianych addresses and special orders. The index is a number between $ 00 - $ fb and is offset from the place of the previous update. This place is remembered by the loader as a direct address, call it counter update. This counter can be initiated by means of special functions, which are numbers greater than $ fb:

$ Fc marks the end of the block update

$ Fd, a (ADDR) is updated directly by the designated address ADDR. Thus, the value of ADDR is written to the counter update and it will be counted from the next shift,

$ Fe, b (blk_num) to update the meter is inserted in the block address designated by blk_num, or subsequent updates will apply to the code in this block,

$ Ff update counter is increased by $ fa (without updating the address).

4th Block update addresses the procedures defined symbols:

    dta a ($ fffb) c'SMB_NAME ', and (blk_len)

SMB_NAME - symbolic name of the procedure (or an array, the system registry, etc.) The eight characters in the code ATASCII,

blk_len - as in a block of $ fffd.

After the header is a string of indicators for the position to update the address - the same as in the block $ fffd. Addresses are changed by adding to an existing address, the procedure specified symbol. This allows for use in programs of the procedures that do not know the address, such procedures are added by other programs in an SDX. Also, system procedures should be used in this way, yet they may have different addresses in different versions of Sparta.

5th The block definition of new symbols:

    dta a ($ fffc), b (blk_num) and (smb_off)
    dta c'SMB_NAME '

blk_num - block number, which is a defined procedure. It follows that the procedure must be loaded as a block relokowalny.

smb_off - offset address in the block procedure, which is offset from the start of the procedure block (first byte is 0) plus the value of blk_off this block. Otherwise, this is the address at which the procedure was zassemblowana, SMB_NAME - a symbolic name defined procedure.

Blocks of type $ fffb, $ fffc, $ fffd are not permanently retained in memory. The system uses them only when the program loads.

Programming Sparta DOS X (SDX)

Syntax for handling Sparta DOS X, is taken from FastAssemblera by Mark Goderskiego below quote from the instructions supplied with the FA. FAS *. source files can now be no problems asemblowac MADS-em. Relokowalne orders are always two byte argument, you can not relocate three byte arguments (65,816).

The most important novelty in the SDX for the programmer is the ability to write simple programs relocatable. Since the MOS 6502 processor does not have a relative addressing, (except short conditional branches), the developers of ICD used a special program blocks charging mechanisms. The entire process consists of loading the block, and then special block of addresses updated. All addresses in the block of the program are counted from zero. Just so add to them the value of memlo to get the address right. Which addresses increase, and which to leave? It was after this update is a special block that contains pointers (specially coded) to those addresses. So after a block or blocks is compulsory execution reloc UPDATE ADDRESS for proper operation of the program. Also, the blocks in which orders SPARTA (or vectors) refer to the blocks or EMPTY reloc mandatory to perform an UPDATE ADDRESS.

Another innovation is the introduction of symbols. Well, some procedures have been defined SDX service by name! These names are always 8 letters (like file names). Instead of using arrays of vectors or strokes (as in the OS), we use the symbols defined SMB. After loading the block or blocks SDX program loads the updated block of symbols and in a similar manner as in relocatable blocks of addresses in the turns. Symbols can be used for blocks reloc and SPARTA.

The programmer can define your own symbols replacing SDX or completely new for use by other programs. This is done through the block NEW UPDATE. However know that a new symbol must be contained in the block reloc.

Number of blocks reloc and EMPTY is limited to 7 by the SDX.

Such blocks can be combined in chains for example:

       sparta blk $ 600
       ...

       blk main reloc
       ...

       blk empty $ 100 main
       ...

       blk reloc extended
       ...

       blk empty $ 200 extended

This means that orders in these blocks can refer to all blocks in the chain.

The chain is not interrupted by updating addresses, or symbols, but is destroyed by the definition of a new symbol, and the other blocks (ie: dos).

Note: A string is meaningful only when all its blocks are loaded into the same memory, or when the program switches to the appropriate memory references.

Note: Commands and vectors in blocks EMPTY reloc and should not refer to the blocks SPARTA! This can cause confusion when the user loads the program LOAD command, and use it after a long time. While the blocks reloc and EMPTY are safe is you never know what is in memory where the last was a block SPARTA!

Equally dangerous is the use of appeals to block the reloc and EMPTY blocks SPARTA (reason as above), but when you install the overlays (*. sys) using the INSTALL it is sometimes necessary, hence is acceptable. You can also initiate a block SPARTA (porzez $ 2E2), then it will always be running, and then becomes redundant.

Note: Between the blocks of SPARTA, and reloc and EMPTY occur between addresses! FA recognize references to other blocks through the addresses, assuming the PC for the reloc and EMPTY from $ 1000, so that when we mix these blocks must be assured of SPARTA is below $ 1000 (eg $ 600) or above the last block relokowalnego, $ 4,000 is usually sufficient This error is not detected by the compiler!


CODE RELOKOWALNY
Relokowalny code is one code that does not have a predetermined address to the computer's memory load, the code has to work regardless of the load address. The Atari XE / XL code provides the system relokowalny Sparta DOS X (SDX), more on this subject can be read in the chapter Programming Sparta DOS X

Relokowalny code for the SDX has a fundamental limitation which is relocated WORD addresses only, not the CPU instruction manual 65816th MADS provides the ability to generate code relokowalnego SDX format and its own incompatible with the SDX, which abolishes the previously mentioned limitations.

Recording Format code file relokowalnym MADS-a is similar to that known from the SDX, as there is here the main block and blocks of additional information on the addresses to be subjected to relocation. MADS uses the simpler a block update, without "compression" which applies SDX.

Advantages of code relokowalnego MADS-a:
take into account the size of the arguments for the CPU 6502, 65816
You can use all the commands the CPU, without restrictions
allows the relocation of young and old address bytes

Restrictions relokowalnego code MADS-a:
label declarations by EQU make before the block. reloc
if we define a new label in the block. reloc must precede its name with a space or a tab (global label)
You can not use pseudo orders ORG, RMB, LMB, NMB, and the Directive. DS
You can not relocate the oldest byte of 24bit words, eg lda ^ $ 121,416

An example of how easy it is to create a code file relokowalny .. \ EXAMPLES \ TETRIS_RELOC.ASM, who has used the CPU and the list of commands that define the pseudo-command is no different from the version nierelokowalnej .. \ EXAMPLES \ TETRIS.ASM


Block relokowalny. Reloc

Block relokowalny MADS-a is generated by using the directive:

 . Reloc [. BYTE |. WORD]

Block for block updates relokowalnego MADS-a call using a pseudo-command BLK:

 BLK ADDRESS UPDATE

After the directive. Reloc is possible to provide a block relokowalnego (. BYTE. WORD), the default is type. WORD. Type. BYTE block applies only intended to be placed at zero (the orders will include the zero), MADS will asemblowal a block from address $ 0000th Type. WORD means that the MADS will asemblowal relokowalny block from address $ 0100 and will be designed to be placed in any area of ??memory (no orders will include the zero).

Header block. Reloc resembles that known from DOS, it was further extended to 10 new bytes for a total occupies 16 bytes, for example:

HEADER. WORD = $ FFFF
START_ADDRESS. WORD = $ 0000
END_ADDRESS. WORD = FILE_LENGTH-1
MADS_RELOC_HEADER. WORD = $ 524D
UNUSED. BYTE = $ 00
CONFIG. BYTE (bit0)
@ STACK_POINTER. WORD
@ STACK_ADDRESS. WORD
@ PROC_VARS_ADR. WORD

MADS_RELOC_HEADER always worth $ 524D corresponding characters 'MR' (M-ADS R-ELOC)
FILE_LENGTH relokowalnego block length is not 16 byte header
CONFIG is currently used only bit0 of a byte, bit0 = 0 means relokowalny assemble the block from address $ 0000, bit0 = 1 block relokowalny assemble from address $ 0100

The last 6 bytes contain information about the values ??of labels needed to operate the software stack @ STACK_POINTER, @ STACK_ADDRESS, @ PROC_VARS_ADR if used during the assembling of relocatable blocks. If the individual blocks. Reloc were zasemblowane with different values ??of these labels and they are linked-then there is a warning message stack Incompatible parameters. If the software stack has not been used the values ??of these labels are zero.

Pseudo order. Reloc MADS-switches and code generation in the mode of taking into account the size relokowalnego command arguments CPU 6502, 65816th Under this code, it is impossible to use the ORG pseudo-instruction, LMB, NMB, RMB, and the Directive. DS. It is not possible to return to the MADS-and code generation mode relokowalnego not, it is possible to generate more than one block. Reloc.

Use of the Directive. Reloc will additionally increase the counter of virtual banks MADS-a, by which the area is local and not visible to other blocks. For more information on virtual banks in section Virtual memory banks (B-OPT).

At the end of the block. Reloc is required to generate a block update command performs a pseudo-BLK with identical syntax as for the block relokowalnego SDX ("BLK UPDATE ADDRESS"). Recording Format update this block is not identical with the SDX, is as follows:

HEADER WORD ($ FFEF)
TYPE CHAR (B-USED, W-ORD, L-ONG, D-WORD, <,>)
DATA_LENGTH WORD
DATA WORD [BYTE]

HEADER always worth $ FFEF
TYPE data type is stored in the 0th bits of this byte .6 and specifies the type of modified addresses, sign "<" means the lower byte of address, the character ">" means a byte address.
DATA_LENGTH is the number of 2-byte data (addresses) to modify
DATE is the correct sequence of data for modification of the main block relokowalnego. At the address indicated here should read the value of TYPE and then modify it under the new loading address.

The exception is the block update for the older byte address ">" for that block is saved in DATA are extra byte BYTE (modified byte address). To upgrade legacy of bytes we read from the address byte WORD in DATA, add it to your current address relocation and add lower byte of the DATA BYTE. So the newly calculated high byte is placed at the DATA WORD.

External Symbols

External Symbols indicate that the variables and procedures that represent will be located somewhere on the outside, beyond the current program. We need not specify where. We just need to give their names and types. Depending on the type of data that represents a symbol of assembler instructions are translated into the appropriate machine code, assembler must know the size of used data.
Currently there is no option to manipulate the external symbols of type '^' (the oldest byte).

External Symbols can be used in relocatable blocks. Reloc as in ordinary blocks of DOS.
External Symbols (external) declare the EXT command using a pseudo or directive. EXTRN:

EXT label type
Label. EXTRN type
. EXTRN label1, Label2, label3 ... type

Block updates for the symbols we call external command using a pseudo-BLK:

 BLK EXTERNAL UPDATE

NOTE: You will be saved symbols that were used in the program.

External symbols are not only defined value type (. BYTE. WORD. LONG. DWORD) eg:

EXT name. BYTE

LABEL_NAME EXT. WORD

 . EXTRN LABEL_NAME. WORD

wait EXT. PROC (. BYTE delay)

External symbol of the declaration procedure. PROC adopt the default type. WORD, an attempt to appeal to the name of this label will be interpreted as an attempt by the MADS procedure call, more on procedure calls. PROC Procedures section.

In the process of assembling after encountering references to external symbols are always substituted zero.

External symbols can be useful to us when we want zasemblowac the program separately from the rest of the actual program. In this program, then there are often references to the procedures, variables that are defined elsewhere, outside, and we not only know their value type. At this point, with the help of external symbols come, which allow assembling of such a program despite the lack of proper procedures or variables.

Another use of external symbols can be called. "Plugins" external programs combined with the main program and performing additional tasks. These are specific types of libraries that use the procedure of the main program, extending its functionality. To create such a plugin would be to determine which procedure provides the main program (their name + parameters and type) and create a procedure to read a file from the external symbols, the procedure for attaching pursue plug-ins to the main program.

Below the header format in a file with external symbols of a B-USED, W-ORD, L-ONG, and D-WORD after the call by BLK EXTERNAL UPDATE:

HEADER WORD ($ FFEE)
TYPE CHAR (B-USED, W-ORD, L-ONG, D-WORD, <,>)
DATA_LENGTH WORD
LABEL_LENGTH WORD
LABEL_NAME ATASCII
DATA WORD .. .. ..

HEADER always worth $ FFEE
TYPE data type is stored in the 0th bits of this byte .6 and specifies the type of modified addresses
DATA_LENGTH is the number of 2-byte data (addresses) to modify
LABEL_LENGTH a symbol name length in bytes
LABEL_NAME is the name of the symbol in the code ATASCII
DATE proper sequence data for modification of the main block relokowalnego. At the address indicated here should read the value of TYPE and then modify it under the new symbol value.

An example application of external symbols and structures. STRUCT is a sample collection of graphic primitives (PLOT, LINE, CIRCLE) from the directory .. \ EXAMPLES \ LIBRARIES \ GRAPHICS \ LIB. Individual modules here use quite a large number of variables at zero, if we want to address these variables were relokowalne each individual would have to declare a variable as an external symbol by EXT (or. EXTRN). We can simplify by using only one external symbol and data structure. STRUCT. Using the structures we define "map" variables, ZP, then an external symbol ZPAGE type. BYTE variables because we want to be at zero. Now referring to the variable we need to write it in such a way that forces relokowalnosc ZPAGE + ZP.DX and so was completely relokowalny module with address changes in the space of the variables of zero.

Public Symbols

Public Symbols and procedures provide a variable occurring in the rest of the block relokowalnym asemblowanego program. With public symbols can refer to variables and procedures, "sewn" such as libraries.

Public symbols can be used in relocatable blocks. Reloc as in ordinary blocks of DOS.

MADS automatically detects whether the publicity given to the label is a variable, constant, or procedure by zadeklarowna. PROC does not require any additional information as in the case of external symbols.
Declare public symbols by using n / w directives:

 . PUBLIC label [, ,...] Label2
 . GLOBAL label [, ,...] Label2
 . GLOBL label [, ,...] Label2

Directive. GLOBAL and. GLOBL have been added in view of compatibility with other assemblers, the meaning is identical with the Directive. PUBLIC.

Block renovation of public call for symbols using the pseudo-BLK order:

 BLK PUBLIC UPDATE

Below the header format in the file with public symbols after the call by BLK UPDATE PUBLIC:

HEADER WORD ($ FFED)
WORD LENGTH
BYTE TYPE (B-USED, W-ORD, L-ONG, D-WORD)
LABEL_TYPE CHAR (C-ONSTANT, V-ARIABLE, P ROCEDURE A-RRAY, S-TRUCT)
LABEL_LENGTH WORD
LABEL_NAME ATASCII
WORD ADDRESS

MADS automatically selects the appropriate type for upublicznianej labels:

C-ONSTANT
  label uncontrolled relocation
V-ARIABLE
  label uncontrolled relocation
P ROCEDURE
 declared by the procedure. PROC, subject to relocation
A-RRAY
     declared by the board. ARRAY, subject to relocation
S-TRUCT
    declared by the structure. STRUCT, is not subject to relocation

If the symbol relates to the structure. STRUCT be saved for additional information (field type structure, the name of the field structure, the number of repetitions of the structure):

STRUCT_LABEL_TYPE CHAR (B-USED, W-ORD, L-ONG, D-WORD)
STRUCT_LABEL_LENGTH WORD
STRUCT_LABEL_NAME ATASCII
STRUCT_LABEL_REPEAT WORD

If the symbol relates to the array. ARRAY if additional information is saved (the maximum declared array index, an array of fields declared type):

ARRAY_MAX_INDEX WORD
ARRAY_TYPE CHAR (B-USED, W-ORD, L-ONG, D-WORD)

If the symbol refers to the procedure. PROC if additional information is recorded, regardless of whether the procedure was or was not declared parameters:

PROC_CPU_REG byte (bits 00 - Rega, 01 - regX, 10 - Regy)
PROC_TYPE BYTE (D-EFAULT, R-EGISTRY, V-ARIABLE)
PARAM_COUNT WORD

For the symbols on the procedures. REG are saved now only types of these parameters in the amount of PARAM_COUNT:

PARAM_TYPE CHAR (B-USED, W-ORD, L-ONG, D-WORD)
...
...

For the symbols on the procedures. VAR parameter types are saved and their names. PARAM_COUNT specifies the total length of the data:

PARAM_TYPE CHAR (B-USED, W-ORD, L-ONG, D-WORD)
PARAM_LENGTH WORD
PARAM_NAME ATASCII
...
...

HEADER always worth $ FFED
LENGTH is the number of symbols stored in the block update
TYPE symbolized the type of B-USED, W-ORD, L-ONG, D-WORD
LABEL_TYPE symbol type: V-ARIABLE, C-ONSTANT, P ROCEDURE A-RRAY, S-TRUCT
For P-type saves additional information: PROC_CPU_REG, PROC_TYPE, PARAM_COUNT, PARAM_TYPE
For type A are stored additional information: ARRAY_MAX_INDEX, ARRAY_TYPE
For S-type saves additional information: STRUCT_LABEL_TYPE, STRUCT_LABEL_LENGTH, STRUCT_LABEL_NAME, STRUCT_LABEL_REPEAT
LABEL_LENGTH public symbol label length in bytes
Label LABEL_NAME public symbol codes stored in ATASCII
ADDRESS address assigned to the symbol in the block relokowalnym. Reloc. This value is subject to relocation by adding to its current address assemble.
PROC_CPU_REG information about the order of use of CPU registers for procedure type. REG
PROC_TYPE type of procedure:
D-EFAULT default type to pass parameters using a software stack and the MADS-
R-EGISTRY parameters for the procedure are reported by the CPU registers (. REG)
V-ARIABLE parameters for the procedure are reported by the variables (. VAR)
PARAM_COUNT information on the number of parameters in the procedure (. REG) or total length of data containing information about the type of parameters and their names (. VAR)
PARAM_TYPE type parameters stored with the characters 'B', 'W', 'L', 'D'
PARAM_LENGTH name length parameter (. VAR)
PARAM_NAME parameter name in the code ATASCII (. VAR)


Linking. LINK

 . LINK 'filename'

Directive. LINK requires a filename as a parameter to the relocation. Accepted files are only DOS Atari, SDX files are not accepted.

If the load address of the file is different than $ 0000, this means that the file contains no code relokowalnego, but may include blocks updates for external and public symbols. Directive. LINK accepts files of any load address, but are subject to relocation of the address only charging $ 0000, for more details on the construction of such a file is contained in Chapter block relokowalny. Reloc.

Directive. LINK allows you to connect with nierelokowalnym relokowalnego code. MADS on the basis of blocks makes the automatic updates of the file relocation. Includes all three types of blocks updated (ADDRESS, EXTERNAL, PUBLIC).
There is no limit to the address at which the file is placed relokowalny.

If the block relokowalny to action requires a software stack and the MADS-label @ STACK_POINTER, @ STACK_ADDRESS, @ PROC_VARS_ADR will be automatically updated based on the header block. Reloc. It is required to block. Reloc and the main program operated on the same software stack if it is necessary.

Mnemonics
Available commands 6502

   LDA LDX LDY STA STX STY ADC AND
   SBC ASL LSR JSR JMP CMP ORA CPY
   CPX INC DEC EOR BRK CLC ROR ROL
   CLD CLI CLV PLP PHA PLA PHP RTI
   RTS SEC SED SEI ins INX Dey DEX
   Yeah TAY TXA TXS TSX NOP TAX BPL
   BCC BCS BNE BMI BVC BVS BEQ BIT

You can use mnemonics extension after the dot "." for such orders LDA, LDX, LDY, STA, STX, STY:

   . B or. From BYTE
   . A or. In or. Q WORD

eg
   lda.w $ 80, AD 80 00
   $ lda 80; A5 80


Available illegal orders, 6502

   ASO RLN LSE RRD SAX LAX DCP ISB
   ALR AMA ANC ANE ANX SHA LAS SBX
   SHS SHX SHY NPO CIM


Available commands 65,816

Of course there are orders of 6502, and apart from them:

   SEP REP STZ TRB TSB BRA COP MVN
   PEA MVP PHD PHB PHK PLB PHX PHY
   PLD PLX PLY STP RTL TCD TCS TDC
   TSC TXY TYX WAI WDM xba XCE INA
   DEA BRL JSL JML

You can use mnemonics extension after the dot "." for such orders LDA, LDX, LDY, STA, STX, STY:

   . B or. From BYTE
   . A or. In or. Q WORD
   . T or. L TRIPLE, LONG (24bit)

eg
   lda.w # $ 00; A9 00 00
   lda # $ 80; A9 80

Exceptions are the orders n / a, which can not change the size of the registry in absolute addressing (some assemblers do not require these commands provide a '#', but MADS required)
# $ Xx

   SEP REP COP

# $ Xxxx

   PEA

Another exception is the long indirect addressing mode, which is represented by square brackets []. As we know, this type of braces are also used to calculate expressions, but if the assembler encounters the first character '[' considers it a long indirect addressing mode, and if not signaled willingness to use the 65816 error with the message Illegal adressing mode. To "cheat" assembler just before the square brackets give the opening '[' character '+'.

 lda [2 +4] lda [6]
 lda + [2 +4]; lda 6


CPU DETECTION
Detection of CPU6502, CPU65816
Example taken from http://www.s-direktnet.de/homepages/k_nadj/cputest.html. The program is able to diagnose the presence of one of the microprocessors: 6502, 65C02, 65816th

/ *

How to detect CPU on Which the assembler code is running

(This information is from Draco, the author of SysInfo 2.0)

You can test it plain 6502-Code if there is a 65c816 CPU, the 16-bit processor avaible
In some XLS as a turbo-board, avaible. Draco told me how to do this:

First we make sure, Whether we are running on NMOS-CPU (6502) or CMOS (65c02, 65c816).
I will just show the "official" way Which doesn `t uses 'illegal opcodes':

* /

 org $ 2000

 opt c +

DetectCPU

 lda # $ 99
 clc
 sed
 adc # $ 01
 cld
 BEQ DetectCPU_CMOS

DetectCPU_02

 ldx # <_6502
 ldy #> _6502
 $ c642 jsr

 lda # 0
 rts

DetectCPU_CMOS

 lda # 0
 rep #% 00000010; reset bit of
 bne DetectCPU_C816

DetectCPU_C02

 ldx # <_65c02
 ldy #> _65c02
 $ c642 jsr

 lda # 1
 rts

DetectCPU_C816

 ldx <_65816
 ldy> _65816
 $ c642 jsr

 lda # $ 80
 rts

Dta c'6502 _6502 ', $ 9b
_65c02 C'65c02 dta ', $ 9b
Dta c'65816 _65816 ', $ 9b


The next example of detection of the CPU is limited to determining the presence of the microprocessor 6502 or 65816th The program looks at disasemblacji differently for 6502, contrary to the 65816th 6502 order 'inc' @ 'deems' nop' command 'xba' deems' sbc # '. With such a "transparency" can we be sure that the program will not perform any illegal operations and honestly recognize the right CPU. The originator of this concise and very clever test is Bassewitz von Ullrich.

 org $ 2000

 opt c +; 65816 enabled

 lda # 0
 
 inc @; increment accumulator
 
 cmp # 1
 bcc cpu6502

, The ultimate test for the presence of 65,816

 xba; put $ 01 in B accu
 dec @ A = $ 00 if 65C02
 xba; get $ 01 back if 65,816
 inc @; make $ 01 / $ 02
 
 cmp # 2
 bne cpu6502

cpu65816

 ldx <text65816
 ldy> text65816
 $ c642 jsr
 rts
 
cpu6502

 ldx <text6502
 ldy> text6502
 $ c642 jsr
 rts

text6502 c'6502 dta ', $ 9b
text65816 c'65816 dta ', $ 9b


MEMORY BANKS
Probably everyone who had anything to do with the architecture of a small Atari concept of "memory bank" is associated with enhanced memory, divided on the size of 16kb banks, switched in the area <$ 4000. $ 7FFF>.

MADS can also be understood in this way (optional OPT B +, hardware memory banks), but by default this is meant in a more virtual (B-OPT option, virtual memory banks).

Banks apply to the n / a pseudo commands:

 LMB # value
 NMB
 RMB

LMB # (Load Memory Bank)
Set the banks of the MADS-counter and on the specific value of range <$ 00. $ FF> (BANK = value), eg

 lmb # 0
 lmb # bank
 lmb # 5, $ 6500; only when OPT B +

NMB (Next Memory Bank)
Increment of a counter-banks and MADS (BANK = BANK + 1).

 NMB
 NMB $ 6500; only when OPT B +

RMB (Reset Memory Bank)
Resets the MADS-and banks (BANK = 0).

 rmb
 RMB $ 3500; only when OPT B +
 RMB $ 8,500, only when the OPT B +


MADS during assemble, each newly defined label assigns the current value of the counter of banks. The developer can have an impact on banks due to the counter value at / in pseudo orders.

Labels assigned the bank counter MADS-a = 0 are a global scale.
Labels assigned the bank counter MADS-a> 0 are the local coverage.


Virtual memory banks (B-OPT)

The MADS by the concept of "virtual memory bank" is understood any area designated by the newly-defined label is assigned a counter current value of banks (the default is to reset the counter of banks). So the virtual memory bank is not necessarily a memory area <$ 4000. $ 7FFF>, but each label represents an area code, which has been assigned a code (the counter value of banks) with range <$ 00. $ FF> using the appropriate pseudo-first orders for use by the programmer (NMB, RMB, LMB).

Exceptions are the blocks. Reloc is not possible to independently change the bank counter, it automatically performs the MADS, which increases the counter for each call to the Directive. Reloc. Counter bank in which case the range is <$ 0,001th. $ FFF7>.
The programmer can read the counter value of banks, which has been assigned the label using the '=' example:

label

 ldx # = label

W / in the example in the register of the CPU regX saved value of the counter memory banks and the MADS-assigned label LABEL.

Another useful operator may be a colon ':' placed at the beginning of the name of the label. This will read the value of the MADS bypassing limitations of such a label range, which introduces a counter-banks and MADS. Sometimes it can cause complications, such as if there have more labels with the same name but in different local areas or in areas with different values ??of the counter of virtual banks.

 lmb # 5

label5
 nop

 lmb # 6

label6
 nop

 lda: label5

For w / in the example no operator ':' at the beginning of the label names in the order 'lda: label5' ends with an error message ERROR: Undeclared label LABEL5 (BANK = 6).

Virtual memory banks can be used to index the array containing the values ??for PORTB. This is also their use in the event you choose to OPT B +.


Sprzetowe memory banks (OPT B +)
This mode of operation the MADS-and can be described as "sensitive to the banks" (BANK SENSITIVE).

Hardware memory banks are an extension of virtual banks. Are understood by MADS as expanded memory banks, included in the area <$ 4000. $ 7FFF>. Action pseudo orders NMB, RMB, LMB is extended by calling the macro @ BANK_ADD that can be found in the directory .. \ EXAMPLES \ MACROS \.

In this mode of operation requires a declaration of specific MADS macros:

 @ BANK_ADD
 @ BANK_JMP

and requires the definition of labels with names:

@ TAB_MEM_BANKS
@ PROC_ADD_BANK

@ TAB_MEM_BANKS label specifies the address of the array from which values ??will be transcribed in the register of PORTB is responsible for switching banks expanded memory. We can help you know and use the ready-detection procedures for expanded memory banks attached to the MADS-a, file .. \ EXAMPLES \ PROCEDURES \ @ MEM_DETECT.ASM.

@ PROC_ADD_BANK label is used by the macro @ BANK_ADD and defines the address at which the code will be extended memory bank switching.

The programmer can read the counter value of banks, which has been assigned the label using the '=', eg:

label

 ldy # = label

W / in the example to the register counter value saved Regy memory banks and the MADS-assigned label LABEL.

If the counter of banks MADS-a = 0 is:
code must be placed outside of the <$ 4000. $ 7FFF>
newly defined labels in this area are global
You can refer to all defined labels without limitations, regardless of the number of bank
spike in area bank possible by using a macro @ BANK_JMP (.. \ EXAMPLES \ MACROS \ @ BANK_JMP.MAC), the parameter for this macro need not be preceded by the operator ':'

If the counter of banks MADS-a> 0 is:
code must be placed in the <$ 4000. $ 7FFF>
newly defined labels in this area are local
can refer only to the global and the labels defined in the current bank
pseudo order LMB, NMB will execute the macro @ BANK_ADD, which includes a new bank under the expanded memory banks of the MADS-counter and sets the new address and assemble (by default on $ 4000)
RMB pseudo command resets the counter memory banks and the MADS-and setting new address assemble outside the bank (by default on $ 8000)
jump in the area of ??another bank possible by using a macro @ BANK_JMP (.. \ EXAMPLES \ MACROS \ @ BANK_JMP), the parameter for this macro must be preceded by the operator ':'

An example of using this mode and the MADS-file .. \ EXAMPLES \ XMS_BANKS.ASM. In this example, the program code is located in two different banks, expanded memory and performed as if it were one entity.


HISTORY

v1.9.2

- Possibility to specify the address for. ZPVAR = $ XX
- Improved references to enumeration labels. ENUM, eg enum_label (field0, field1)
- Added ability to generate external symbols of the block BLK for UPDATE EXTRN for DOS files, previously only for files. Reloc, eg:

  . Extrn Vbase. Word
  org $ 2000
  lda # $ 80
  sta Vbase + $ 5d

  blk update extrn

- Added an error message "Could not use NAME in this context" in the case of appeals to block orders. MACRO. ENUM. STRUCT
- Fixed bug that prevented the use of 'EQU' in the name of the label
- Added the directive. ,....., CB + byte last byte string is stored in inwersie
- Added support for the segments by the Directive. SEGDEF. SEGMENT. ENDSEG
- Added new directive # # N CYCLE 6502 code generating a given number of cycles N
- Added support for CPU illegal instruction 6502, for example in the file .. \ examples \ test6502_illegal.asm
- Updated config files for Notepad + + '.. \ syntax \ Notepad + +'
- Fixed file record LST
- Fixed memory allocation for the structural variables, extended syntax for. STRUCT

. Struct LABEL
 x, y, z. word / / number of variables of the same type on one line
 . Byte a, b
. Ends

. Enum type
  a = 1, b = 2
. Ende

. Struct Label2
  x type
  type y
. Ends

v1.9.0

- Fixed-line record of comments / * * / to a file listing *. LST, before these lines were not saved
- Amendment to the label declared with the command line-d: label, such labels previously been seen only in the first pass
- In the case of additivity blocks. LOCAL address only the first of these blocks is saved
- Fixes for parsing macros, labels before starting with the END may be interpreted as a pseudo-command END
- Fix for empty file read relokowalnego, previously occurred error "Value out of range '
- Fixes for. USING (. USE)

v1.8.8 - 1.8.9

- An updated engine software ghost .. \ EXAMPLES \ Sprites \ CHARS about ghosts 8x24
- For not including the file extension and the absence of such a file for ICL 'filename' will be adopted by default, the *. ASM ICL 'filename.asm'
- Improved performance comments / * * / in blocks. MACRO and. REPT
- Removed a bug that prevents the proper assembling block # IF, # WHILE expressions joined by. OR. AND
- Switches on the command line can only be preceded by a '-', formerly the '/', however, were problems with the sign on MacOSX
- Fixed scope of the Directive. USING, for the current namespace and another and contain the namespace

v1.8.6 - 1.8.7

- Improved recognition of comments / * * / in the expressions
- The default address for. ZPVAR set at $ 0,080, previously $ 0000
- Added new directive. Elif directive as shorter counterpart. ELSEIF
- Extended operation of the Directive. LEN about the possibility of giving a filename as a parameter, it returns the length of the file
- Improved performance of the directive. DEF condition expressions. IF (. IFDEF. Ifndef)

v1.8.5

- Added macro relokujace RMT modules ... \ EXAMPLES \ MSX \ RMT_PLAYER_RELOCATOR \
- Added test for syntax not asemblowanych procedures. PROC is activated when the switch-x "Exclude unreferenced Procedures"
- Fixed the switch "-d: label [= value]", providing a value for the label is now optional, default value of 1 assigns mads
- The Directive. DS. ALIGN will not cause the allocation of variables defined. VAR
- Allocation of variables. VARs for the new block will not happen if the ORG ORG block located in the block. LOCAL or. PROC
- Fixed line breaking character '\' in strings bounded by brackets ()
- Removed a bug where the relocated address for the expression of the Directive. ERROR (ERT)
- Removed bugs when parsing command line parameters
- Removed bugs for optimizing the length of the macro code instruction MVA, MWA, etc.
- Implementing the revised code nesting blocks. PROC
- Fixed code executing action commands pseudo IFT condition ELI ELS EIF
- Added the message "'#' is allowed only in repeated lines" for the use case loop counter # (. R) outside the loop
- Removed a bug that caused erroneous allocation of variables declared by the Directive. VAR while the macro
- In order to unify the syntax of references to an enumeration type labels are possible only through the dot '.', Formerly also by the '::'
- Possible shorter references to enumerations enum_label (fields), eg:

. Enum type
 val0 = 1
 val1 = 5
 val2 = 9
. Ende

 lda # type (val0 | val2) == "lda # typ.val0 | typ.val2"

- Extended syntax for the directive. SAV, for example:

 . Sav 'filename', offset, length
 . Sav 'filenema' length
 . Sav [offset] 'filename', offset2, length
 . Sav length
 . Sav offset, length

- Extended syntax for the directive. ARRAY, in the absence of administration of the maximum array index will be calculated on the basis of the quantity of elements, the elements can be introduced without the need to precede the index of [expression], for example:

. Array temp. Byte
 1,4,6; [0 .2] = 1,4,6
 [12] = 9.3; [12th .13] = 9.3
 [5]: [8] = 10.16; [5 .6] = 10.16; [8th .9] = 10.16
 0,0, \; [14th .17] = 0,0,1,1
 1.1
. Enda; 18 elements, TEMP [0 .17]

- Added possibility to allocate a variable of type structured by means of directives. VAR and. ZPVAR, for example:

. Struct Point
 x. byte
 y. byte
. Ends

 . Var a, b, c Point
 . Zpvar Point f, g, and

- Added possibility to allocate a variable of type enumeration using directives. VAR and. ZPVAR, for example:

. Enum Boolean
 false = 0
 true = 1
. Ende

 . Var Boolean test
 . Zpvar Boolean test

- Added possibility of declaration of the structure fields using enumerations, such as:

. Enum Estate
  DONE DIRECTORY_SEARCH, INIT_LOADING, LOADING
. Ende
 
. Struct SLoader
    m_file_start. word
    m_file_length. word
 
    m_state Estate
. Ends

v1.8.3 - 1.8.4

- New motor spirits with the minimum requirements of program memory, no image memory buffers ... EXAMPLES \ Sprites \ CHARS_NG
- New version packer Huffman (compatible with Free Pascal Compiler-em, "fpc-MDelphi sqz15.pas") and Huffman decompressor SQZ15 ... EXAMPLES \ COMPRESSION \ SQUASH
- Fixed code generated for orders MVP, MVN, PEA, BRA (65816 CPU)
- Added new orders BRL, JSL, JML (65816 CPU), as the equivalent of the orders of long jumps BRA, JSR, JMP
- Block updates the labels outside (external) has been extended to junior and senior record of the address byte of this label
- Fixed effect of the Directive. USE (. USING), operates independently of the namespace which is used
- Removed a bug in certain situations, skipping assemble block # IF, # WHILE
- Added ability to define variables by the Directive. DS or pseudo-ORG command before the block. Reloc
- Added additional form of syntax for the directive. VAR, except that for this case is not possible to determine the address location of variables in memory

 . VAR. TYPE LAB1 lab2 lab3. TYPE lab4. Lab5 lab6 TYPE ...

 . Var. Byte a, b, c. Dword and j

- Added possibility of definition of individual variables in a less structured way than before by DTA

. Struct @ Point
 x. byte
 y. byte
. Ends

point @ point; point dta @ point [0] <=> Point dta @ Point
pointB @ point; pointB dta @ point [0] <=> pointB dta @ Point

points dta @ point [100]

- Added new directive. ZPVAR to automatically allocate space variable at zero

 . ZPVAR TYPE label1, Label2 label3 = $ 80; label1 = $ 80, Label1 Label2 = + TYPE, LABEL3 = Label2 + TYPE
 . ZPVAR Label4, label5 TYPE; Label4 = LABEL3 + TYPE, LABEL5 = Label4 + TYPE

 . Print. Zpvar

- Fixed effect of the Directive. ERROR ERT and pseudo orders, it is possible to place additional information in the row just like to. PRINT (. ECHO), for example:

  ERT *> $ 6000, 'BUUU exceeded the scope of memory', *- $ 6000, 'bytes'

- Added possibility of nesting blocks procedures. PROC, the same code can be called with different parameters, such as:

. CopySrc percent (. Word src +1). Var

 . ToDst percent (. Word src +1, dst +1). Var
 . Endp

ldy # 0
src lda $ ffff, y
dst sta $ ffff, y
ins
bne src

rts
. Endp

copySrc.ToDst # $ a080 # $ B000

copySrc # $ A360

- Added new directives. ENUM and. Ende (. Eend)

. Dni_tygodnia enum

Monday = 1
Tuesday, Wednesday = 5, Sunday = 7
Friday
Saturday
Sunday

. Ende

ift == dni_tygodnia Day: Tuesday
. Print 'Tuesday'
e and f

- Extended the functionality of multi-line comments / * * / o the ability to put them anywhere

 lda # 12 + / * comment * / 23

- Made possible relocation of addresses defined by Directive. DEF

 . Reloc
 . Def label =*
 lda label

- Added ability to use characters {} to denote the block (except block. MACRO), the sign'{','}' is recognized at the beginning of a new line, eg:

# While. A word ad <= # $ bc40 39
{
ad sta $ bc40

ad an inv
}

. Percent lab
{
. Local temp2
{
}

. Array Table [255]. Long
{}
}

v1.8.2

- Removed the file length limit for pseudo command INS (previously included file length was limited to 65536 bytes)
- Added an error message "The referenced label ... Previously has not been defined Properly 'in the case of labels that are not defined until the end, for example, only a first pass an indeterminate value
- Added new directive. ECHO as a counterpart to the Directive. PRINT, the information generated. PRINT (. ECHO) are now also saved in *. LST Listing
- Added new directive. ALIGN allows for alignment to a specified range of memory, plus you can specify what value to fill memory

  [Label]. ALIGN N ??[, fill]

- Added new switch-U (Warn of unused labels)

1.8.1

- Extended operation of a backslash '\', placing it at the end of the line is a continuation of the current line from the new line, for example:

  macro_temp \
  _____________________________________parametr1_________________________________________________ \
  _____________________________________parametr2_________________________________________________ \
  _____________________________________parametr3_________________________________________________

  lda \
  #____________________________________ Label________________________________________ \
  +__________________________________ Expression___________________________________

- Changed to call the endless testing of the macro followed by an error 'Infinite Loop'
- Fixed a record label to *. LAB, an error was made after the addition of areas additivity LOCAL
- Fixed effect of pseudo command SIN (code borrowed from XASM)
- Improved recognition of the switch turned on, the directives-C (Case sensitive)
- Improved reading blocks. REPT (indicating the correct line with an error) and. MACRO
- Disabled use. VAR block. REPT
- Enabled nested and multiple run (through macros) loop. REPT i: repeat (previously occurred the message 'Use. REPT directive')
- Enabled to pass parameters to the block. REPT, eg

. REPT 10, #
Label: 1; LABEL0, Label1, Label2 ... LABEL9
. Endre

. REPT 5, $ 12, $ 33, $ 44, $ 55, $ 66
 dta: 1, 2, 3, 4, 5, $ 12, $ 33, $ 44, $ 55, $ 66
 dta: 5, 4, 3, 2, 1, $ 66, $ 55, $ 44, $ 33, $ 12
. Endre

1.7.9 - 1.8.0

- Fixed error in the description of the switch-F, previously 'Label at first column', the correct description of this 'CPUs command at first column'
- Rewritten from scratch Service Directive. DS and option F + OPT (added the ability to use blocks and RUN INI)
- Rewritten from scratch support for OPT option? + (Local labels in the standard IEA)
- Added possibility of publicity in the blocks declared by the PUBLIC arrays. ARRAY structures and declarations. STRUCT
- Directive generates code 6502 for a decision. TEST was replaced by Directive # IF directive. ENDT by # END additionally possible to use the directive # ELSE eg:

 # If. Byte and> # 8. And. Byte and <# 200
 # Else
       # If. Word j = # 12
       # End
 # End

- Directive generates code for the 6502 iteration. WHILE was replaced by Directive # WHILE, Directive. ENDW by # END, for example:

 lda 20 -> lda 20
 # While. Byte @ = 20 -> wait cmp 20
 # End -> sne
                      -> Jmp wait

- Directive # # WHILE IF and accept two additional operators '==' and '! ='
- Added the directive. EXITM as equivalent. EXIT
- Added the directive. IFs as equivalent. ENDIF
- Added the directive. IFDEF directives as shorter counterpart. IF. DEF
- Added the directive. Ifndef directives as shorter counterpart. IF. NOT. DEF
- Was made possible to define macros in the procedure. PROC, summarizing the current limit is to define macros in the area. LOCAL and. PROC
- The occurrence of any warnings while assembling exitcode will not change (exit_code = 0), a change dictated by the need for compatibility with the Linux makefile
- Unified way to label declarations of local and global, "white space" before the name of the label did not reveal a need to define this label as global, this will enable only the directive. DEF: LABEL
- Fixed makra@CALL.MAC i@CALL_2.MAC, global temporary variable? @ Stack_offset is now modified by the Directive. DEF
- Resignation of the option-E (Eat White spaces), currently this option is always enabled
- Fixed display line number of error in a macro is currently being executed
- Abbreviated names of the labels created during the macro (easier to identify a file *. LAB)
- Fixed option action of H-OPT
- Added new macro commands INL (increse LONG), IND (increse DWORD), DEL (decrese LONG), DED (decrese DWORD)
- Added new macro commands CPB (compare BYTE), CPW (compare WORD), CPL (compare LONG), CPD (compare DWORD)
- Improved and extended action directives and # # TEST WHILE based on the code generated by macro commands CPB, CPW, CPL, CPD, directives and # # TEST WHILE expressions '= # 0' and '<> # 0' generates the shortest code resultant
- Added optimization of the length of the generated code for the macro commands MWA, MWX, MWY
- Added new option to optimize R OPT macro code instruction MWA, MWX, MWY, MVA, MVX, MVY due to the registers, for example:

                    opt opt ??r-r +
    mva # 0 $ 80 -> lda # $ 00 -> lda # 0
    mva # 0 $ 81 -> sta $ 80 -> sta $ 80
                    lda # $ 00 -> sta $ 81
                    sta $ 81 ->

- Extended the functionality of the Directive. DEF about the possibility of assigning the value of the newly declared the label, such as:

 . Def label = 1

- Extended the functionality of the Directive. DEF labels about the possibility of defining a global matter aktulnego local area, for example:

 . Def: label

- Was made possible additivity of areas. LOCAL, ie, there may be many local areas of the same name, the symbols contained in such areas will belong to a common namespace, eg:

. Local namespace

 . Proc1 percent
 . Endp

. Endl

. Local namespace

 . Proc2 percent
 . Endp

. Endl

1.7.8

- Added the directive. Mende,. PGEND. Rend as equivalents. ENDM. ENDPG. Endre
- Now the macro declaration must end with the Directive. ENDM or. MENDE (previously it was possible to use the directive. END)
- Improved way of making macros so that implementation of the directive has been made possible. Endl executed from within a macro
- Fixed bugs on older relokowanego bytes of address and updating a block of public symbols
- Added new directive. USING (. USE) to specify a path to search for the names of labels
- Fixed effect of directives. LOCAL. DEF whose malfunction manifested in specific cases
- Fixed effects strokes macro commands (SNE, RNE, etc.), whose malfunction manifested in specific cases
- Extended syntax for the directive. TEST (6502 code for the condition) for any number of expressions connected by. OR or. AND (no change piorytetu evaluation using parentheses), eg:

 . Test. Byte k> # 10 1. Or. Word j> # 100. And. Word j <# 105. Or. Byte k <= # 5
 ...
 ...
 . Endt

- Extended syntax for the directive. WHILE (code 6502 for a loop) for any number of expressions connected by. OR or. AND (no change piorytetu evaluation using parentheses), eg:

 . While. Byte k> # 4. And. Byte k <# 39
 ...
 ...
 . Endw

1.7.6 - 1.7.7

- Added new switch-B: ADDRESS to enable assembling of the specified address
- Added new option OPT F + - allows to create blocks of contiguous memory (useful for cartw)
- Added support for type parameters. LONG and. DWORD passed to procedures. PROC type. VAR (previously accepted parameters was only types. BYTE and. WORD)
- Added new directive. FL realizing a record of real numbers REAL Atari FP format, eg:

pi. 3.1415926535897932384626433832795 fl; 40 03 14 15 92 65
tb. fl 0.5 12.34 -2.30 0.00002
tb. fl 0.5, 12.34, -2.30, 0.00002

- Has made possible a record value than other types. Byte in the block. ARRAY
- Added support for multiple types. STRUCT, before these types of memory have been accepted but has not been properly reserved for them, for example:

  . Struct test
   x: 200. byte
   s: 999. long
  . Ends

dta test buf [0]

- Fixed error in the code generation relokowalnego Laoo noticed by, for example:

  . Reloc

   lda temp
temp. long $ aabbcc

- Error 'relocation Addres overload' now occurs only when the expression will involve more than one label relokowalnej, before any expression involving relokowalnej labels would show this error message
- Block updates plublicznych symbols was extended to the possibility of permanent transfer of various types of B-USED, W-ORD, L-ONG, D-WORD, previously passed was just the type W-ORD
- Modified operation of the Directive. VAR in blocks. LOCAL located in the block. PROC, such variables are always postponed to the end of the block in front of the Directive. ENDP, in other cases at the end of the block. LOCAL against the Directive. Endl
- Was made possible relokowalnosc code generated by the Directive. WHILE and. TEST
- Fixed the value of a test operation. WORD in the code generated by the Directive. WHILE and. TEST
- Added new directive. ADR returns before the change of address labels address assemble
- Added new directive. LEN returns the length of the blocks defined. PROC and. ARRAY
- Improved performance of operations division, multiplication and modulo, previously erroneously been interpreted Priority for these operations
- Comments from the end of the line is not preceded by a comment that will cause an error "Unexpected end of line '
- Added ability to assign a variable fields defined by the structure, eg:

@ Point. Struct
       x. byte
       y. byte
       . Ends

and @ Point
b @ point
c @ point

- Extended syntax. STRUCT the ability to add new fields without specifying the field name, eg:

 . Struct @ id
  id. word
 . Ends

 . Struct @ mem
  @ Id
  adr. word
 . Ends

- Extended syntax of the command macro MWA about the possibility of using a zero-page indirect addressing postindeksowanego Y, for example:

  mwa ($ 80), y $ A000, x
  $ mwa bc40, y ($ f0) s
  mwa ($ 80), y ($ 82), y

- Extended syntax for the directive. EXTRN, it is now possible The announcement of more different types of labels in one row, the announcement of the procedure. PROC in this line must appear at the end, eg:

  . Extrn a, b, c, d. Byte xyz. Word line. Percent (. Byte x, y). Reg

- Extended syntax for the directive. VAR, it is now possible to declare more labels of various types in one line and assign them to the address of which will be set aside in memory, for example:

  . Var x, y of. Byte bit 2. Dword = $ 80

- Extended syntax for the parameters of the procedures provided by the variables. VAR, it is possible to specify offset, eg:

move. percent (. word src +1, dst +1). var

src lda $ ffff
dst sta $ ffff

     . Endp

- Added new directive. Nowarn exempting display warnings for the currently asemblowanego line, eg:

 . Nowarn PROCNAME

- Added new macro commands PHR, PLR, performing deposition and removal of the registers with the hardware stack, for example:

  PHR -> PHA PLR -> PLA
         TAY TXA
         PHA PLA
         Yeah TAX
         PHA PLA

- Added new macro commands ADB, SBB performing addition and subtraction of the value type. BYTE, for example:

 ADB $ 80 # $ 12 B000 -> lda $ 80
                        clc
                        adc # 12
                        sta $ B000

 SBB # 200 $ A000 -> lda # 200
                        sec
                        sbc $ A000
                        sta $ A000

- Added ability to use C syntax for hex numbers, eg:

 lda 0x2000
 ldx # 0x12

temp = 0x8000

1.7.5

- Directive. DS blocks SDX relocatable reloc reloc and MADS declares a block from the now empty
- Added new switch-F, which allows you to place orders and pseudo CPU orders from the first column in row
- New procedures prescribed by reading blocks. MACRO. REPT and implements a procedure to share the line with the character '\'
- Added new pseudo orders ADW, SBW performing addition and subtraction of values ??of type WORD for CPU6502, for example:

  hlp adw # 40; hlp = hlp 40
  hlp adw # 20 pom, pom = hlp 20

- Extended operation of the Directive. DEF about the possibility of defining a label, for example. DEF label
- Increased number of passes for the EQU statement labels for certain special cases

1.7.4

- Fixed effect of the Directive. PRINT, yet could not see the value of the label that starts with the letter 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', ' L ',' T ',' V '
- Blocked the action of the Directive. DS blocks. Reloc and SDX, and repaired its operation with a conditional statement. IF (IFT)
- Improved search-and access paths: path (you can refer to subdirectories contained therein)
- If errors are displayed when you assemble them all and not just the first of the errors
- Fixed bugs, including the use of macros in the file. reloc could cause in some cases incorrect information on the record addresses relokownych
- Simplified procedures for termination was a way using the MADS-software stack and there is no need to use the directive. EXIT, and the Directive. ENDP no longer causes additional action on the stack software
- Added new directive. SYMBOL as a counterpart to the block update UPDATE NEW SYMBOL BLK 'SYMBOL' directive. SYMBOL can be used anywhere in the program
- Added automatic update blocks induction (ADDRESS, EXTERNAL, PUBLIC, SYMBOL) for. Reloc and SDX
- Added new directives. BY. WO. HE. EN. SB (borrowed from IEA)
- Added new switch OPT? - (Default) label with a question mark (? Labels) are treated as temporary labels, OPT? + Label with a question mark (? Labels) are treated as local and temporary, the name of the local area is the recently used the label without question mark
- Added the directive. LEND. PEND. AEND. WEND. TENDA. SEND as the equivalent directives. Endl. ENDP. ENDW, ENDW. ENDT. ENDS
- Added new directives. And GLOBAL. GLOBL as a counterpart (replacement) of the Directive. PUBLIC
- Added optimize conditional jumps JEQ, jne, JPL, JMI, JCC, JCS, JVC, JVS, if this option is selected a short jump BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS
- Added new default separator character space to the reported parameters. PROC. MACRO, yet it was only a comma
- Improvement of the transmission parameters to macros and procedures, such as paramatrem macros can be directive or an expression that returns the value of the loop counter symbol '#'

  12 Macro #

- Added ability to use a space as a separator for. VAR. EXTRN, eg

  . EXTRN a b c d. Word
  . VAR i = 1 j = 2. Byte
  . VAR a b c d. Byte

- Extended syntax for. VAR allows ignited variables constant, for example:

 . Var i = 10 j = 12. Byte
 . Var a, b = 2. Byte

- Added new directives. WHILE. ENDW allow you to automatically generate code for a WHILE loop, for example:

         ldx # $ ff
 . While. Word addr <# $ bc40 40 * 24
         stx $ bc40
    adr: equ *- 2
         inv addr
 . Endw

- Added new directives. TEST. ENDT allow you to automatically generate the code for the condition, such as:

 . Test. Byte (@>=#' a ')
  . Test. (@<=#' Of byte ')
      
  . Endt
 . Endt

1.7.3

- Added possibility to change the address assemble. PROC or. LOCAL without charging a change of address
- Removed to optimize the code for the macro commands MWA, etc., which could cause in particular cases, the MADS-loop and
- Added the directive. REG. VAR to determine a way of passing parameters to procedures (. REG by the CPU registers. VAR for variables)
- Added the directive. VAR allows for the declaration of variables in blocks. PROC. LOCAL, declared zmiennne are physically deposited at the end of the block
- Extended syntax for the directive. EXTRN such EXTRN label1, Label2, label3 ... TYPE
- If no declaration of labels for the software stack MADS-a, default values ??are accepted @ PROC_VARS_ADR = $ 0500, @ STACK_ADDRESS = $ 0600, @ STACK_POINTER = $ FE
- Added repeat_counter # that can be used interchangeably with the Directive. R
- An error occurs '^ not relocatable' when trying to relocate the command '^ lda label'
- Added support for regular public symbols (C-ONSTANT) in blocks PUBLIC
- Improved relokowalnosc for arrays. ARRAY, data created by. STRUCT, the parameters passed to procedures by the constant #

v1.7.2

- Rewritten support for pseudo orders REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS, SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS
- Fixed effect of the Directive. LINK for blocks with a fixed address
- Improved testing of reserved words (you can use names reserved for use only when 65816 6502)
- Changes in the listing, it displays information about the number of the bank only when a bank> 0
- Added support for macro commands MWA, MWX, MWY, MVA, MVX, MVY, ADD, SUB, INW, DEW (to support them are no longer needed macros)

v1.7.1

- Added ability to use mnemonic names of 65,816 in 6502 mode, the mode has an error occurs 65816 Reserved word
- Fixed effects strokes SCC pseudo commands, macros, etc. in RNE
- Improved performance of many macros separated by a colon ':'

v1.7.0

- Removed a bug that caused too small number of runs assemble
- Added support for pseudo orders JEQ, jne, JPL, JMI, JCC, JCS, JVC, JVS (macros are no longer needed to operate them)

v1.6.9

- Extended syntax for. ARRAY. PUT
- Added pseudo-EXT command allows the external label declarations
- Added macros JEQ, jne, JPL, JMI, JCC, JCS
- Added the directive. PAGES and. ENDPG
- Added the directive. END replacing other directive. END?
- Switch-H was replaced by a-HC (generates a header file for CC65)
- Added new switch-HM generating header file for the MADS-and sorting out the type of label constants, VARIABLES, PROCEDURES
- Added new directive. Reloc relokowalny generates code in the format and the MADS-

v1.6.8

- Added new directive. PUT, and extended syntax for the directive. GET (.. / EXAMPLES / MSX / MPT_PLAYER / MPT_RELOCATOR.MAC, .. / EXAMPLES / MSX / TMC_PLAYER / TMC_RELOCATOR.MAC)
- Added support for pseudo-XASM orders and REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS, SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS
- Added the possibility to combine any number of known MADS-these mnemonics using the mark ':' (style XASM s), eg:

  lda: cmp: req 20
  ldx: ldy: lda: iny label

v1.6.6 - 1.6.7

- The source of the MADS-and compatible with Free Pascal Compiler, the compilation is possible to use it on other platforms such as Linux, Mac OS, OS / 2, etc.
- From now MADS himself selects the appropriate number of passes assemble, switch '/ 3' is no longer needed
- Improved and developed a mechanism of passing parameters to the MADS box (chapter 'The relay assembly')
- Calling a macro has been corrected in the line delimited by a '\' and the recognition and enforcement of improved lines of characters separated by '\'
- Fixed bug where the wrong MADS Directive. ENDM of pseudorozkazem IFT
- Fixed effect conditional statements. ELSEIF. ELSE
- Improved validation testing of conditional statements in macros
- Handling procedures. PROC has been expanded with new macros and mechanisms through which is similar in operation and ease of use to the procedures of the higher-level languages
- For procedures. PROC with the declared parameters is now required additional declaration @ PROC_VARS_ADR
- No restrictions on the number of parameters passed to procedures, limited only by available memory
- Added new switch / d: label = value which allows to define a new label MADS-a from the command line
- Added new switch / x "Exclude unreferenced Procedures" allows to skip during assemble not used in the procedure declared Directive. PROC
- New option OPT T + (sep track, rep) tracking changes in the size of the registers A, X, Y, orders made by the SEP, REP (65816 CPU)
- New library in the directory .. \ EXAMPLES \ LIBRARIES
- The declaration of the local area. LOCAL is not required to enter the realm name
- New operators'-=','+=','++', '-' to reduce / increase the value of the temporary labels, such as:

  ? Label - ->? Label =? Label-1
  ? Lab + + ->? Lab =? Lab 1
  ? Temp + = 3 ->? Temp =? Temp 3
  ? Offset -= 5 ->? Offset =? Offset-5

- Extended syntax of the comma sign the declaration procedure parameters, such as:

 . Proc name (. Byte a, b, c. Word d, e)
 . Endp

v1.6.5

- Added new switch '-3' incorporating 3 runs instead of 4-echoes for faster assembling
- Improved processing of structures declared in the memory of the MADS-a, the order of the listing is no longer relevant
- Added the ability to connect any number of lines in a poem listing using the character '\'

v1.6.4

- Added the directive. R, returns the counter value of the loop. REPT <0. Max>
- Added possibility to use space in the data type declarations such as dta a (...
- Removed bugs

