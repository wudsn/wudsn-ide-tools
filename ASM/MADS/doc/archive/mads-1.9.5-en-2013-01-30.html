<?xml version="1.0" encoding="ISO-8859-2" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<!-- Original file, Polish : http://mads.atari8.info/mads.html -->
<!-- Original file, English: http://translate.google.de/translate?hl=de&sl=pl&tl=en&u=http%3A%2F%2Fmads.atari8.info%2Fmads.html -->
<!-- Validate XHTML using  : http://validator.w3.org/ -->
<!-- Continue review after line 2200 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2"/>
	
<title>MAD-ASSEMBLER INSTRUCTIONS</title>

<style type="text/css">

h1 {
	font-family: Tahoma, Verdana, Arial;
	font-size: 24px;
	color: #000000;
	background-position: left;
	font-weight: bold;
	text-decoration:underline;
}

h2 {
	 text-decoration:underline;
}

h3 {
	 text-decoration:underline;
}

h4 {
	 text-decoration:underline;
}

.switch {
	font-weight: bold;
}

.footnote {
	font-family: Tahoma, Verdana, Arial;
	font-size: 9px;
	color: #666666;
	text-decoration: none;
	background-position: center;}

.code {
   font-family: monospace;
   color: #0000FF;
}

.editors-note {
    font-family: Tahoma, Verdana, Arial, sans-serif;
    font-style: italic;
}


.tekst {
	font-family: Tahoma, Verdana, Arial;
	font-size: 11px;
	color: #000000;
	font-weight: normal;
	background-position: left;
}

.tekst-wiekszy {
	font-family: Tahoma, Verdana, Arial;
	font-size: 14px;
	color: #000000;
	background-position: left;
	font-weight: bold;
	border-bottom-width: 1px;
	border-bottom-style: solid;
	border-bottom-color: #666666;
}

</style>
</head>

<body style="font-family: Courier New;font-size:12px">


<div style="text-align:center">
<h1>MAD-ASSEMBLER 1.9.5</h1>
<div class="footnote">Tebe/Madteam (01.01.2013)</div>
<div class="footnote">Translated <span style="text-decoration:strikeout">poorly</span> to English by Phaeron using Google Translate (26.01.2013)</div>
<div class="footnote">Formatted and revised by JAC!, not final yet (29.01.2013)</div>
</div>

<hr/>

<div id="tableofcontent">
<table>
<tr><td style="vertical-align:top">
<ul>
<li><b><a href="#introduction">Introduction</a></b>
<ul>
<li><a href="#preface">Preface</a></li>
<li><a href="#compilation">Compilation</a></li>
<li><a href="#differences_and_similarities">Differences and similarities between XASM and MADS</a>
<ul>
<li><a href="#similarities">Similarities</a></li>
<li><a href="#differences">Differences and new features</a></li>
</ul>
</li>
</ul>
</li>

<li><b><a href="#switches">Usage</a></b>
<ul>
<li><a href="#switches">Assembler switches</a></li>
<li><a href="#error_codes">Error codes</a></li>
<li><a href="#lst_file_format">.LST file format</a></li>
<li><a href="#lab_file_format">.LAB file format</a></li>
<li><a href="#h_file_format">.H file format</a></li>
</ul>
</li>

<li><b><a href="#sdx">SpartDOS X</a></b>
<ul>
<li><a href="#dos_file_fomats">SpartaDOS X and Atari DOS formats</a></li>
<li><a href="#programming_spartados_x">Programming SpartaDOS X</a></li>
</ul>
</li>

<li><b><a href="#mnemonics">Mnemonics</a></b>
<ul>
<li><a href="#opcodes_8bit">6502</a></li>
<li><a href="#opcodes_8bit_ill">6502 (illegal)</a></li>
<li><a href="#opcodes_16bit">65816</a></li>
</ul>
</li>

<li><b><a href="#cpu_detection">CPU detection</a></b>
</li>

<li><b><a href="#memory_banks">Memory Banks</a></b>
<ul>
<li><a href="#virtual_memory_banks">Virtual</a></li>
<li><a href="#hardware_memory_banks">Hardware</a></li>
</ul>
</li>

<li><b><a href="#relocatable_code">Relocatable code</a></b>
<ul>
<li><a href="#relocatable_blocks">Relocatable blocks</a></li>
<li><a href="#labels_ext">External symbols</a></li>
<li><a href="#labels_pub">Public symbols</a></li>
<li><a href="#linking">Linking</a></li>
</ul>
</li>

<li><b><a href="#types">Types</a></b>
<ul>

<li><b><a href="#structures">Structures</a></b>
<ul>
<li><a href="#_struct">Declaring structured types</a></li>
<li><a href="#struct_wy">Defining structured data</a></li>
</ul>
</li>

<li><b><a href="#enums">Enumerations</a></b>
<ul>
<li><a href="#enums">Declaring enumerated types</a></li>
<li><a href="#enums">Defining enumerated data</a></li>
</ul>
</li>
</ul>
</li>

<li><b><a href="#history">History</a></b>
</li>
</ul>

</td>

<td style="vertical-align:top">
<ul>

<li><b><a href="#syntax">Syntax</a></b>
<ul>
<li><a href="#comments">Comments</a></li>
<li><a href="#combining_multiple_lines">Combining multiple lines into one line</a></li>
<li><a href="#combining_multiple_mnemonics">Combining multiple mnemonics</a></li>
</ul>
</li>

<li><b><a href="#expressions">Expressions</a></b>
<ul>
<li><a href="#numbers">Numbers</a></li>
<li><a href="#operators">Operators</a></li>
</ul>
</li>

<li><b><a href="#labels">Labels</a></b>
<ul>
<li><a href="#labels_anm">Anonymous</a></li>
<li><a href="#labels_lok">Local</a></li>
<li><a href="#labels_glo">Global</a></li>
<li><a href="#labels_set">Temporary</a></li>
<li><a href="#labels_mae">MAE-style temporary</a></li>
</ul>
</li>

<li><b><a href="#_opt">Assembly control</a></b>
<ul>
<li><a href="#_opt">Changing assembly options</a></li>
<li><a href="#conditions">Conditional assembly</a></li>
<li><a href="#_error">Stopping assembly</a></li>
<li><a href="#assembling_into_zero_page">Assembling into zero page</a></li>
</ul>
</li>

<li><b><a href="#macro_commands">Macro commands</a></b>
</li>

<li><b><a href="#pseudo_commands">Pseudo-commands</a></b>
<ul>
<li><a href="#_blk">Defining SDX blocks</a></li>
<li><a href="#_smb">Defining SDX symbols</a></li>
<li><a href="#_dta">Defining data</a></li>
</ul>
</li>

<li><b><a href="#directives">Directives</a></b>
<ul>
<li><a href="#_rept">Repetition (.REPT)</a></li>
<li><a href="#_symbol">Defining SDX symbols (.SYMBOL)</a></li>
<li><a href="#_segment">Defining segments (.SEGDEF)</a></li>
</ul>
</li>

<li><b><a href="#directives_6502">6502 code generation directives</a></b>
<ul>
<li><a href="#_while6502">Defining loops (#WHILE)</a></li>
<li><a href="#_test6502">Defining conditionals (#IF)</a></li>
<li><a href="#_cycle6502">#CYCLE</a></li>
</ul>
</li>

<li><b><a href="#arrays">Arrays</a></b>
<ul>
<li><a href="#array">Declaring arrays</a></li>
</ul>
</li>

<li><b><a href="#macros">Macros</a></b>
<ul>
<li><a href="#declaring_macros">Declaring macros</a></li>
<li><a href="#calling_macros">Calling macros</a></li>
</ul>
</li>

<li><b><a href="#procedures">Procedures</a></b>
<ul>
<li><a href="#proc">Declaring procedures</a></li>
<li><a href="#proc_wy">Procedure calls</a></li>
<li><a href="#procedure_parameters">Procedure parameters</a></li>
</ul>
</li>

<li><b><a href="#locals">Local scopes</a></b>
<ul>
<li><a href="#obszar_lok">Declaring local scopes</a></li>
</ul>
</li>

</ul>

</td></tr>
</table>
</div>
<hr/>

<div id="introduction">
<h1>INTRODUCTION</h1>

<div id="preface">
<h2>Preface</h2>

Mad-Assembler (MADS) is a 32-bit application, written in Delphi.
Most applications are written in C, so to be different I used Delphi 7.0 ;).
<p>
MADS is oriented toward users of QA, XASM, and FA.
The syntax is borrowed from QA, some macro commands and syntax come from XASM,
and SpartaDOS X (SDX) syntax is inherited from FA. Additional characters are
allowed in label names. Also added are support for the 65816 CPU, macros, procedures,
splitting across virtual memory banks, and nested label names.
</p>
<p>
The number of labels and macros are limited only by the memory in your PC. Specifically,
you can have 2147483647 (INTEGER) table entries. I'm sure this amount is
sufficient. :)
</p>
<p>
Arithmetic operations are done with values of type INT64 (signed 64 bit), with the result
represented with a value of type CARDINAL (unsigned 32 bit).
</p>
<p>
A line can be up to 65535 bytes, which is also the length limit of a label name.
However, I have not had the opportunity to check labels as long as poems. :)
</p>
<p>
With the free compiler <b>Free Pascal Compiler</b>, it is possible to compile MADS
for other platforms, such as Linux, Mac, OS/2, etc. For more information on how to build,
see the chapter on <a href="#compilation">Compilation</a>. For more information on
XASM check its home page: <a href="http://atariarea.histeria.pl/x-asm">http://atariarea.krap.pl/x-asm/</a>.
</p>

</div>

<div id="compilation">
<h2>Compilation</h2>
<p>
To compile MADS source, you can use the Delphi compiler, if
Delphi 7.0 or later is installed. Another, more multi-platform way is to use the compiler package from the <b>Free Pascal
Compiler (FPC)</b>, which can be downloaded from: <a href="http://www.freepascal.org/">http://www.freepascal.org/</a>
</p>

Run the installer, and select the folder in which you installed FPC. It is important
not to use a directory name which contains '!' or other special characters, or
else you will not be able to compile any files, and it should probably not be a standard
path name. The command-line to start compilation could look like this (the case in the
parameter names is important):

<pre class="code">
fpc -Mdelphi -v mads.pas

    -Mdelphi    compile in Delphi mode
    -v          show all errors and warnings
    -O3         enable code optimization
</pre>

Compared to the Delphi compiler, FPC generates bigger code,
but the speed of the compiled MADS is much faster, even by a few seconds.
The included MADS.EXE is compiled using FPC.

</div>

<div id="differences_and_similarities">
<h2>DIFFERENCES AND SIMILARITIES BETWEEN MADS AND XASM</h2>

<h3 id="similarities">Similarities</h3>
<ul>
<li>the same syntax</li>
<li>the same exit codes</li>
<li>the same macro commands</li>
</ul>

<h3 id="differences">Differences and new behaviors</h3>
<ul>
<li>small additions to ORG, e.g. 'ORG [[expression]]address[,address2]'</li>
<li>XASM does not like whitespace, MADS tolerates and accepts it in logical/arithmetic expressions and static/variable definitions</li>
<li>MADS allows expressions to be grouped with (), [], XASM only within []</li>
<li>MADS provides static and variable definitions of local, global, and temporary scope, XASM only global</li>
<li>MADS does not accept ORG a:address or ORG f:address</li>
<li>MADS encodes real numbers using the directive <b>.FL</b> .FL real, XASM by pseudo-command <b>DTA R</b> DTA R(real)</li>
<li>MADS has expanded support in the pseudo-command INS</li>
<li>MADS does not accept the addressing form 'lda (203),0'</li>
<li>MADS allows writing programs for SpartaDOS X</li>
<li>MADS permits writing relocatable code in a custom format</li>
<li>when encoding the value of a character, i.e.
<pre>
  lda #' '
  lda #" "
</pre>
MADS distinguishes between single quotes (ATASCII coding) and double
quotes (INTERNAL coding), whereas XASM treats both forms the same (ATASCII coding).
Of course, the quote types are treated the same in DTA by MADS.
</li>
<li>in indexed modes, a '+' or '-' sign increments or decrements the index register, e.g.
<pre class="code">
  lda $2000,x+  -&gt; lda $2000,x
                   inx
</pre>
but if the '+' or '-' sign is used with a value, it change the value of the main operand instead
(this only works with absolute indexed addressing):
<pre class="code">
  lda $2000,x+2 -&gt; lda $2002,x
</pre>
</li>
</ul>

</div>

</div>
<div id="usage">
<h1>USAGE</h1>

<div id="switches">
<h2>Assembler switches</h2>

<pre class="code">
Syntax: mads source [switches]

-b:address      Generate binary file at specific address
-c              Label case sensitivity
-d:label=value  Define a label
-f              CPU command at first column
-hc[:filename]  Header file for CC65
-hm[:filename]  Header file for MADS
-i:path         Additional include directories
-l[:filename]   Generate listing
-m:filename     File with macro definition
-o:filename     Set object file name
-p              Print fully qualified file names in listing and error messages
-s              Silent mode
-t[:filename]   List label table
-x              Exclude unreferenced procedures
-vu             Verify code inside unreferenced procedures
-u              Warn of unused labels
</pre>


<p>
The default filenames are:
</p>

<pre class="code">
source.lst
source.obx
source.lab
source.h
source.hea
source.mac
</pre>

<p>
If no extension is specified for the <b>source</b> file, MADS will default to
the extension .ASM.
</p>

Switches can be given in any order, preceded by '/' or '-', and case does not matter.
Also, switches can be combined:

<pre class="code">
mads -lptd:label=value -d:label2=value source.asm
mads -l  -p  -t  source
mads source.asm  -lpt
mads.exe "%1" -ltpi:"d:\!atari\macro\"
mads -i:"c:\atari\macros\" -c source.asm  -lpt
</pre>

By default, after assembly MADS will save the output with the extension '.OBX',
which can be changed with a batch file:
<pre class="code">
mads "%1" -o:%~n1.xex
</pre>

You can learn more about the operators by entering "CALL /?" in the Microsoft Windows command shell.

<p>
<span class="switch">-b:address</span><br/>
Using the <b>-b</b> switch allows specification of a target address for a file that
does not specify an address itself via the the <a href="#_org">ORG</a> pseudo-command.
</p>


<p>
<span class="switch">-c</span><br/>
The <b>-c</b> switch causes label, variable, and constant names to be treated as
case-sensitive. Assembler directives and 6502/65816 CPU instructions are always recognized
regardless of case.
</p>

<p>
<span class="switch">-d:label=value</span><br/>
Use the <b>-d</b> switch to define a new label in MADS memory from
the command-line. This switch can be used multiple times in a single invocation of MADS,
which is useful when assembling from a batch (*.BAT) file.
</p>

<p>
<span class="switch">-f</span><br/>
Use the <b>-f</b> switch to allow CPU instructions to be recognized in the first column instead of
just labels.
</p>


<p>
<span class="switch">-hc[:filename]</span><br/>
The switch <b>-hc</b> saves a header file for the CC65 compiler.
It also lets you specify a new name for the file. The default extension for the CC65
header file is *.H.
</p>


<p>
<span class="switch">-hm[:filename]</span><br/>
The switch <b>-hm</b> saves a header file for MADS. It also lets you specify
a new name for the file. The default extension for the MADS is *.HEA.
Such a file contains information about the banks and values assigned to labels. Additionally,
the labels are grouped by their types: CONSTANTS, VARIABLES, PROCEDURES.
</p>

<span class="switch">-i:path</span><br/>
The <b>-i</b> switch is used to set the search path for ICL and INS.
This switch can be use multiple times in the same command-line to MADS
<pre class="code">
Example: mads -i:"D:\program files" -i:C:\temp -i:"D:\atari project" ...
</pre>

<p>
<span class="switch">-l:filename</span><br/>
The <b>-l</b> switch enables writing of a listing file. It also lets you specify a new name for the file.
</p>

<p>
<span class="switch">-m:filename</span><br/>
The <b>-m</b> switch specifies a file with macro definitions, which MADS
assembles before the main *.ASM file.
</p>

<p>
<span class="switch">-o:filename</span><br/>
The <b>-o</b> switch specifies a new name for the
Atari DOS or SpartaDOS X executable file, which is created at the end of assembly.
</p>

<span class="switch">-p</span><br/>
The <b>-p</b> switch is useful in conjunction with Code Genie and WUDSN IDE.
When an error occurs during assembly, MADS generated error messages will appear in the
Output Bar of Code Genie:
<pre class="code">
Example: D:\!Delphi\Masm\test.asm (29) ERROR: Missing .PROC
</pre>
Now just double-click the message line, and the cursor in the editor will move to the line with the error.
In WUDSN IDE, error messages are added automatically to the Problems view with the correct line number.

<p>
<span class="switch">-s</span><br/>
Use the <b>-s</b> switch to activate the so-called 'Silent mode', where no messages will be displayed,
only errors (ERROR) and warnings (WARNING).
</p>

<p>
<span class="switch">-t[:filename]</span><br/>
The <b>-t</b> switch writes a file with referenced label definitions. It also lets you specify an
alternate name for the file.
</p>

<p>
<span class="switch">-x</span><br/>
The <b>-x</b> switch skips assembly of unreferenced procedures defined with the <b>.PROC</b> directive.
</p>

<p>
<span class="switch">-vu</span><br/>
The <b>-vu</b> switch enables verification of code inside procedures even if they are not emitted, usually used in conjunction with <b>-x</b>.
</p>

<p>
<span class="switch">-u</span><br/>
The <b>-u</b> switch lists unreferenced labels in the program.
</p>

</div>

<div id="error_codes">
<h2>Exit codes</h2>
The following exit codes are returned by the executable. Warnings do not change the value of the exit code.

<pre class="code">
  0 = no errors
  2 = error occurred
  3 = bad parameters, assembling not started
</pre>
</div>

<div id="lst_file_format">
<h2>.LST file format</h2>

The listing format is the same as XASM, except that the virtual memory bank
is added before the address (if the bank is &lt;&gt;0). For more on virtual banks, see <a href="#memory_banks">Memory banks</a>.

<pre class="code">
  3
  4 = 01,9033        picture equ $9033
  5 = 01,00A0        scr1 equ $a0
  6
  7
  8 01,2000 EA       main nop
</pre>
</div>

<div id="lab_file_format">
<h2>.LAB file format</h2>
<p>
As with XASM, the *.LAB file stores information about labels in the program.
</p>
There are three columns:
<ul>
<li>The first column is the virtual bank number assigned to the label (if &lt;&gt;0).</li>
<li>The second column is the label value.</li>
<li>The third column is the label name.</li>
</ul>

Virtual bank numbers with values &gt;= $FFF9 have special meanings:
<pre>
 $FFF9   label for parameter in procedure defined by .PROC
 $FFFA   label for array defined by .ARRAY
 $FFFB   label for structured data defined by the pseudo-command DTA STRUCT_LABEL
 $FFFC   label for SpartaDOS X symbol defined by SMB
 $FFFD   label for macro defined by .MACRO directive
 $FFFE   label for structure defined by .STRUCT directive
 $FFFF   label for procedure defined by .PROC directive
</pre>

<p>
Characters with special meanings in label names:
</p>
<ul>
<li>label with two colons :: is defined in a macro</li>
<li>a dot ('.') separates the name of a scope (.MACRO, .PROC, .LOCAL, .STRUCT) from the field name in the scope</li>
</ul>

<p>
The numeric value after :: is the number of the macro call.
</p>

<pre class="code">
Mad-Assembler v1.4.2beta by TeBe/Madteam
Label table:
00	0400	@STACK_ADDRESS
00	00FF	@STACK_POINTER
00	2000	MAIN
00	2019	LOOP
00	201C	LOOP::1
00	201C	LHEX
00	0080	LHEX.HLP
00	204C	LHEX.THEX
00	205C	HEX
00	205C	HEX.@GETPAR0.LOOP
00	2079	HEX.@GETPAR1.LOOP
</pre>
</div>

<div id="h_file_format">
<h2>.H file format</h2>

I'm not sure if the file is OK, but Eru wanted something so here it is. :)
It is useful for linking together ASM and CC65, or C ported to the Atari.
Its contents can look like this (example file TEST.ASM):

<pre class="code">
#ifndef _TEST_ASM_H_
#define _TEST_ASM_H_

#define TEST_CPU65816 0x200F
#define TEST_CPU6502 0x2017
#define TEST_TEXT6502 0x201F
#define TEST_TEXT65816 0x2024

#endif
</pre>
</div>
</div>
<div id="macro_commands">
<h1>MACRO COMMANDS</h1>
The purpose of macro commands is to save time when writing programs and to shorten listings. Macro
commands replace commonly used groups of instructions.

<pre class="code">
 <a href="#_req">REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS</a>

 <a href="#_seq">SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS</a>

 <a href="#_jeq">JEQ, JNE, JPL, JMI, JCC, JCS, JVC, JVS</a>

 <a href="#_add">ADD, SUB</a>

 <a href="#_adb">ADB, SBB</a>

 <a href="#_adw">ADW, SBW</a>

 <a href="#_phr">PHR, PLR</a>

 <a href="#_inw">INW, INL, IND, DEW, DEL, DED</a>

 <a href="#_mv">MVA, MVX, MVY</a>

 <a href="#_mw">MWA, MWX, MWY</a>

 <a href="#_cp">CPB, CPW, CPL, CPD</a>
</pre>

<div id="_req">
<h3>REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS</h3>
These macro commands are similar to the 6502 branch instructions BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS,
but branch to the previously assembled instruction ("repeat").

<pre class="code">
  lda:cmp:req 20          -&gt;      lda 20
                          -&gt; wait cmp 20
                          -&gt;      beq wait
  ldx #0                  -&gt;      ldx #0 

  mva:rne $500,x $600,x+  -&gt; loop lda $500,x
                          -&gt;      sta $600,x
                          -&gt;      inx
                          -&gt;      bne loop
</pre> 
</div>

<div id="_seq">
<h3>SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS</h3>

These macro commands are similar to the 6502 branch instructions BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS, but
branch over the next assembled instruction ("skip").

<pre class="code">
  lda #40        -&gt;      lda #40
  add:sta  $80   -&gt;      clc
  scc:inc  $81   -&gt;      adc $80
                 -&gt;      sta $80
                 -&gt;      bcc skip
                 -&gt;      inc $81
                 -&gt; skip
</pre> 
</div>

<div id="_jeq">
<h3>JEQ, JNE, JPL, JMI, JCC, JCS, JVC, JVS</h3>

These macro commands are similar to the 6502 branch instructions BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS,
but can target the entire 64KB address space ("jump").
If the distance is short (in the range of [-128..+127] bytes), MADS uses a regular BEQ, BNE, BPL, BMI, BCC, BCS, BVC, or BVS branch instruction.

<pre class="code">
  jne dest  -&gt; beq *+4
            -&gt; jmp dest
</pre> 
</div>

<div id="_add">
<h3>ADD, SUB</h3>
These macro commands add or subtract from the accumulator without including the carry flag.

<pre class="code">
  add  -&gt; clc        sub  -&gt; sec
       -&gt; adc ...         -&gt; sbc ...
</pre>
</div>

<div id="_adb">
<h3>ADB, SBB</h3>

These macro commands add or subtract a value from a byte location in memory and store it either back
or to another location.

<pre class="code">
  adb src #$40 -&gt; lda src       adb a b c  -&gt; lda a
               -&gt; clc                      -&gt; clc
               -&gt; adc #$40                 -&gt; adc b
               -&gt; sta src                  -&gt; sta c

  sbb src #$80 -&gt; lda src       sbb a b c  -&gt; lda a
               -&gt; sec                      -&gt; sec
               -&gt; sbc #$80                 -&gt; sbc b
               -&gt; sta src                  -&gt; sta c
</pre>
</div>

<div id="_adw">
<h3>ADW, SBW</h3>
These macro commands add or subtract a value from a word location in memory and store it either back
or to another location.
<pre class="code">
  adw src #$40 -&gt; clc             adw a b c  -&gt; clc
               -&gt; lda src                    -&gt; lda a
               -&gt; adc #$40                   -&gt; adc b
               -&gt; sta src                    -&gt; sta c
               -&gt; scc                        -&gt; lda a+1
               -&gt; inc src+1                  -&gt; adc b+1
                                             -&gt; sta c+1

  adw src #$40 src -&gt; clc
                   -&gt; lda src
                   -&gt; adc #$40
                   -&gt; sta src
                   -&gt; lda src+1
                   -&gt; adc #$00
                   -&gt; sta src+1
                                             
  sbw src #$4080 -&gt; sec           sbw a b c  -&gt; sec
                 -&gt; lda src                  -&gt; lda a
                 -&gt; sbc &lt;$4080               -&gt; sbc b
                 -&gt; sta src                  -&gt; sta c
                 -&gt; lda src+1                -&gt; lda a+1
                 -&gt; sbc >$4080               -&gt; sbc b+1
                 -&gt; sta src+1                -&gt; sta c+1 
</pre>
</div>

<div id="_phr">
<h3>PHR, PLR</h3>
These macros are similar to the 6502 mnemonics PHA and PLA, but push or
pop the A, X, and Y registers to and from the stack.

<pre class="code">
  phr  -&gt; pha         plr  -&gt; pla
       -&gt; txa              -&gt; tay
       -&gt; pha              -&gt; pla
       -&gt; tya              -&gt; tax
       -&gt; pha              -&gt; pla
</pre>
</div>

<div id="_inw">
<h3>INW, INL, IND, DEW, DEL, DED</h3>
The macro commands <b>INW</b>, <b>INL</b>, and <b>IND</b> increment 16-bit (word), 24-bit (long), and 32-bit (dword) memory locations.
<p>
The macro commands <b>DEW</b>, <b>DEL</b>, and <b>DED</b> decrement 16-bit (word), 24-bit (long), and 32-bit (dword) memory locations.
The accumulator is also changed after the decrement macro commands.
</p>
<pre class="code">
  inw dest  -&gt;      inc dest    -&gt;  inc dest
            -&gt;      bne skip    -&gt;  sne
            -&gt;      inc dest+1  -&gt;  inc dest+1
            -&gt; skip             -&gt;

  dew dest  -&gt;      lda dest    -&gt;  lda dest
            -&gt;      bne skip    -&gt;  sne
            -&gt;      dec dest+1  -&gt;  dec dest+1
            -&gt; skip dec dest    -&gt;  dec dest   
</pre>
</div>

<div id="_mv">
<h3>MVA, MVX, MVY</h3>

The macro commands <b>MVA</b>, <b>MVX</b>, <b>MVY</b> transfer bytes using the A, X, or Y registers, respectively.
<b>OPT R+</b> can potentially reduce the code size from these macros by removing redundant instructions.
<pre class="code">
  lda src    -&gt; mva src dst
  sta dst    -&gt;

  ldy $10,x  -&gt; mvy $10,x $a0,x
  sty $a0,x  -&gt;

  ldx #$10   -&gt; mvx #$10 dst
  stx dst    -&gt;
</pre>
</div>

<div id="_mw">
<h3 >MWA, MWX, MWY</h3>
The macro commands <b>MWA</b>, <b>MWX</b>, <b>MWY</b> transfer words using the A, X, or Y registers, respectively.
<b>OPT R+</b> can potentially reduce the code size from these macros by removing redundant instructions.
<pre class="code">
  ldx &lt;adr    -&gt; mwx #adr dst
  stx dst     -&gt;
  ldx &gt;adr    -&gt;
  stx dst+1   -&gt;

  mwa #0 $80  -&gt; lda #0           mwy #$3040 $80  -&gt; ldy &lt;$3040
              -&gt; sta $80                          -&gt; sty $80
              -&gt; sta $81                          -&gt; ldy &gt;$3040
                                                  -&gt; sty $81

  mwa ($80),y $a000,x  -&gt; lda ($80),y
                       -&gt; sta $a000,x
                       -&gt; iny
                       -&gt; lda ($80),y
                       -&gt; sta $a001,x
</pre>
</div>

<div id="_cp">
<h3>CPB, CPW, CPL, CPD</h3>
The macro commands <b>CPB</b>, <b>CPW</b>, <b>CPL</b>, and <b>CPD</b> perform comparison of
byte, word (16-bit), long (24-bit), and dword (32-bit) values, respectively.
<pre class="code">
  cpw temp #$4080
  bcc skip

  cpd v0 v1
  beq skip
</pre>
</div>

</div>
<div id="pseudo_commands">
<h1>PSEUDO-COMMANDS</h1>
Pseudo-commands are not directly translated into code but control the assembly itself and the content of the output file.
 
<pre class="code">
  <a href="#_ift">IFT</a> [.IF] expression
  <a href="#_ift">ELS</a> [.ELSE]
  <a href="#_ift">ELI</a> [.ELSEIF] expression
  <a href="#_ift">EIF</a> [.ENDIF]
 
  <a href="#_error">ERT</a> ERT 'string'["string"] | ERT expression

  label EQU expression
  label  =  expression

  label <a href="#_set">SET</a> expression
 
  label <a href="#labels_ext">EXT</a> type

  <a href="#_opt">OPT</a> [bcfhlmorst][+-]
  <a href="#_org">ORG</a> [[expression]]address[,address2]
  <a href="#_ins">INS</a> 'filename'["filename"][*][+-value][,+-ofset[,length]]
  <a href="#_icl">ICL</a> 'filename'["filename"]
  <a href="#_dta">DTA</a> [abfghltv](value1,value2...)[(value1,value2...)]
  <a href="#_dta">DTA</a> [cd]'string'["string"]
  RUN expression
  INI expression
  <a href="#_en">END</a> [.EN]

  <a href="#_sin">SIN</a> (centre,amp,size[,first,last])
  <a href="#_rnd">RND</a> (min,max,length)

  <a href="#_repeat">:repeat</a>

  <a href="#_blk">BLK</a> N[one] X
  <a href="#_blk">BLK</a> D[os] X
  <a href="#_blk">BLK</a> S[parta] X
  <a href="#_blk">BLK</a> R[eloc] M[ain]|E[xtended]
  <a href="#_blk">BLK</a> E[mpty] X M[ain]|E[xtended]
  <a href="#_blk">BLK</a> U[pdate] S[ymbols]
  <a href="#_blk">BLK</a> U[pdate] E[xternal]
  <a href="#_blk">BLK</a> U[pdate] A[dress]
  <a href="#_blk">BLK</a> U[pdate] N[ew] X 'string'

 label  <a href="#_smb">SMB</a> 'string'

  <a href="#_nmb">NMB</a>
  <a href="#_rmb">RMB</a>
  <a href="#_lmb">LMB</a> #expression
</pre>

These are mostly the same as in XASM, although there are some differences with quoted strings.
Both '' and "" are treated the same except in operands, where
'' gives the ATASCII code of a character, and "" gives the INTERNAL code.

<div id="_blk">
<h3>BLK</h3>
The pseudo-command <b>BLK</b> defines and updates SpartaDOS X blocks which allow for relocatable code.
<pre>
  BLK N[one] X                    - set program counter to X without adding a header block

  BLK D[os] X                     - DOS block with header $FFFF or without header when
                                    the program counter is already set to X

  BLK S[parta] X                  - fixed address block with header $FFFA, set program counter to X

  BLK R[eloc] M[ain]|E[xtended]   - relocatable block in MAIN or EXTENDED memory

  BLK E[mpty] X M[ain]|E[xtended] - relocatable block reserving MAIN or EXTENDED memory
                                    <b>Note:</b> The program counter is immediately raised by X bytes

  BLK U[pdate] S[ymbols]          - update block for updating previous SPARTA or RELOC blocks with the
                                    addresses of SDX symbols

  BLK U[pdate] E[xternal]         - update block for updating addresses of external labels ($FFEE header)
                                    <b>Note:</b> Does not apply to SpartaDOS X, as this is a MADS extension

  BLK U[pdate] A[dress]           - update block for addresses in RELOC blocks

  BLK U[pdate] N[ew] X 'string'   - block declaring a new symbol 'string' in a RELOC block
                                    with address X. If the symbol name is prefixed with @,
                                    the address is in main memory and can be invoked by
                                    command.com
</pre>
For more information on SpartaDOS X blocks, see <a href="#dos_file_fomats">SpartaDOS X and Atari DOS file formats</a> and <a href="#programming_spartados_x">Programming SpartaDOS X</a>.
</div>

<div id="_set">
<h3>label SET expression</h3>

The pseudo-command <b>SET</b> redefines a label, with similar effect as temporary labels that
begin with '?'.

<pre class="code">
Example: redfine label temp

temp set 12
     lda #temp

temp set 23
     lda #temp
</pre>
</div>

<div id="_smb">
<h3>label SMB 'string'</h3>

The pseudo-command <b>SMB</b> declares a label as a SDX symbol. The symbol name can have a maximum of 8 characters.
The pseudo-command <b>BLK UPDATE SYMBOLS</b> will instruct the assembler then to generate the correct update block
for symbols. 
<pre class="code">
Example: declare and use SDX symbol

  pf  smb 'PRINTF'
      jsr pf
      ...
</pre>
This example code will instruct the SDX system to insert the correct address into the JSR instruction.<br/>
<b>Note:</b> This statement is not transitive, so the following example will cause errors at compile time:
<pre class="code">
  cm  smb 'COMTAB'
  wp  equ cm-1     -&gt; ERROR!
      sta wp
</pre>

Use this instead:
<pre class="code">
  cm  smb 'COMTAB'
      sta cm-1     -&gt; OK
</pre>
<p>
<b>Note:</b> Use labels for all symbols and declare before usage for correct operation!
</p>
</div>

<div id="_repeat">
<h3>:repeat</h3>
The ':' operator specifies the number of times to repeat the line. 
The repeat count should be in the range [0..2147483647].
When repeating a line with ':repeat', it is possible to use the loop counter in the repeated
line using a hash sign ('<b>#</b>') or the parameter :1.
<pre class="code">
Example: repeat code

       :4   asl @
       :2   dta a(*)
       :256 dta #/8

  ladr :4   dta l(line:1)
  hadr :4   dta h(line:1)           
</pre>
Within macros, the ':' specifies a macro parameter by number if it is in decimal.
When attempting to use the character ':' to repeat lines in a macro:
<pre class="code">
  .macro test
    :2 lsr @
  .endm
</pre>
The ':' prefixed number in this case is interpreted as the <b>second macro parameter</b>.
To prevent this interpretation by MADS, add something after the ':'
that does nothing, such as the plus sign ('+').

<pre class="code">
  .macro test
    :+2 lsr @
  .endm
</pre>

<p>
Now, the ':' is correctly interpreted as <b>:repeat</b>.
</p>
</div>

<div id="_opt">
<h3 >OPT</h3>
The <b>OPT</b> pseudo-command allows options to be enabled or disabled during
assembly.
<pre>
  b+  enable bank sensitivity
  b-  disable bank sensitivity                                  (default)
  c+  use 65816 instruction set (16bit)
  c-  use 6502 instruction set (8bit)                           (default)
  f+  emit file as a single block (useful for cartridges)
  f-  emit file as multiple blocks                              (default)
  h+  write DOS executable file headers                         (default)
  h-  omit DOS executable file headers
  l+  enable writing to listing file (*.LST)
  l-  disable writing to listing file (*.LST)                   (default)
  m+  expand macros in listing
  m-  include only macro invocation in listing                  (default)
  o+  enable writing to object file (*.OBX)                     (default)
  o-  disable writing to object file (*.OBX)
  r+  enable optimization for <b>MVA</b>, <b>MVX</b>, <b>MVY</b>, <b>MWA</b>, <b>MWX</b>, <b>MWY</b>
  r-  disable optimization for <b>MVA</b>, <b>MVX</b>, <b>MVY</b>, <b>MWA</b>, <b>MWX</b>, <b>MWY</b>     (default)
  s+  print listing to screen
  s-  do not print listing to screen                            (default)
  t+  enable SEP/REP tracking (65816 CPU)
  t-  disable SEP/REP tracking (65816 CPU)                      (default)
  ?+  labels beginning with '?' are local (MAE style)
  ?-  labels beginning with '?' are temporary                   (default)
</pre>
<pre class="code">
Example:
 
  opt c+ c  - l  + s +	;Sequence is important, so result is c-
  opt o +               ;Spaces are ignored
  opt h-;
</pre>

<p>
All options controlled by <b>OPT</b> can be used anywhere in the listing, e.g. if it is
turned on at line 12 and off at line 20 then the listing will only contain lines 12 through 20.
</p>
<b>OPT c+</b> is required to use 65816 addressing modes.
<p>
If you use CodeGenie and <b>'OPT s+'</b>, the listing file is unnecessary as the listing is
printed in the lower pane (Output Bar).
</p>
</div>

<div id="_org">
<h3>ORG [[header]][,adr][,loadadr]</h3>
The <b>ORG</b> pseudo-command sets the new assembly address and therefore the new position
for data in RAM. Different types and standard and user defined headers can be created in
the output file, so the DOS can load the data to the correct position.
<pre>
  adr                    - assembles to ADR, setting the address in the header to ADR
  adr,loadadr            - assembles to ADR, setting the address in the header to LOADADR
  [b($ff,$fe)]           - writes $FFFE header (will generate 2 bytes)
  [$ff,$fe],adr          - writes $FFFE header, setting the address in the header to ADR
  [$d0,$fe],adr,loadadr  - writes $D0FE header, assemble at address ADR, set the address in the header to LOADADR
  [a($FFFA)],adr         - writes SpartaDOS $FAFF header, set address in the header to ADR
</pre>
<pre class="code">
Example: disable standard header and generate own header

 opt h- 
 org [a($ffff),d'atari',c'ble',20,30,40],adr,loadadr
</pre>

Brackets <b>[ ]</b> are used to write a new header, which can be any length. Other
values following closing ']', separated by a comma, are the assembly address and the
address in the header.
<p>
Here is an example of a file with a single header, assembled at address $2000, with valid
block start and end addresses in the header.
</p>

<pre class="code">
Example: gerenate DOS header

  opt h-f+
  org [a(start), a(over-1)],$2000

start
   nop
   .ds 128
   nop
over
</pre>
</div>

<div id="_ins">
<h3>INS 'filename'["filename"][*][+-value][,+-ofset[,length]]</h3>
<p>
The <b>INS</b> pseudo-command allows inclusion of an external binary file. The included
file does not have to be in the same directory as the main file being assembled. Search paths for
the file can be configured using the <b>-i</b> switch (see <a href="#switches">Assembler switches</a>).
</p>

Additionally, you can perform the following operations on the binary data:
<pre>
  *          invert bytes
  +-VALUE    increase or decrease each byte by the value of the expression VALUE

  +OFSET     skip OFSET bytes at the beginning of the file     (seek to OFSET)
  -OFSET     read OFSET bytes at the end of the file           (seek to FILE_LENGTH-OFSET)

  LENGTH     read LENGTH bytes from the file
</pre>

If the LENGTH value is not specified, the default behavior is to read to the end.
</div>

<div id="_icl">
<h3>ICL 'filename'["filename"]</h3>
The pseudo-command <b>ICL</b> includes an additional source file in the assembly process.
The attached file does not have to be in the same directory as the main assembly file. Additional
paths are added to the MADS search path using the <b>-i</b> switch (see <a href="#switches">Assembler switches</a>).
</div>

<div id="_dta">
<h3>DTA</h3>
The pseudo-command <b>DTA</b> defines typed data. If the type is not specified, byte data (b) is assumed.
The following types are supported:
<pre>
  b   byte data (8-bit)
  a   word data (16-bit)
  v   relocatable WORD data (16-bit)
  l   byte data (8-bit)
  h   byte data (8-bit)
  t   long data (24-bit)
  e   long data (24-bit)
  f   double word data (32-bit)
  g   double word data (32-bit) in reversed byte order (big-endian)
  c   ATASCII string, delimited by '' or ""
      Using a star (<b>*</b>) at the end encodes inverse video, e.g. dta c'abecadlo'*
  d   INTERNAL string, delimited by '' or "";
      Using a star (<b>*</b>) at the end encodes inverse video, e.g. dta d'abecadlo'*
</pre>
<pre class="code">
Example:

  dta 1 , 2, 4
  dta a ($2320 ,$4444)
  dta d'sasasa', 4,a ( 200 ), h($4000)
  dta c 'file', $9b
  dta c'invers'*
</pre>
</div>

<div id="_sin">
<h3>SIN(center,amp,size[,first,last])</h3>
Generates a sine table when used with the DTA  pseudo-command. CENTER is a number which is added to every sine value.
AMP is the sine amplitude and SIZE  is the sine period.
The optional arguments FIRST and LAST define range for which the sine values are generated.
The default values are FIRST=0 and LAST=size-1. The following example defines table of 64 words representing a quarter of a sine with amplitude of 1000.
<pre class="code">
Example: generate sine table

  dta a(sin(0,1000,256,0,63))    
</pre>
</div>

<div id="_rnd">
<h3>RND(min,max,length)</h3>
This pseudo-command generates LENGTH pseudorandom values in the range [MIN..MAX].
<pre class="code">
Example: genenate random value

  dta b(rnd(0,33,256))
</pre>
</div>

<div id="_ift">
<h3>IFT, ELS, ELI, EIF</h3>
These pseudo-commands and directives conditionally include lines based on the value of an expression.

<pre class="code">
 ift [.if] expression
 els [.else]
 eli [.elseif] expression
 eif [.endif]
</pre>
</div>
</div>

<div id="directives">
<h1>DIRECTIVES</h1>

<pre class="code">
  <a href="#_align">.ALIGN</a> n[,fill]
 
  <a href="#arrays">.ARRAY</a> label index type [= default_value]
  <a href="#arrays">.ENDA, [.AEND]</a>

  <a href="#_def">.DEF</a> label [= expression]

  <a href="#enums">.ENUM</a> label
  <a href="#enums">.ENDE, [.EEND]</a>

  <a href="#_error">.ERROR</a> [ERT] 'string'["string"] or .ERROR [ERT] expression

  <a href="#labels_ext">.EXTRN</a> label [,label2,...] type

  <a href="#conditions">.IF</a> [IFT] expression
  <a href="#conditions">.ELSE</a> [ELS]
  <a href="#conditions">.ELSEIF</a> [ELI] expression
  <a href="#conditions">.ENDIF</a> [EIF]

  <a href="#_ifdef">.IFDEF</a> label
  <a href="#_ifndef">.IFNDEF</a> label

  <a href="#locals">.LOCAL</a> label
  <a href="#locals">.ENDL, [.LEND]</a>

  <a href="#linling">.LINK</a> 'filename'
 
  <a href="#macros">.MACRO</a> label
  <a href="#macros">.ENDM, [.MEND]</a>
  <a href="#macros">:[%%]parameter</a>
  <a href="#macros">.EXITM</a> [.EXIT]

  <a href="#_nowarn">.NOWARN</a>

  <a href="#_print">.PRINT</a> [.ECHO] 'string1','string2'...,value1,value2,...

  <a href="#_pages">.PAGES</a> [expression]
  <a href="#_pages">.ENDPG, [.PGEND]</a> 

  <a href="#labels_pub">.PUBLIC, [.GLOBAL], [.GLOBL]</a> label [,label2,...]

  <a href="#procedures">.PROC</a> label
  <a href="#procedures">.ENDP, [.PEND]</a>
  <a href="#procedures">.REG, .VAR</a>

  <a href="#_rept">.REPT</a> expression [,parameter1, parameter2, ...]
  <a href="#_rept">.ENDR, [.REND]</a>
  <a href="#_rept">.R</a>

  <a href="#relocatable_blocks">.RELOC</a> [.BYTE|.WORD]

  <a href="#structures">.STRUCT</a> label
  <a href="#structures">.ENDS, [.SEND]</a>

  <a href="#_symbol">.SYMBOL</a> label
 
  <a href="#_segment">.SEGDEF</a> label address length [bank]
  <a href="#_segment">.SEGMENT</a> label
  <a href="#_segment">.ENDSEG</a>
 
  <a href="#_using">.USING, [.USE]</a> proc_name, local_name

  <a href="#_var">.VAR</a> var1[=value],var2[=value]... (.BYTE|.WORD|.LONG|.DWORD)
  <a href="#_zpvar">.ZPVAR</a> var1, var2... (.BYTE|.WORD|.LONG|.DWORD)

  <a href="#_end">.END</a>

  <a href="#_en">.EN</a>

  <a href="#_byte">.BYTE</a>
  <a href="#_byte">.WORD</a>
  <a href="#_byte">.LONG</a>
  <a href="#_byte">.DWORD</a>

  <a href="#_or">.OR</a>
  <a href="#_or">.AND</a>
  <a href="#_or">.XOR</a>
  <a href="#_or">.NOT</a>

  <a href="#_lohi">.LO</a> (expression)
  <a href="#_lohi">.HI</a> (expression)

  <a href="#_db">.DB</a>
  <a href="#_dw">.DW</a>
  <a href="#_ds">.DS</a> expression

  <a href="#_by">.BY</a> [+byte] bytes and/or ASCII
  <a href="#_wo">.WO</a> words
  <a href="#_he">.HE</a> hex bytes
  <a href="#_sb">.SB</a> [+byte] bytes and/or ASCII
  <a href="#_cb">.CB</a> [+byte] bytes and/or ASCII
  <a href="#_fl">.FL</a> floating point numbers

  <a href="#_adr">.ADR</a> label
  <a href="#_len">.LEN</a> label

  <a href="#_get">.GET</a> [index] 'filename'["filename"][*][+-value][,+-offset[,length]]
  <a href="#_put">.PUT</a> [index] = value
  <a href="#_sav">.SAV</a> [index] ['filename',] length
</pre>


<div id="_symbol">
<h3>.SYMBOL label</h3>
The directive <b>.SYMBOL</b> is equivalent to the pseudo-command <b>SMB</b> except that the symbol name does
not need to be specified, as it is implied to be LABEL.
A <b>.SYMBOL</b> directive can be placed anywhere within a relocatable SDX block defined by <b>BLK RELOC</b>, unlike  <b>SMB</b>.
<p>
Whenever there is a  <b>.SYMBOL</b> directive, the following block update will be generated:
</p>
<pre class="code">
  BLK UPDATE NEW LABEL 'LABEL'
</pre>
More on the declaration of SDX symbols is found in the section for the <a href="#_smb">Pseudo-command SMB</a>.
</div>

<div id="_align">
<h3>.ALIGN n [,fill]</h3>
The directive  <b>.ALIGN</b> aligns the assembly address to the value N, using FILL as the memory preset value for
any needed fill. It is possible to align relocatable code provided that the FILL value is given.
The default values are N=$0100 and FILL=0.

<pre class="code">
Example:

 .align
 .align $400
 .align $100,$ff
</pre>
</div>

<div id="_rept">
<h3>.REPT expression [,parameter1, parameter2, ...]</h3>
The directive <b>REPT</b> is the same as the <a href="#_repeat"><b>:repeat</b></a> operator,
except that a block is repeated instead of a single line. The beginning of the block is defined 
with the <b>.REPT</b> directive, which is followed by a repeat count in the range
<b>[0..2147483647]</b> and then optional parameters. Unlike macro parameters, the
parameters to <b>.REPT</b> are always calculated first and the result is substituted immediately (this
feature can be used to define new labels). The parameters specified in the .<b>REPT</b> block are used
like parameters to a <b>.MACRO</b> block. A <b>.REPT</b> block is ended using the <b>.ENDR</b> directive,
before which there should be no label.

<p>
Additionally, within a <b>.REPT</b>...<b>.ENDR</b> block, the hash sign '<b>#</b>' (or directive <b>.R</b>)
gives the current value of the loop counter (like for <b>:repeat</b>).
</p>
<pre class="code">
Example:

  .rept 12, #*2, #*3        ; A .REPT block can be combined with :rept
  :+4 dta :1                ; :+4 to distinguish from repeat block parameter :4
  :+4 dta :2
  .endr

  .rept 9, #                ; Define 9 labels label0..label8
label:1 mva #0 $d012+#
  .endr
</pre>

<div id="_pages">
<h3 >.PAGES [expression]</h3>
The directive <b>.PAGES</b> specifies that a piece of code delimited by a <b>.PAGES .. .ENDPG</b> block
should fit within a number of memory pages (the default is 1). If the program code exceeds the given
number of memory pages, the error message <b>Page error at $xxxx</b> is generated.
<p>
These directives can help if you want part of the program to be within one memory page, or if
you write a program stored in an additional memory bank (64 pages of memory), such as:</p>
<pre class="code">
Example:

  org $4000
 
  .pages $40
   ...
  .endpg
</pre>
</div>

</div>

<div id="_segment">
<h3>.SEGDEF label address length [attribute] [bank]<br/>
.SEGMENT label<br/>
.ENDSEG
</h3>
The directive <b>.SEGDEF</b> defines a new segment LABEL at address ADDRESS and with length LENGTH. Read/write attributes
(<b>R</b>-read, <b>W</b>-write, <b>RW</b>-read/write) can be assigned to the segment, as well as a virtual bank number BANK (default=0).
<p>
The <b>.SEGMENT</b> directive begins writing of code and data to the code segment LABEL. Exceeding the preset length of the
segment generates the error message <b>Segment LABEL error at $xxxx</b> where XXXX is the offset in the segment.
</p>
<p>
The directive <b>.ENDSEG</b> ends writing to the current segment and returns to the main program block.
</p>

<pre class="code">
Example:

      .segdef sdata adr0 $100
      .segdef test  adr1 $40

      org $2000

      nop
      .cb 'ALA'

      .segment sdata
      nop
      .endseg

      lda #0

      .segment test
      ldx #0
      clc
      dta c'ATARI'
      .endseg

adr0  .ds $100
adr1  .ds $40 
</pre>
</div>

<div id="_end">
<h3>.END</h3>
The directive <b>.END</b> can be used interchangeably with the directives <b>.ENDP</b>, <b>.ENDM</b>, <b>.ENDS</b>, <b>.ENDA</b>, <b>.ENDL</b>, <b>.ENDR</b>, <b>.ENDPG</b>, <b>.ENDW</b>,
and <b>.ENDT</b>.
</div>

<div id="_var">
<h3>.VAR var1[=value1],var2[=value2]... (.BYTE|.WORD|.LONG|.DWORD) [=address]</h3>

The directive <b>.VAR</b> is used to declare and initialize variables in the main program
block and in <b>.PROC</b> and <b>.LOCAL</b> blocks. MADS does not use the information in these variables in further
operations involving pseudo and macro commands. Acceptable types of variables are <b>.BYTE</b>, <b>.WORD</b>, <b>.LONG</b>,
and <b>.DWORD</b>, multiples of those types, and types declared by <b>.STRUCT</b> and <b>.ENUM</b>.

<pre class="code">
Example:

  .var a,b , c,d   .word          ; 4 variables of type <b>.WORD</b>
  .var a,b,f  :256 .byte          ; 3 variables each with a size of 256 bytes
  .var c=5,d=2,f=$123344 .dword   ; 3 .DWORD variables with values 5, 2, and $123344

  .var .byte i=1, j=3             ; 2 variables of type <b>.BYTE</b> with values 1, 3

  .var a,b,c,d .byte = $a000      ; 4 variables of type <b>.BYTE</b> with addresses $A000, $A001, $A002, $A003
 
  .var .byte a,b,c,d = $a0        ; 4 variables of type <b>.BYTE</b>, with the last variable 'D' having address $A0
                                  ; Note: In this form it is not possible to determine the address of variables

  .proc name
  .var .word p1,p2,p3             ; Declare three variable of type <b>.WORD</b>
  .endp

  .local
      .var a,b,c .byte
      lda a
      ldx b
      ldy c
  .endl

  .struct Point                   ; New structure of type Point
      x .byte
      y .byte
  .ends

  .var a,b Point                  ; Declare structured variables
  .var Point c,d                  ; Equivalent to 'label DTA Point'
</pre>

Declared variables are physically allocated at the end of the block, as determined by the directives
<b>.ENDP</b>, <b>.ENDL</b>, or <b>.END</b>. The exception is that in a <b>.PROC</b> block, variables declared with <b>.VAR</b> are
always allocated in front of the <b>.ENDP</b> directive even if the <b>.VAR</b> statements are within nested
<b>.LOCAL</b> blocks.
</div>

<div id="_zpvar">
<h3>.ZPVAR var1, var2... (.BYTE|.WORD|.LONG|.DWORD) [=address]</h3>
The directive <b>.ZPVAR</b> is used to declare zero page variables in the main
program block and in <b>.PROC</b> and <b>.LOCAL</b> blocks. Attempting to assign to or initialize a variable
of this type will generate the warning message <b>Uninitialized variable</b>.
MADS does not use the information in these variables in further operations involving
pseudo and macro commands. Acceptable variable types are <b>.BYTE</b>, <b>.WORD</b>, <b>.LONG</b>, <b>.DWORD</b>,
multiples of those types, and types declared by <b>.STRUCT</b> and <b>.ENUM</b>:

<pre class="code">
Example:

  .zpvar a b c d  .word = $80     ; 4 variables of type <b>.WORD</b> starting at address $0080
  .zpvar i j .byte                ; two more byte variables starting at address $0080+8

  .zpvar .word a,b                ; 2 variables of type <b>.WORD</b>
                                  ; Note: In this form it is not possible to determine the address of variables

  .struct Point                   ; Declare new structure Point
      x .byte
      y .byte
  .ends

  .zpvar a,b Point                ; Declare structured variables
  .zpvar Point c,d                ; Equivalent to 'label DTA Point'                                
</pre>

The zero page variable will be assigned addresses only at the end of the block in which it was declared, at
<b>.ENDP</b>, <b>.ENDL</b>, or <b>.END</b>. The exception is a <b>.PROC</b> block where variables declared with <b>.ZPVAR</b> are assigned
at the <b>.ENDP</b> directive even if variables are declared within nested <b>.LOCAL</b> blocks.

<p>
Using <b>.ZPVAR</b> with only an address will specify the first address to assign to the next variable. The
default address is $0080.
</p>
<pre class="code">
Example:

 .zpvar = $40                       
</pre>

The address is automatically incremented by MADS and the warning message <b>Access violations at address $xxxx</b>
is generated if addresses are repeated. In the case of a zero page overflow, the error message <b>Value out of range</b> is generated.
</div>

<div id="_print">
<h3>.PRINT [.ECHO]</h3>
Prints on screen parameter values or string expressions delimited by <b>''</b> or <b>""</b> quotes:

<pre class="code">
Example:

  .print "End: ",*,'..',$8000-*
  .echo  "End: ",*,'..',$8000-*
</pre>

<p class="editors-note">
(Editor's note: Values are printed out as hexadecimal with a $ prefix.)
</p>
</div>

<div id="_error">
<h3>.ERROR [ERT] 'string'["string"] | .ERROR [ERT] expression</h3>

The directive <b>.ERROR</b> and the pseudo-command <b>ERT</b> are equivalent and
stop assembly, displaying a message given as a parameter delimited by <b>''</b> or <b>""</b>.
If the parameter is a boolean expression, then assembly will stop and generate the error message <b>User error</b> if EXPRESSION is true.

<pre class="code">
Example:

  ert    "halt"         ; ERROR: halt
  .error "halt"

  ert    *>$7fff        ; ERROR: User error
  .error *>$7fff
</pre>
</div>

<div id="_byte">
<h3>.BYTE, .WORD, .LONG, .DWORD</h3>

These directives are used to determine the allowable types for parameters in a procedure
declaration. They can also be used instead of the pseudo-command <b>DTA</b> for data definition.

<pre class="code">
Example:

  .proc test (.word tmp,a,b .byte value)

  .byte "atari",5,22
  .word 12,$FFFF
  .long $34518F
  .dword $11223344
</pre>
</div>

<div id="_db">
<h3>.DB</h3>
This directive defines data of type <b>BYTE</b>. It is equivalent to the pseudo-command <b>DTA B</b> or the <b>.BYTE</b> directive.
</div>

<div id="_dw">
<h3>.DW</h3>
This directive defines data of type <b>WORD</b>. It equivalent to the pseudo-command <b>DTA A</b> or the <b>.WORD</b> directive.
</div>

<div id="_ds">
<h3 >.DS expression</h3>
This directive has been adapted from MAC'65 and reserves uninitialized memory. This
is equivalent to the pseudo-command <b>ORG *+expression</b>. The .DS directive cannot
be used in relocatable code like ORG can.

<pre class="code">
Example:

  bufferlen .ds 1    ; Reserves a single byte
  buffer    .ds 256  ; Reserves 256 bytes
</pre>
</div>

<div id="_by">
<h3>.BY [+byte] bytes and/or ASCII</h3>

This directive stores byte values in memory. ASCII strings can be specified by enclosing the string in either single or double quotes.
If the first character of the operand field is a '<b>+</b>', then the following byte will be used as a constant and added to all remaining bytes of the instruction.

<pre class="code">
Example:

  .by +$80 1 10 $10 'Hello' $9B	; Generates 81 8A 90 C8 E5 EC EC EF 1B
</pre>

Values in <b>.BY</b> statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.
</div>

<div id="_wo">
<h3>.WO words</h3>
This directive stores words in memory. Multiple words can be entered. Values in <b>.WO</b> statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.
</div>

<div id="_he">
<h3>.HE hex bytes</h3>
This directive stores hex bytes in memory. This is a convenient method to enter strings of hex bytes, since it does not require using the '$' character. The bytes are separated by spaces, which I feel makes a much more readable layout than the 'all run together' form of hex statement that some other assemblers use.
<pre class="code">
Example:

  .HE 0 55 AA FF
</pre>
Values in .HE statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.
</div>

<div id="_sb">
<h3>.SB [+byte] bytes and/or ASCII</h3>
This directive is the same as the <b>.BY</b> pseudo-command, except that it will convert all bytes into ATASCII screen codes before storing them.
The ATASCII conversion is done before any constant is added with the '+' modifier.
<p>
Values in <b>.SB</b> statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.
</p>
</div>

<div id="_cb">
<h3>.CB [+byte] bytes and/or ASCII</h3>
This directive is the same as the <b>.BY</b> pseudo-command, except that the last character on the line will be EOR'ed with $80.
<p>
Values in <b>.CB</b> statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.
</p>
</div>

<div id="_fl">
<h3>.FL floating point numbers</h3>
This directive stores 6-byte BCD floating point numbers for use with the OS floating point ROM routines.
<p>Values in <b>.FL</b> statements may also be separated with commas for compatibility with other assemblers.
Spaces are allowed since they are easier to type.</p>
</div>

<div id="_en">
<h3>.EN</h3>
The directive <b>.EN</b> is equivalent to the pseudo-command <b>END</b> and ends the assembly.
<p>
This is an optional pseudo-command to mark the end of assembly. It can be placed before
the end of your source file to prevent the remaining portion of it from being assembled.
</p>
</div>

<div id="_adr">
<h3>.ADR label</h3>
The directive <b>.ADR</b> returns the address of LABEL before the assembly address is changed.
You can put LABEL between parentheses or square brackets. 
<pre class="code">
Example:

  org $2000

  .proc tb,$1000
  tmp lda #0
  .endp

  lda .adr tb.tmp   ; = $2000
  lda tb.tmp        ; = $1000
</pre>
</div>

<div id="_len">
<h3>.LEN label</h3>
The directive <b>.LEN</b> returns the length in bytes of a block declared with <b>.PROC</b>, <b>.ARRAY</b>, <b>.LOCAL</b>,
or <b>.STRUCT</b>. The LABEL is the name of the <b>.PROC</b>, <b>.ARRAY</b>, <b>.LOCAL</b>, or <b>.STRUCT</b> block.
It is possible to put the name LABEL between parentheses or square brackets.

<pre class="code"> <!-- TODO verify/compile -->
Example:

label
  .array [255] .dword
  .enda

  dta a(.len label) ; = $400

  .proc wait
  lda:cmp:req 20
  rts
  .endp

  dta .len wait     ; = 7
</pre>
</div>

<div id="_def">
<h3>.DEF label [= expression]</h3>
The directive <b>.DEF</b> is used as unary operator to check for the presence of the LABEL definition or to define it.
If the label is defined it returns <b>1</b> or <b>TRUE</b>, otherwise it returns <b>0</b> or <b>FALSE</b>.
It is possible to put the name LABEL between parentheses or square brackets.

<pre class="code">
Example:

  ift .not(.def label)
   .def label
  eif
</pre>

<b>Note</b>: Defining a label <b>after</b> the use of a <b>.DEF</b> which references it can be dangerous,
particularly if the <b>.DEF</b> is used in an <b>.IF</b> directive.
</div>

<div id="_ifdef">
<h3>.IFDEF label</h3>
The directive <b>.IFDEF</b> is equivalent to <b>.IF .DEF LABEL</b>.
<pre class="code">
Example:

  .ifdef label
      jsr proc1
  .else
      jsr proc2
  .endif
</pre>
</div>

<div id="_ifndef">
<h3>.IFNDEF label</h3>
The directive <b>.IFNDEF</b> is equivalent to <b>.IF .NOT .DEF LABEL</b>.

<pre class="code">
Example:

  .ifndef label
      clc
  .else
      sec
  .endif
</pre>

In the following example, the <b>.IFNDEF</b> (<b>.IF</b>) block will be processed and the label defined
only when the block is first encountered. If there are any errors associated with their definition,
this will only be reported when a reference to one of them is attempted, resulting in the
error message <b>Undeclared label LABEL</b>.

<pre class="code">
Example:

 .ifndef label
     .def label
     lda #0           ; This will only be generated once and not be reassembled
     temp = 100       ; Label TEMP is defined only once during assembly
 .endif
</pre>
</div>

<div id="_nowarn">
<h3>.NOWARN</h3>
The directive <b>.NOWARN</b> disables warning messages for the current line being assembled.

<pre class="code">
Example:

  .nowarn .proc temp  ; Warning message <b>Unreferenced procedure TEMP</b> not generated
          .endp
</pre>
</div>

<div id="_using">
<h3>.USING, [.USE] label</h3>
The directive <b>.USING</b> (<b>.USE</b>) allows an additional scope to be specified for label lookup.
<b>.USING</b> (<b>.USE</b>) is valid in the current namespace.

<pre class="code">
Example:

    .local move
tmp  lda #0
hlp  sta $a000

     .local move2
tmp2 ldx #0
hlp2 stx $b000
     .endl

     .endl

    .local main
    .use move.move2
    lda tmp2        ; Will be move.move2.tmp2
    .use move
    lda tmp         ; Will be move.tmp
    .endl
</pre>
</div>

<div id="_get">
<h3>.GET [index] 'filename'... [.BYTE, .WORD, .LONG, .DWORD]</h3>
This directive equivalent to the pseudo-command <b>INS</b> (similar syntax), except
that the file is loaded into the MADS memory instead of beining included in the assembly.
This directive allows the specified file to be loaded into memory and for its bytes
to be referred to as a one-dimensional array.
<p>
The INDEX must be in the range [0..65535]. The values read by <b>.GET</b> are of type <b>.BYTE</b>.
</p>

<pre class="code">
Example:

  .get 'file'                     ; Load the file into a MADS array
  .get [5] 'file'                 ; Load the file into an array starting at index 5

  .get 'file',0,3                 ; Load the file into an array of size 3

  lda #.get[7]                    ; Load the value of element 7 of the file array
  address = .get[2]+.get[3]&lt;&lt;8    ; Use bytes 2 and 3 of the file array as an address
</pre>

With the help of the directives <b>.GET</b> and <b>.PUT</b> you can transform binary files
during the assmbley. For example sound modules can be relocated using macros and these directives.
See MADS macro in the file "../EXAMPLES/MSX/TMC_PLAYER_RELOCATOR/TMC_RELOCATOR.MAC" for
an example which relocates a module for Theta Music Composer (TMC).
</div>

<div id="_put">
<h3>.PUT [index] = value</h3>
The directive .PUT stores a value of type <b>.BYTE</b> into a one-dimensional array in the
MADS memory. This is the same array in which the directive <b>.GET</b> reads a file.
<p>
The INDEX must be in the range [0..65535].
</p>
<pre class="code">
Example:

  .put [5] = 12          ; Store the value 12 into MADS memory at element 5
</pre>
</div>

<div id="_sav">
<h3>.SAV [index] ['filename',] length</h3>
The directive <b>.SAV</b> saves the MADS memory used by the directives <b>.GET</b> and <b>.PUT</b>
to an external file or inserts it into the current assembly output.
<p>
The INDEX must be in the range [0..65535].
</p>
<pre class="code">
Example:

  .sav ?length            ; Insert elements [0..?LENGTH-1] to current assembly output
  .sav [200] 256          ; Insert elements  [200..200+256-1] to current assembly output
  .sav [6] 'filename',32  ; Save elements [6..6+32-1] to file FILENAME
</pre>
</div>

<div id="_or"> 
<h3>.OR, .AND, .XOR, .NOT</h3>
These directives are equivalent to the logical operators <b>||</b> (<b>.OR</b>),
 <b>&amp;&amp;</b> (<b>.AND</b>), <b>^</b> (<b>.XOR</b>),<b>!/</b> (<b>.NOT</b>).
</div>

<div id="_lohi"> 
<h3>.LO (expression), .HI (expression)</h3>
These directives are equivalent to the operators <b>&lt;</b> (low byte) and <b>&gt;</b> (high byte), respectively.
</div>

<div id="conditions">
<h3>.IF, .ELSE, .ELSEIF, .ENDIF</h3>

<pre class="code">
  .if     [ift] expression
  .else   [els]
  .elseif [eli] expression
  .endif  [eif]
</pre>

These directives and pseudo-commands can be used interchangeably to conditionally assemble portions of code.

<pre class="code">
Example:

  .if .not .def label_name
    label_name = 1
  .endif

  .if [.not .def label_name] .and [.not .def label_name2]
    label_name = 1
    label_name2 = 2
  .endif
</pre>

In these examples the parentheses or square brackets are required. Otherwise the parameter
of the first <b>.DEF</b> directive would be the label <b>label_name.AND.NOT.DEFlabel_name2</b>.
because spaces are ignored and periods are allowed in label names.
</div>

</div>

<div id="directives_6502">
<h1>6502 CODE GENERATION DIRECTIVES</h1>

<pre class="code">
  <a href="#_test6502">#IF</a> type expression [.OR type expression] [.AND type expression]
  <a href="#_test6502">#ELSE</a>
  #END

  <a href="#_while6502">#WHILE</a> type expression [.OR type expression] [.AND type expression]
  #END

  <a href="#_cycle6502">#CYCLE #N</a>
</pre>

<div id="_test6502">
<h3>#IF type expression [.OR type expression] [.AND type expression]</h3>
The <b>#IF</b> directive is somewhat equivalent to the IF statement of higher-level languages (C, Pascal).
<p>
The <b>#IF</b>, <b>#ELSE</b>, and #END directives produce 6502 machine code for an IF conditional
statement around the designated program block and can be nested. All types are
acceptable (.BYTE, .WORD, .LONG, and .DWORD). It is possible to combine terms
using the .AND and .OR directives, but it is impossible to control the order of evaluation
with parentheses.
</p>
<p>
The implementation of the <b>#IF</b> directive begins with the calculation of the value
that is a simple expression consisting of two operands and one operator (expression
can be combined using the .OR or .AND directives).
</p>
<p>
If the expression is non-zero (TRUE), the program block within the <b>#IF</b> is executed,
terminated by a JMP instruction to the next instruction after <b>#END</b> if there is an
<b>#ELSE</b> block.
</p>

If the expression is zero (FALSE), the code following <b>#ELSE</b> is executed. If there is no
<b>#ELSE</b> directive, then control is transferred to the next instruction after the <b>#END</b>
directive.

<pre class="code">
Example:

  #if .byte label&gt;#10 .or .byte label&lt;#5
  #end

  #if .byte label&gt;#100
    #if .byte label&lt;#200
    #end
  #end

  #if .byte label&gt;#100 .and .byte label&lt;#200 .or .word lab=temp
  #end

  #if .byte @
  #end
</pre>
</div>

<div id="_while6502">
<h3>#WHILE type expression [.OR type expression] [.AND type expression]</h3>
The <b>#WHILE</b> directive is equivalent to the WHILE statement in higher-level languages (C, Pascal).
<p>
The directives <b>#WHILE</b> and <b>#END</b> allow generation of 6502 machine code for a loop around
the given program block and can be nested. The types <b>.BYTE</b>, <b>.WORD</b>, <b>.LONG</b>, and <b>.DWORD</b> are
acceptable. Multiple terms can be connected with the <b>.OR</b> and <b>.AND</b> directives, but the order
of evaluation cannot be controlled by parentheses.
</p>
The sequence of operations in the expansion of the <b>#WHILE</b> statement is as follows:
<ol>
    <li>Calculate the value of the expression and check if it is equal to zero (FALSE).
        <ul>
            <li>if so, skip step 2;</li>
            <li>if not (TRUE), go to step 2.</li>
        </ul></li>
    <li>Execute the code block bounded by the <b>#WHILE</b> and <b>#END</b> directives, then go to step 1.</li>
</ol>

If the first evaluation of the expression produces zero, the program block will never be
executed and control passes to the next statement after <b>#END</b>.


<pre class="code">
Example:

  #while .byte label&gt;#10 .or .byte label#5
  #end

  #while .byte label&gt;#100
   #while .byte label2#200
   #end
  #end

  #while .byte label&gt;#100 .and .byte label#200 .or .word lab=temp
  #end
</pre>
</div>

<div id="_cycle6502">
<h3>#CYCLE #N</h3>

The directive <b>#CYCLE</b> generates code to take a given number of cycles. The generated code does not
modify any memory or any general purpose register.

<pre class="code">
  #cycle #17  ; pha      3 cycles
              ; pla      4 cycles
              ; pha      3 cycles
              ; pla      4 cycles
              ; cmp $00  3 cycles
                        ---------
                        17 cycles
</pre>
</div>

<div id="assembling_into_zero_page">
<h2>Assembling into zero page</h2>

Unlike two-pass assemblers like QA and XASM, MADS is a multi-pass assembler.
This has many advantages. Why? Take this example.

<pre class="code">
Example: detection of zero page addressing

      org $00
 
      lda tmp+1
  tmp lda #$00
</pre>

A two-pass assembler does not know the value of the label TMP.
It will assume that it is 16-bit (<b>.WORD</b> type) and generate LDA abs.
However, MADS nicely generates LDA zp because the actual size is known in the last pass.
This is the simplest benefit of multiple passes.
Now, suppose referring to zero page with LDA abs is explicitly desired.
No problem, just extend the mnemonic to force 16-bit addressing.

<pre class="code">
Example: force 16-bit addressing

     org $00
 
     lda.w tmp+1
 tmp lda #$00
</pre>

Three mnemonic extensions are allowed:
<pre>
  <b>.b</b>[<b>.z</b>]      - <b>.BYTE</b> or zero page
  <b>.w</b>[<b>.a</b>][<b>.q</b>]  - <b>.WORD</b> or address
  <b>.l</b>[<b>.t</b>]      - <b>.LONG</b> or triple byte
</pre>
The last one generates a 24-bit value for 65816 long addressing (seldom used).
For more information 6502 and 65816 CPU mnemonics, see <a href="#mnemonics">Mnemonics</a>.
<p>
Another way to force zero page addressing is to use curly braces <b>{ }</b> to generate opcodes with <b>DTA</b> pseudo-opcode.
</p>
<pre class="code">
Example: 

  dta {lda $00},$80 ; Generates $a5,$80, i.e. lda $80
</pre>

Either will work with MADS as the last pass will do the trick.
The next problem is putting this code on your computer.
Loading directly into page zero will probably work if the target area is within [$80..$FF],
but when loading below that the OS is unlikely to survive.
<p>
Therefore, MADS provides the possibility to relocate code.
The pseudo-command <b>ORG address1,address2</b> assembles at <b>address1</b>, but loads to address <b>address2</b>.
The  pseudo-command <b>ORG</b> always creates a new block in the file, which adds an additional four bytes for the header of
the new block.
</p>

<pre class="code">
Example: relocate zero page code

      org $20,$3080
 
      lda tmp+1
  tmp lda #$00
</pre>

This assembles at address $0020, but with a load address of $3080. Of course, moving
the code to the correct address ($0020 in our example) is now the responsibility of the programmer.
<p>
If it is OK for the new address of the data in memory to be the current address, then
the property of <b>.LOCAL</b> and <b>.PROC</b> blocks can be used to avoid writing a new header.
</p>

<pre class="code">
Example: relocate inline blocks

   1
   2 					org $2000
   3
   4 FFFF> 2000-200D> A9 00  lda #0
   5 2002 EA                 nop
   6
   7 0060                   .local temp, $60
   8
   9 0060 BD FF FF           lda $ffff,x
  10 0063 BE FF FF           ldx $ffff,y
  11
  12                         .endl
  13
  14 2009 A5 60              lda temp
  15 200B AD 03 20           lda .adr temp
  16
</pre>

In this example the block TEMP will be assembled with the new address $60
and be placed in memory at address $2003. After the block end directive (<b>.ENDL</b>, <b>.ENDP</b>, <b>.END</b>),
assembly will resume at the previous assembly address plus the length of the block,
which in this case is $2009.
<p>
The directives <b>.ADR</b> and <b>.LEN</b> can then be used to copy the block to the correct address.
</p>

<pre class="code">
Example:

        ldy #0
  copy  mva .adr(temp),y temp,y+
        cpy #.len temp
        bne copy
</pre>
For more information on the directives, see <a href="#_ADR">.ADR</a> and <a href="#_LEN">.LEN</a>.
</div>

</div>

<div id="types">
<h1>TYPES</h1>
MADS allows the declaration of two types of data: structured data (<b>.STRUCT</b>) data and enumerated data (<b>.ENUM</b>). 

<div id="structures">
<h1>STRUCTURED TYPES, STRUCTURES</h1>

If you have programmed in <b>C</b>, you have probably already encountered structures.
Overall, a MADS structure defines an array of virtual, one-dimensional fields
of varying <b>.BYTE</b>, <b>.WORD</b>, <b>.LONG</b>, or <b>.DWORD</b>
types or multiples thereof. They are virtual because they exist only in the MADS memory during assembly.

<p>
The fields of the structure contain information about offsets from the beginning of the structure.
</p>

<h2 id="_struct">Declaring structures (<b>.STRUCT</b>)</h2>

Structures can be declared with the following directives.
<pre class="code">
  name .struct
       .ends [.send] [.end]

       .struct name
       .ends [.send] [.end]
</pre>

<h3>name .STRUCT</h3>

Declares a structure with the name <b>name</b> preceding the <b>.STRUCT</b> directive.
The name of the structure is required and an error is generated if it is missing.
Structures cannot be named with mnemonic or pseudo-command names. If the name
is reserved, a <b>Reserved word</b> error is reported.

<pre class="code">
Example: structure declaration

.struct name

  x .word      ; lda #name.x = 0
  y .word      ; lda #name.y = 2
  z .long      ; lda #name.z = 4
  v .dword     ; lda #name.v = 7

  q :3 .byte   ; lda #name.q = 11

.ends          ; lda #name   = 14 (length)
</pre>

Each line defines a field by name and type (.BYTE, .WORD, .LONG, or .DWORD). The
field name may be preceded by whitespace. Between the .STRUCT and .ENDS directives,
CPU mnemonics may not be used. Attempting to do so or having other invalid
characters will result in an <b>Improper syntax</b> or <b>Illegal instruction</b>
error message.
<p>
In summary, the label <b>name</b> contains information about the total length
of the structure (in bytes). The other labels describing the fields contain information
about the offsets to each field from the beginning of the structure.
</p>

Structure declarations cannot be nested, but previously declared structures can be nested
in other ones (declaration order does not matter). For example:

<pre class="code">
.struct temp

x .word
y .word
v .byte
z .word

.ends


.struct test

tmp  temp

.ends

 lda #temp.v
 lda #test.tmp.x
 lda #test.tmp.z
</pre>

<p>
What are structures useful for?
</p>
Suppose you have a table of different types, where you can read each table field with
a predetermined offset value. If a field is added to the table, or the table is modified
in any other way, the program code will have to be updated to use new field offsets.
Defining the table using a structure means that offsets can be determined by the structure
definition, which are then automatically updated even if the structure of the table is
changed.

<p>
Another example of structure usage can be found in the section on <a href="#labels_ext">External symbols</a>, <a href="#_prz_str">Using external symbols with structures (.STRUCT)</a>.
</p>

<h2 id="struct_wy">Defining structured data, references</h2>

Structured data can be defined by assigning a new label with the pseudo-command DTA and
a specific structure name, or just with the structure name without the pseudo-command.
The result is that the virtual structure definition is turned into actual reserved memory.

<pre class="code">
label DTA struct_name [count] (data1,data2,data3...) (data1,data2,data3...) ...

label struct_name
</pre>

<p>
<b>COUNT</b> specifies a number in the range [0..COUNT],
which defines the maximum element index in a one-dimensional array and thus the amount
of memory reserved.
</p>

Examples of structure and structured data declarations:

<pre class="code">
;-----------------------;
; structure declaration ;
;-----------------------;
.STRUCT temp

x .word
y .word
v .byte
z .word

.ENDS

;---------------;
; defining data ;
;---------------;

data dta temp [12] (1,20,200,32000) (19,2,122,42700)

data2 dta temp [0]

data3 temp          // shorter equivalent to DATA2
</pre>

The value in square brackets must be a value between <b>[0..2147483647]</b>,
which defines the maximum value of a one-dimensional array index and thus the amount of memory
reserved for the structured data.

<p>
After the square brackets an optional list of initializer values (in parentheses) may follow.
Otherwise, the field values default to zero. However, if the initializer list is shorter than
the number of declared fields, the remaining fields are initialized to the previous value
given for those fields:
</p>

<pre class="code">
data dta temp [12] (1,20,200,32000)
</pre>
</div>

Such a declaration will result in all fields being initialized to the values 1,20,200,32000,
not just the first element data[0].


<p>
If the list of initializers is longer than the number of elements, the error <b>Constant
expression violates subrange bounds</b> will result.
</p>

To refer to fields in the structured data, use its name, followed by an index in square
brackets and the field name after a dot:
<pre class="code">
 lda data[4].y
 ldx #data[0].v
</pre>

Forgetting the brackets with an index in the syntax <b>label[index]</b> results in the error message <b>Undeclared label</b>.
</div>

<div id="enums">
<h1>ENUMERATED TYPES, ENUMERATION</h1>

These directives are used with enumerations:

<pre class="code">
name .enum
     .ende [.eend] [.end]

Example:

.enum portb
 rom_off = $fe
 rom_on = $ff
.ende

.enum test
 a             ; a=0
 b             ; b=1
 c = 5         ; c=5
 d             ; d=6
.ende
</pre>

<p>
Enumerations are declared using the directives <b>.ENUM</b> and <b>.ENDE</b>.
The name of the enumeration is required and an error will be generated otherwise.
Enumeration names may not be the same as mnemonics or pseudo-commands, which will
produce a <b>Reserved word</b> error.
</p>

The label values are automatically assigned starting with a default value of 0
and incrementing by 1. You can define the value of each label directly or
have them be automatically set.
<p>
Enumerated labels are referenced using this syntax:
</p>

<pre class="code">
 enum_name (field)
</pre>

or directly like with .LOCAL and .PROC blocks, with a dot between the enumeration
name and the field name:

<pre class="code">
 lda #portb(rom_off)

 dta portb.rom_on, portb.rom_off
</pre>

Enumerations can be used for field declarations in structures (.STRUCT) and variable declarations (.VAR):

<pre class="code">
bank portb           // allocate variable BANK of size 1 byte
.var bank portb      // allocate variable BANK of size 1 byte

.struct test
 a portb
 b portb
.ends
</pre>

The size of an enumeration is dependent upon the maximum value of its labels:
<pre class="code">
    .enum estate
        done, directory_search=$ff, init_loading, loading
    .ende
</pre>

In this example, the enumeration "EState" will have a size of two bytes (WORD).

<p>
The size of an enumeration can be checked with the .LEN directive (equivalent to SIZEOF),
where the result will be a value in the range [1..4] (1=BYTE, 2=WORD, 3=LONG, 4=DWORD):
</p>

<pre class="code">
 .print .len estate
</pre>

</div>

<div id="arrays">
<h1>ARRAYS</h1>

<h2 id="array">Declaring dimensional arrays (<b>.ARRAY</b>)</h2>

Directives for arrays:

<pre class="code">
name .array index type [= default_value]
     .array name count type [= default_value]
     .enda [.aend] [.end]
</pre>

Available types are <b>.BYTE</b>, <b>.WORD</b>, <b>.LONG</b>, and <b>.DWORD</b>.

<p>
INDEX specifies the maximum permitted value of the array index range [0..INDEX].
This value can be a constant or an expression in the range  <b>[0..65535]</b>.
If INDEX is omitted, the range is determined by the number of input values.
</p>

CPU mnemonics cannot be used between .ARRAY and .ENDA, and attempting to do so or having
other illegal characters will result in the error <b>Improper syntax</b>.
        <p></p>
The array index used for initialization can be specified along with initializer values.
A new array index is set by placing it in square brackets at the beginning of a new
line, i.e. <b>[expression]</b>. Additional indices can be supplied, separated by
a colon (<b>':'</b>). The array values then follow after a equals sign (<b>'='</b>):
<pre class="code">
.array tab .byte      ; Define array TAB with an unspecified number of elements
 1,3                  ; [0]=1, [1]=3
 5                    ; [2]=5 
 [12] = 1             ; [12]=1
 [3]:[7]:[11] = 9,11  ; [3]=9, [4]=11, [7]=9, [8]=11, [11]=9, [12]=11
.enda
</pre>

This facility may seem strange and of limited use, but it is occasionally useful, such as
for declaring lookup tables for translating the scan code of a pressed key or between
ATASCII and INTERNAL code.

<pre class="code">
.array TAB [255] .byte = $ff   ; Allocate 256 bytes [0..255] with initial value $FF

 [63]:[127] = "A"              ; Assign new values TAB[63]="A", TAB[127]="A"
 [21]:[85]  = "B"
 [18]:[82]  = "C"
 [58]:[122] = "D"
 [42]:[106] = "E"
 [56]:[120] = "F"
 [61]:[125] = "G"
 [57]:[121] = "H"
 [13]:[77]  = "I"
 [1] :[65]  = "J"
 [5] :[69]  = "K"
 [0] :[64]  = "L"
 [37]:[101] = "M"
 [35]:[99]  = "N"
 [8] :[72]  = "O"
 [10]:[74]  = "P"
 [47]:[111] = "Q"
 [40]:[104] = "R"
 [62]:[126] = "S"
 [45]:[109] = "T"
 [11]:[75]  = "U"
 [16]:[80]  = "V"
 [46]:[110] = "W"
 [22]:[86]  = "X"
 [43]:[107] = "Y"
 [23]:[87]  = "Z"
 [33]:[97]  = " "

 [52]:[180] = $7e
 [12]:[76]  = $9b

.enda
</pre>

<p>
In this example, an array TAB is created with indices [0..255] and 256 .BYTEs in size,
pre-initialized to $FF. The array elements are then set to translate keyboard scan codes
(both upper and lowercase, ignoring case) to INTERNAL.
</p>

The colon (':') is used to separate array indices.

<p></p>
Another example is to center a string:
<pre class="code">
 org $bc40

.array txt 39 .byte
 [17] = "ATARI"
.enda
</pre>

<p>
In summary, the <b>.ARRAY</b> directive allows creation of a one-dimensional array
of values with a specified type.
</p>

To refer to an array:
<pre class="code">
 lda tab,y
 lda tab[23],x
 ldx tab[200]
</pre>

If the index given in square brackets exceeds the maximum index of the array, the error message
<b>Constant expression violates subrange bounds</b> is reported.
</div>

<div id="macros">
<h1>MACROS</h1>

Macros help perform repetitive tasks by automating them. They are only kept in memory during assembly
unless invoked. With their aid, MADS can push and pop parameters off a software stack for
a procedure declared with the directive .PROC and switch extended memory banks with
the option BANK SENSITIVE (OPT B+).

<div id="declaring_macros">
<h2>Declaring macros</h2>

Macro pseudo-commands and directives:

<pre class="code">
name .macro [arg1, arg2 ...] ['separator'] ["separator"]
     .macro name [(arg1, arg2 ...)] ['separator'] ["separator"]
     .exitm [.exit]
     .endm [.mend]
     :[%%]parameter
     :[%%]label
</pre>

<h3>name .macro [(arg1, arg2 ...)] ['separator'] ["separator"]</h3>

Declares a macro named <b>name</b> with the directive <b>.MACRO</b>.
The macro name is required and an error is reported without it. Macro names cannot be
the same as an instruction mnemonic or pseudo-command, which will cause a
<b>Reserved word</b> error message.

<p></p>
A list of named arguments can be specified for the macro, optionally wrapped in parentheses.
Assigning name to macro arguments improves readability of macro code.
Argument names and numeric arguments can be used interchangeably.

<pre class="code">
.macro SetColor val,reg
 lda :val
 sta :reg
.endm
</pre>

<p></p>
At the end of the macro declaration, the argument separator and the argument parsing mode
can be supplied (unchanged for single quotes, split into parameters and addressing modes
for double quotes).
<p>
<b>The default separators</b> for macro argument parsing are a comma (',') and a space (' ').
</p>

<pre class="code">
name .macro 'separator'
</pre>

Between the quotes '' we place the separator character used to separate parameters when
invoking the macro (only with single quotes).

<pre class="code">
name .macro "separator"
</pre>

Double quotes ("") can also be used to set separators for the macro parameters, but this also
indicates to MADS that the parameters should be split into two parts: addressing mode
and argument.

<pre class="code">
     test #12 200 &lt;30

test .macro " "
     .endm
</pre>

This TEST macro is declared with a space as the separator using <b>"</b>,
which then causes the macro parameter to be divided into two parts, addressing mode and argument.
<pre class="code">
 #12   -&gt;  addressing mode '#' argument 12
 200   -&gt;  addressing mode ' ' argument 200
 &lt;30   -&gt;  addressing mode '#' argument 0   (calculated expression value of "&lt;30")

 test '#' 12 ' ' 200 '#' 0
</pre>

<b>NOTE #1:</b> The sign operators '&lt;', '&gt;' are evaluated before parameters are passed
to a macro, with the result substituted as the parameter.

<p>
<b>NOTE #2:</b> If the macro parameter is the loop counter <b>'#'</b> or <b>'.R'</b>
(!!! the single character '#' or the directive '.R', and not an expression involving one of them !!!)
the value of the loop counter is substituted as the macro parameter.
</p>

This property can be used to create iterated label names like "label0", "label1", "label2", "label3"... :

<pre class="code">
 :32 find #

find .macro
      ift .def label:1
      dta a(label:1)
      eif
     .endm
</pre>

In this example, the address of each numbered label is written (if it is defined).


<h3>.EXITM [.EXIT]</h3>
End the macro. This terminates the macro invocation.

<h3>.ENDM [.MEND]</h3>
The directive .ENDM or .MEND ends the current macro definition. The .END directive cannot
be used as for the .LOCAL, .PROC, .ARRAY, .STRUCT, and .REPT directives.

<h3>:[%%]parameter</h3>
The parameter is a <b>positive decimal number</b> (>=0), followed by a colon (':')
or two percent signs ('%%'). If in a macro you want to use ':' for repetition and
not to signify a macro parameter, ensure that the next character after the colon is outside of
the range ['0'..'9']:
<pre class="code">
 :$2 nop
 :+2 nop
 :%10 nop
</pre>

Parameter :0 (%%0) has special meaning and contains the number of parameters passed.
This can be used to check if the required number of parameters was passed to a macro:

<pre class="code">
  .if :0&lt;2 || :0&gt;5
    .error "Wrong number of arguments"
  .endif

  ift %%0&lt;2 .or :0&gt;5
    ert "Wrong number of arguments"
  eif 
</pre>

<pre class="code">
Example: macro definition

.macro load_word

   lda &lt;:1
   sta :2
   lda &gt;:1
   sta :2+1   
 .endm

 test ne
 test eq

.macro test
  b%%1 skip
.endm
</pre>
</div>


<div id="calling_macros">
<h2>Calling macros</h2>

Macros are called by name, with arguments separated by default with commas (',') or spaces (' ').
The maximum number of parameters is limited only by PC memory. If the number of parameters passed
is fewer than the number of parameters in the macro, the missing parameters are set to the value
<b>-1 ($FFFFFFFF)</b>. This property can be used to test if a parameter has been passed,
but it is easier to use parameter zero (%%0).

<pre class="code">
 macro_name [Par1, Par2, Par3, 'Par4', "string1", "string2" ...]
</pre>

A parameter can be a value or a string delimited by either single quotes ('') or double quotes.
("").

<ul>
<li>Single quotes '' are passed to the macro along with the characters within them</li>
<li>Double quotes "" mean that only the string within the quotes and not the quotes themselves are passed to the macro</li>
</ul>

<p>
All label definitions within a macro are local.
</p>
If the assembler does not find a label within the macro, it will then look in the local scope
(if there was a <b>.LOCAL</b> directive), then in the procedure (if a procedure is
currently being defined), and then finally in the main program.

<pre class="code">
Example: macro call

  macro_name 'a',a,>$a000,cmp    ; The default separator ','
  macro_name 'a'_a_>$a000_cmp    ; The declared separator '_'
  macro_name 'a' a >$a000 cmp    ; The default separator ' '
</pre>

Macros can be called from other macros as well as called recursively. In the latter case,
care should be taken to avoid causing stack overflow in MADS. MADS is
protected against infinite recursion and will stop with the error message <b>Infinite recursion</b> once the nesting depth
reaches 4095.

<pre class="code">
Example: cause stack overflow in MADS stack

jump .macro
      jump
     .endm
</pre>


Example program that passes parameters to pseudo-procedures, from the file "..\EXAMPLES\MACRO.ASM".
<pre class="code">
Example:

 org $2000
 
 proc PutChar,'a'-64    ; Call macro PROC, with as parameters
 proc PutChar,'a'-64    ; The name of a procedure to call by JSR
 proc PutChar,'r'-64    ; and a single argument (INTERNAL character code)
 proc PutChar,'e'-64
 proc PutChar,'a'-64

 proc SetColor,$23      ; Call another procedure to change the background color

;---

loop jmp loop           ; Endless loop to show the effect

;---

proc .macro             ; Declare PROC macro
 push =:1,:2,:3,:4      ; Call PUSH macro to push arguments onto the stack
                        ; =:1 calculates the memory bank
 
 jsr :1                 ; Jump to procedure (procedure name is the first parameter)
 
 lmb #0                 ; Load memory bank, setting bank to 0
 .endm                  ; End of PROC macro

;---

push .macro             ; Declare PUSH macro

  lmb #:1               ; Set up virtual memory bank

  .if :2&lt;=$FFFF      ; If passed argument is less than or equal to $FFFF
    lda &lt;:2          ; put it on the stack
    sta stack
    lda &gt;:2
    sta stack+1
  .endif 

  .if :3&lt;=$FFFF
    lda &lt;:3
    sta stack+2
    lda &gt;:3
    sta stack+3
  .endif 

  .if :4&lt;=$FFFF
    lda &lt;:4
    sta stack+4
    lda &gt;:4
    sta stack+5
  .endif 
 
  .endm
 

* --------------- *     ; SetColor procedure
*  PROC SetColor  *
* --------------- *
  lmb #1                ; Set virtual bank to 1
                        ; Label definitions are now local to this bank
stack org *+256         ; Stack for SetColor procedure
color equ stack

SetColor                ; Code for SetColor procedure
  lda color
  sta 712
  rts
 
* -------------- *      ; PutChar procedure
*  PROC PutChar  *
* -------------- *
  lmb #2                ; Set virtual bank to 2
                        ; Label definitions are now local to this bank
stack org *+256         ; Stack for PutChar procedure
char  equ stack

PutChar                 ; Code for PutChar procedure
  lda char
  sta $bc40
scr equ *-2

  inc scr
  rts
</pre>

Of course, this example uses a software stack, whereas with the 65816
the hardware stack could be used instead. Because the defined variables are each local to
a particular bank, procedure calls can be created with similar structure and function
to those of higher-level languages.

<p>
However, it is simpler and more efficient to use the procedures allowed by MADS,
which are declared with <b>.PROC</b>. For more information on procedure declaration
and operations, see <a href="#procedures">Procedures</a>. 
</p>

</div>
</div>

<div id="procedures">
<h1>PROCEDURES (.PROC)</h1>

MADS adds the ability to use procedures with parameters. This feature resembles the
familiar mechanisms of high-level languages and is just as easy for a programmer to use.

<p>
The built-in MADS macros (@CALL.MAC, @PULL.MAC, @EXIT.MAC) provide
a software stack of 256 bytes, the same size as the hardware stack, a way to pop
from the software stack, and to save and restore parameters when calling other
procedures. MADS supports recursive procedure calls.
</p>

<p>
The programmer is not involved in this mechanism and can focus on his program, only needing
to define the appropriate labels and include the needed macros when assembling the program.
</p>
<p>
Also, the software stack can be omitted and arguments passed using a more classical method
with CPU registers (.REG directive) or with variables (.VAR directive).
</p>
<p>
Another feature of .PROC procedures is that it is possible to omit them during assembly if
they are not referenced. This generates the warning message <b>Unreferenced procedure ????</b>.
They can be removed during assembly by specifying the <b>-x</b> 'Exclude unreferenced procedures'
command-line parameter to MADS.
</p>
<p>
All labels defined in a .PROC procedure are local but can also be accessed globally,
which is uncommon in other programming languages.
</p>
<p>
It is possible to define a global label from Within a .PROC procedure (see
<a href="#labels_glo">Global labels</a>). 
</p>

To access labels within a procedure from outside of it, address it using a dot ('.'):

<pre class="code">
 lda test.pole

.proc test

pole nop

.endp
</pre>

If a referenced label is not found within a .PROC procedure, MADS will then
look for in enclosing scopes until the global scope is reached. To directly address a global label
from within a .PROC procedure (or any other scope) prefix the label name with a colon (':').

<p></p>


For procedures that use a software stack, MADS requires three specific globally defined labels
(the stack location, the stack pointer, and the address of the procedure variables):
<div style="color: #0000FF">
<pre>
@PROC_VARS_ADR
@STACK_ADDRESS
@STACK_POINTER
</pre>
</div>

<p>
If these labels are undefined and a .<b>.PROC</b> procedure with a software stack is used,
MADS assumes the following default values: <b>@PROC_VARS_ADR = $0500</b>, <b>@STACK_ADDRESS = $0600</b>,
and <b>@STACK_POINTER = $FE</b>.
</p>

For procedures using a software stack, MADS also requires the declaration of macros with
specific names. Declarations of these macros are included with MADS in the following files:

<pre class="code">
@CALL    ..\EXAMPLES\MACROS\@CALL.MAC
@PUSH    ..\EXAMPLES\MACROS\@CALL.MAC
@PULL    ..\EXAMPLES\MACROS\@PULL.MAC
@EXIT    ..\EXAMPLES\MACROS\@EXIT.MAC
</pre>

These macros implement the loading and pushing of parameters onto the software stack, the popping
and saving of procedure parameters off the software stack, and calling other procedures using
the software stack.
</div>

<div id="proc">
<h2>Declaration of .PROC procedures</h2>

Procedure declaration directives:

<pre class="code">
 name .PROC [(.TYPE PAR1 .TYPE PAR2 ...)] [.REG] [.VAR]
 .PROC name [,address] [(.TYPE PAR1 .TYPE PAR2 ...)] [.REG] [.VAR]
 .ENDP [.PEND] [.END]
</pre>


<h3>name .PROC [(.TYPE Par1,Par2 .TYPE Par3 ...)] [.REG] [.VAR]</h3>

Declares a procedure <b>name</b> using the <b>.PROC</b> directive. The procedure name is
required and an error is generated without it. Mnemonic names and pseudo-commands cannot be used
as procedure names and will cause a <b>Reserved word</b> error.

<p></p>

To use MADS's parameter passing mechanism, the parameters have to be declared beforehand.
Parameter declarations are enclosed in parentheses ( ). There are four types of parameters:

<pre>
.BYTE  (8-bit)  relocatable
.WORD  (16-bit) relocatable
.LONG  (24-bit) non-relocatable
.DWORD (32-bit) non-relocatable
</pre>


<b>Note:</b> In current versions of MADS, it is not possible to pass parameters of structure type (.STRUCT).


<p></p>

The parameter type comes first, followed by at least one space, followed by the parameter name.
Multiple parameters of the same type can be declared, separated by commas (',').

<pre class="code">
Example: procedure declaring using the software stack
name .PROC ( .WORD par1 .BYTE par2 )
name .PROC ( .BYTE par1,par2 .LONG par3 )
name .PROC ( .DWORD p1,p2,p3,p4,p5,p6,p7,p8 )
</pre>

<p>
Additionally, by using the .REG or .VAR directives, parameters can be passed to MADS procedures
by CPU registers (.REG) or variables (.VAR). The directive specifying the parameter passing
convention is placed at the end of the .PROC procedure declaration.
</p>

<pre class="code">
Example: procedure declarations using CPU registers
name .PROC ( .BYTE x,y,a ) .REG
name .PROC ( .WORD xa .BYTE y ) .REG
name .PROC ( .LONG axy ) .REG
</pre>

<p>
The .REG directive requires that the parameter names are made up of the letters 'A', 'X', 'Y', or
a combination thereof. These refer to the names of the CPU registers and affect the order in which
they are used. The number of parameters passed is limited by the number of CPU registers, so at most
three bytes can be passed to the procedure. The advantage of this method is speed and lower memory
usage.
</p>

<pre class="code">
Example: procedure declarations using variables

name .PROC ( .BYTE x1,x2,y1,y2 ) .VAR
name .PROC ( .WORD inputPointer, outputPointer ) .VAR
name .PROC ( .WORD src+1, dst+1 ) .VAR
</pre>

With .VAR, the parameter names indicate the variable names which will be loaded with the passed
parameters. This method is slower than .REG but still faster than software stack methods.

<p>
Procedures are exited in the usual way, using the RTS command. Adding the <b>RTS</b>
instruction at the end of each code path is the responsibility of the programmer, not the assembler.
</p>

As with a .LOCAL block, a new address can be specified for assembling a .PROC block:
<pre class="code">
.PROC label,$8000
.ENDP

.PROC label2,$a000 (.word ax) .reg
.ENDP
</pre>

For procedures that use the software stack, MADS invokes the macro <b>@EXIT</b> at
the end of the procedure, whose task is to modify the software stack pointer
<b>@STACK_POINTER</b>. This is necessary for proper software stack operation.
Users can write their own <b>@EXIT</b> macro, or use the one included
with MADS in the file "..\EXAMPLES\MACROS\@EXIT.MAC", which currently looks like this:

<pre class="code">
.macro @EXIT

 ift :1&lt;&gt;0

  ift :1=1
   dec @stack_pointer

  eli :1=2
   dec @stack_pointer
   dec @stack_pointer

  els
   pha
   lda @stack_pointer
   sub #:1
   sta @stack_pointer
   pla

  eif

 eif

.endm
</pre>

<p>
The macro <b>@EXIT</b> should not alter the contents of CPU registers if you want
to return a result from a .PROC procedure using CPU registers.
</p>


<h3>.ENDP</h3>

The <b>.ENDP</b> directive ends a procedure declaration block.
</div>

<div id="proc_wy">
<h2>Procedure calls</h2>

<p>
A procedure is called by name (the same as for a macro), followed by any provided parameters,
separated by a commas (',') or spaces (' '). It is not possible to use other separators.
</p>

If the type of a parameter is different than the type used in the procedure declaration, an
<b>Incompatible types</b> error is reported.

<p>
If the number of parameters passed is different than the number of parameters in the procedure
declaration, the result is an <b>Improper number of actual parameters</b> error.
The exception is procedures which use parameters passed by CPU register (.REG) or
variable (.VAR), in which case the extra parameters are assumed to be already loaded into
the correct registers or variables.
</p>

There are three ways to pass parameters:
<ul>
<li>'#' by value</li>
<li>' ' by address (without prefix)</li>
<li>'@' by accumulator (parameter type <b>.BYTE</b>)</li>
<li>"string" as a string, e.g. "label,x"</li>
</ul>

<pre class="code">
Example: procedure call

 name @ , #$166 , $A400  ; with the software stack
 name , @ , #$3f         ; with .REG or .VAR
 name "(hlp),y" "tab,y"	 ; with .VAR or the software stack (the software stack uses the X register)
</pre>

<p>
When MADS encounters a procedure call that uses the software stack, it executes the
macro @CALL. However, if the procedure does not use the software stack, a plain
<b>JSR PROCEDURE</b> is used instead of the @CALL macro.
</p>

To the <b>@CALL</b> macro, MADS passes parameters computed based on the
procedure declaration, breaking each parameter into three components: addressing mode, parameter
type, and parameter value.
<pre class="code">
@CALL_INIT 3\ @PUSH_INIT 3\ @CALL '@','B',0\ @CALL '#','W',358\ @CALL ' ',W,"$A400"\ @CALL_END PROC_NAME
</pre>

Here, the <b>@CALL</b> macro pushes the contents of the accumulator, then the value
$166 (358 dec), then the value at the address $A400. For more information on
how parameters are passed to the macro (and the importance of '' and ""), see <a href="#calling_macros">Calling macros</a>.

<p>
Parameters passed using the accumulator ('@') should always be the first parameter
passed to the procedure. If it is used elsewhere, the accumulator is already modified by that
point (this restriction is imposed by the <b>@CALL</b> macro). Of course, this can be
lifted with a custom version of the <b>@CALL</b> macro.
With procedures that use .REG or .VAR, a '@' parameter can be used in any position.
</p>
<p>
The end of a <b>.PROC</b> procedure is marked by an RTS. After the procedure call,
MADS invokes the <b>@EXIT</b> macro to modify the <b>@STACK_POINTER</b>, which is necessary
for proper operation of the software stack. The number of bytes passed to the procedure is passed
as a parameter to the macro, which then subtracts that number of bytes from the software stack.
</p>

<p class="editors-note">
(Editor's note: This is known as a caller-pops convention, since the caller both pushes and pops
the parameters off the stack, and is common in C implementations.)
</p>

<p>
Adding an <b>RTS</b> instruction at the end of every code path in the procedure is the responsibility
of the programmer, and not the assembler.
</p>
</div>

<div id="procedure_parameters">
<h2 >Procedure parameters</h2>

Referring to procedure parameters does not require additional effort by the programmer:
<pre class="code">
@stack_address equ $400
@stack_pointer equ $ff
@proc_vars_adr equ $80

name .PROC (.WORD par1,par2)

 lda par1
 clc
 adc par2
 sta par1
 
 lda par1+1
 adc par2+1
 sta par1+1

.endp

 icl '@call.mac'
 icl '@pull.mac'
 icl '@exit.mac'
</pre>

At the time of declaration, MADS automatically defines these parameters by assigning values
based on @PROC_VARS_ADR. In the preceding example, MADS will define the parameters as PAR1 =
@PROC_VARS_ADR and PAR2 = @PROC_VARS_ADR + 2.

<p>
The programmer uses these parameters by the names given in the procedure declaration, similarly
as with higher-level languages. In MADS, it is possible to access procedure parameters externally,
which is unusual in higher-level languages. For instance, PAR1 can be read as follows:
</p>

<pre class="code">
 lda name.par1
 sta $a000
 lda name.par1+1
 sta $a000+1
</pre>

This copies the two bytes at PAR1 to addresses $A000 and $A000+1. Of course, this can only be
done after completion of this particular procedure. Remember that each procedure has parameters
stored at the same area addressed by @PROC_VARS_ADR, so with each new procedure call
the parameter area at &lt;@PROC_VARS_ADR
.. @PROC_VARS_ADR + $FF&gt; changes.

<p>
If a procedure is declared using .REG type parameters, the programmer should remember to
preserve or use parameters before they are modified by the procedure code. With .VAR type
parameters, this is not an issue because the parameters are saved in specific memory locations
where they can always be read.
</p>
</div>

<div id="locals">
<h1>LOCAL AREA</h1>
The main purpose of a local area in MADS is to create a new scope for labels.<br/>
All labels defined in a .LOCAL area are local. However, you can still refer to a local
label globally, which is uncommon in other programming languages..<br/>
It is possible to define a global label within a .LOCAL area
(see <a href="#labels_glo">Global labels</a>). .<br/>
If the assembler cannot find a label within a .LOCAL area, MADS will then look
in the global scope. To refer to global labels directly from a .LOCAL area, prefix
the label name with a colon (':')..<br/>

<h2 id="obszar_lok">Declaring .LOCAL scopes</h2>

<p>
Local scope directives:
</p>
<pre class="code">
 [name] .LOCAL [,address]
 .LOCAL [name] [,address]
 .ENDL [.LEND] [.END]
</pre>

<h3>[name] .LOCAL [,address]</h3>
<p>
Declares a local scope named <b>name</b> with the directive <b>.LOCAL</b>.
The local scope name is not required and can be omitted. Local scope names cannot be the same
as mnemonics and pseudo-commands, and attempting to use a reserved name will result in a
<b>Reserved word</b> error.
</p>

<p>
After the name of the local scope (or the .LOCAL directive), a new assembly address can be
provided. After the end of the block (.ENDL), the assembly address reverts to the previous
address plus the length of the block.
</p>

<pre class="code">
label .local,$4000
.endl

.local label2,$8000
.endl

.local
.endl

.local label3
.endl
</pre>

All definitions within a <b>.LOCAL</b> block are local. To refer to a global label with
the same name as a local name, prefix the name with a colon (':'):

<pre class="code">
lab equ 1

.local

lab equ 2

 lda #lab
 ldx #:lab

.endl
</pre>

In this example, the A register is set to 2, while the X register is set to 1.

<p>
If the assembler cannot find a label in a <b>.LOCAL</b> scope, it will then check
an enclosing macro (if one is being processed), then the enclosing procedure (if there is one),
and finally the main program at global scope.
</p>

Within a local scope, all label definitions are qualified by the local scope's name. To reach
labels defined in another local scope, both the name of the local scope and the label must be
supplied:

<pre class="code">
 lda #name.lab1
 ldx #name.lab2

.local name

lab1 = 1
lab2 = 2

.endl
</pre>

<p>
A dot ('.') is used to address labels within a <b>.LOCAL</b> block.
</p>

<p>
Local scopes can be nested, as well as placed within procedures declared using
the <b>.PROC</b> directive. Local scopes are cumulative, i.e. there may
be multiple scopes of the same name and all symbols in those scopes will belong
to a common namespace.
</p>


<h3>.ENDL</h3>
<p>
The <b>.ENDL</b> directive ends a local scope.
</p>

<pre class="code">
Example: local scope declaration

 org $2000
 
tmp ldx #0   &lt;-------------   label in global scope
                          |
 lda obszar.pole  &lt;---    |   reference to local scope
                     |    |
.local obszar        |    |   local scope declaration
                     |    |
 lda tmp   &lt;---      |    |
              |      |    |
 lda :tmp     |      | &lt;---   reference to global scope
              |      |
tmp nop    &lt;---      |        definition in local scope
                     | 
pole lda #0       &lt;---   &lt;--- definition in local scope
                            |
 lda pole  &lt;----------------- reference within local scope

.endl                         end of local scope
</pre>

</div>

<div id="syntax">
<h1>SYNTAX</h1>
MADS accepts the same syntax as QA and XASM.
However, it is stricter with comments placed at the end of a line (comments
should be preceded the appropriate symbol) and more lenient with
whitespace and CPU instruction mnemonics without arguments, i.e.:

<pre class="code">
   asl            -&gt; asl @
   lda #          -&gt; lda #0
</pre>

MADS will accept missing white spaces between the mnemonic and operand, provided
that the operand does not start with a '@', which is used in the names
of labels, or '%' and ':', which are used to denote numbered macro
parameters (%%number, :number), e.g.:

<pre class="code">
   lda$44
   lda#
   lda(80),y
</pre>

<div id="comments">
<h2>Comments</h2>

Comment lines must start with a ';' or '*'.
For a single-line comment, however, the safest way is to use a semicolon (';'),
as the asterisk ('*') has other meanings and can mean multiplication or
the current assembly address. On the other hand, the semicolon is dedicated only
for comments.

<p></p>

The characters '//' can also be used for a single-line comment, and
'/* */' for a multi-line or inline comment.

<pre class="code">
 * this is a comment
                 ; This is a comment
 lda #0      ; This is a comment
 dta  1 , 3     * BAD COMMENT, WILL BE MISINTERPRETED

 org $2000 + 1      BAD COMMENT, WILL BE MISINTERPRETED

 nop // this is a comment

 // this is a comment

 dta 1,2, /* comment */ 3,4

 lda /* comment */ #0

/*
  ...
  this is a multi-line comment
  ...
*/

/************************************
  this is also a multi-line comment
*************************************/
</pre>

The multi-line comment signs '/* */' and the end-line comment sign '//' can be used without restrictions.
</div>

<div id="combining_multiple_lines">
<h2>Combining multiple lines into a single line</h2>

Multiple lines can be combined into a single line using '\', e.g.:

<pre class="code">
  lda 20\ cmp 20\ beq *-2
  lda 20   \ cmp  20   \   beq *-2
  lda #0  \lop  sta $a000,y  \ iny  \ bne lop     ; Comments only at the end of this line
</pre>

<p>
If there is no space after the '\' character, a mnemonic or other string can be
interpreted as a label, so make sure to treat '\' as the beginning of a new line.
</p>

<p>
MADS stops processing the line once either at the end of the chain or when a comment is reached,
so comments can be placed only at the end of the line.
</p>

<b>WARNING:</b> Putting a '\' at the end of a line tells MADS to combine the current line with the next line. 

<pre class="code">
Exmaple: Combining lines
  lda\
  #\
  12
</pre>

In this case, we get the result 'LDA #12'.
</div>

<div id="combining_multiple_mnemonics">
<h2>Combining multiple mnemonics</h2>

XASM already provided the ability to combine two mnemonics using a ':'.
In MADS, this is extended to combine any number of MADS-known mnemonics:

<pre class="code">
 lda:cmp:req 20

 lda:iny:sta:iny $600,y
</pre>

<p class="editors-note">
(Editor's note: All mnemonics in a combined statement are processed with the same argument.
This is fine when some of the instructions only have implied addressing. However, it can lead
to accidents with instructions that have both implied and memory forms. For instance,
"STA:INC:RNE pixels,X+"
will assemble as STA pixels,X / INX / INC pixels,X / INX / BNE *.)
</p>

</div>
</div>

<div id="expressions">
<h1>EXPRESSIONS</h1>

The term <b>expression</b> means a series of operators and operands (arguments) that
specifies the order of operations, i.e. type and order of evaluation. A compound expression
is an expression with two or more operators. Operators that affect only one operand are
called unary, and operators with two arguments are called binary.
<p>
Expressions are evaluated in the order determined by priority of each operator in the
direction specified by the precedence of each operator.
</p>
<div id="numbers">
<h2>NUMBERS</h2>

<p>
MADS accepts numbers in decimal, hexadecimal, binary, ATASCII, and INTERNAL
format.
</p>

decimal notation:
<pre class="code">
  -100
  -2437325
  1743
</pre>

hexadecimal notation:
<pre class="code">
  $100
  $e430
  $000001
 
  0x12
  0xa000
  0xaabbccdd
</pre>

binary notation:
<pre class="code">
  %0001001010
  %000000001
  %001000
</pre>

ATASCII code:
<pre class="code">
  'a'
  'fds'
  'W'*
</pre>


INTERNAL code:
<pre class="code">
  "B"
  "FDSFSD"
  "."*
</pre>

Only the first character of ATASCII or INTERNAL coding is significant. A '*' after the closing
quote specifies inverse characters.
<p></p>
Additionally, there are two possible operations '+' and '-' for strings, which increase or decrease the
values of the quoted characters.

<pre class="code">
  "FDttrteSFSD"-12
  'FDSFdsldksla'+2
</pre>
</div>

<div id="operators">
<h2>Operators</h2>

<pre>
Binary operators:

+   Addition
-   Subtraction
*   Multiplication
/   Division
%   Remainder
&amp;   Bitwise and
|   Bitwise or
^   Bitwise xor
&lt;&lt;  Arithmetic shift left
&gt;&gt;  Arithmetic shift right
=   Equal
==  Equal (same as =)
&lt;=  Not equal
!=  Not equal (same as &lt;&gt;)
&lt;   Less than
&gt;   Greater than
&lt;=  Less or equal
&gt;=  Greater or equal
&amp;&amp;  Logical and
||  Logical or


Unary operators:

+  Plus (does nothing)
-  Minus (changes sign)
~  Bitwise not (complements all bits)
!  Logical not (changes true to false and vice versa)
&lt;  Low (extracts low byte)
&gt;  High (extracts high byte)
^  High 24bit (extracts high byte)
=  Extracts memory bank
:  Extracts global variable value


Operator precedence:

first []              (brackets)
 + - ~ &lt; &gt;            (unary)
 * / % &amp; &lt;&lt; &gt;&gt;        (binary)
 + - | ^              (binary)
 = == &lt;&gt; != &lt; &gt; &lt;= &gt;= (binary)
 !                    (unary)
 &amp;&amp;                   (binary)
last  ||              (binary)
</pre>

</div>
</div>

<div id="labels">
<h1>LABELS</h1>

Labels may be defined in the program with local or global scope, depending
on the location where they are defined. Additionally, labels may be defined
as temporary, also with local or global scope.


<ul>
<li>A <b>global label</b> is visible from anywhere in the program,
even within a macro (<b>.MACRO</b>), procedure (<b>.PROC</b>),
or local scope (<b>.LOCAL</b>).
</li>


<li>A <b>local label</b> is only visible within the <b>.MACRO</b>,
<b>.PROC</b>, or <b>.LOCAL</b> scope in which it is defined.
</li>
</ul>

<ul>
<li>Label names must begin with ['A'..'Z','a'..'z','_','?','@'].</li>
<li>The rest of the label name may contain ['A'..'Z','a'..'z','0'..'9','_','?','@'].</li>
<li>Labels are always at the beginning of a line.</li>
<li>A label preceded by whitespace should end in a ':' to avoid misinterpretation as a macro.</li>
<li>In addressing expressions, prefixing a label with ':' tells the assembler to refer to the
    label in the main program (global label).</li>
</ul>

<pre class="code">
Example: label definitions

?name    EQU  $A000      ; Defining a temporary global label
name      =   *          ; Defining a global label
name2=12                 ; Defining a global label
@?name   EQU  'a'+32     ; Defining a global label
  name: equ 12           ; Defining a non-global label that does not start at the beginning of the line
         name: = 'v'     ; Defining a non-global label that does not start at the beginning of the line
</pre>

Unlike QA/XASM, a question mark ('?') and at-sign ('@') can be used in label names.
<p>


Using a dot ('.') in a label name is allowed but not recommended. The dot is reserved for
extended mnemonics, assembler directives, and addressing new MADS structures.</p>

<p>
A dot ('.') at the beginning of a label name suggests that it is an assembler
directive, and a question mark ('?') at the beginning signifies a temporary
label that can be changed several times during assembly.
</p>


<div id="labels_anm">
<h2>Anonymous labels</h2>

To ensure clarity when using anonymous labels, their use is limited only to jumps
no more than 10 instances away.

<p>
The character '@' is reserved for anonymous labels, and there must be a sign
character indicating either forward direction ('+') or backwards direction ('-').
Additionally, you can specify the number of anonymous labels in the range [1..9].
</p>

<pre class="code">
 @+[1..9]     ; Forward
 @-[1..9]     ; Backward

@ dex   ---- -------
  bne @+   |  --   |
  stx $80  |   |   |
@ lda #0   |  --   |
  bne @- ---       |
  bne @-1  ---------
</pre>
</div>

<h2 id="labels_lok">Local labels</h2>

<p>
Labels defined within a macro (<b>.MACRO</b>), procedure (<b>.PROC</b>),
or local scope (<b>.LOCAL</b>) are local labels by default and do not
need additional markup.
</p>

Local labels are defined using the following equivalent pseudo-commands:
<pre class="code">
 EQU
  =
</pre>

To access global labels, i.e. those defined outside of a macro (<b>.MACRO</b>),
procedure (<b>.PROC</b>), or local scope (<b>.LOCAL</b>), use the
':' operator:
<pre class="code">
lp   ldx #0         ; Define global label LP

     test
     test
 
test .macro

      lda :lp       ; The ':' prefix causes reference to the global label LP

      sta lp+1      ; Reference to the local label LP in the macro
lp    lda #0        ; Definition of local label LP in the macro

     .endm
</pre>

In this example, there are two definitions of labels with the same name (LP),
but each has a different value and a different scope.

<h2 id="labels_glo">Global labels</h2>

<p>
Each definition outside of a macro (<b>.MACRO</b>), procedure (<b>.PROC</b>),
or local scope (<b>.LOCAL</b>) is global.
</p>

Global labels are defined using the following equivalent pseudo-commands:
<pre class="code">
 EQU
  =
</pre>

Or with .DEF directive syntax:
<pre class="code">
 .DEF :label [= expression]
</pre>

<p>
The .DEF directive normally defines local labels, but the ':' at the beginning
of the label indicates a global label instead. Using the syntax <b>.DEF :label</b>
allows definition of global labels within a local scope.
</p>

<b>
The ':' at the beginning of the label has special meaning and indicates a global
label, or label at mainline level, disgarding any current local scopes.
</b>

<p>
For more information on use of the .DEF directive, see <a href="#_def">.DEF Directive</a>.
</p>

<pre class="code">
Example: defining global labels

lab equ *
   lab2 equ $4000

	?tmp = 0
	?tmp += 40
 
.proc name

      .def :?nazwa   = $A000
           .def :nazwa=20

      .local lok1
        .def :@?nazw   = 'a'+32
      .endl

.endp
</pre>

Examples of defining a global temporary labels include the macro <b>@CALL</b>
in the file "..\EXAMPLES\MACROS\@CALL.MAC", which defines the temporary label
<b>?@STACK_OFFSET</b>. This is later used by other macros called
called by the macro <b>@CALL</b>, and is used to optimize access to
parameters on the stack.

<pre class="code">
@CALL .macro

  .def ?@stack_offset = 0    ; Definition of temporary global lavel ?@stack_offset
 
  ...
  ...
 
 
@CALL_@ .macro

  sta @stack_address+?@stack_offset,x
  .def ?@stack_offset = ?@stack_offset + 1    ; Modify ?@stack_offset label

 .endm 
</pre>


<h2 id="labels_set">Temporary labels</h2>

A temporary label has the property that its value can be changed many times
during assembly. Normally, attempting to redefine a label results in a
<b>Label declared twice</b> error, which does not occur with a
temporary label.

<p>
The lifetime of a temporary label depends on the scope in which it is defined.
Temporary labels may have local scope (<a href="#labels_lok">Local labels</a>) or global scope
(<a href="#labels_glo">Global labels</a>).
</p>

A temporary label is created by placing a '?' at the beginning:
<pre class="code">
 ?label
</pre>

<b>
Temporary labels should not be used to name procedures (.PROC), macros
(.MACRO), local scopes (.LOCAL), structures (.STRUCT),
or arrays (.ARRAY).
</b>

<p></p>

A temporary label is defined using one of the following equivalent pseudo-commands:
<pre class="code">
 EQU
  =
</pre>

Additionally, they can be modified using recognizable C operators:
<pre class="code">
 -= expression
 += expression
 --
 ++
</pre>

These assignment operators only work with temporary labels, and attempting to
use them for other types of labels results in the error message <b>Improper syntax</b>.

<p></p>

<pre class="code">
Example: temporary labels

?loc = $567
?loc2 = ?loc+$2000

	 lda ?loc
	 sta ?loc2

?loc = $123

	 lda ?loc
</pre>

<h2 id="labels_mae">MAE-style temporary labels</h2>

Option <b>OPT ?+</b> tells MADS that labels starting with <b>'?'</b> should be interpreted
as local labels as MAE does. By default, labels starting with <b>'?'</b> are interpreted by
MADS as temporary labels (<a href="#labels_set">Temporary labels</a>).

<pre class="code">
Example: MAE-style temporary labels

       opt ?+
       org $2000

local1 ldx #7
?lop   sta $a000,x
       dex
       bpl ?lop

local2 ldx #7
?lop   sta $b000,x
       dex
       bpl ?lop
</pre>

</div>

<div id="sdx">
<h1>SPARTADOS X</h1>

<div id="dos_file_fomats">
<h2>SpartaDOS X and Atari DOS file formats</h2>

Reproduced from Serious Magazine, author Qcyk/Dial.

<p>
A file itself is only a collection of bytes, lots of numbers that can mean
both everything and nothing at the same time if you do not know how to
interpret them. For this reason, most files are equipped with a variety of
headers which store information about what the file contains and are
necessary to read them. This includes binary executables loaded under DOS.
After all, DOS is a program and like everyone else has a right to expect
a certain structure in its data.
</p>

Traditional binary files, recognized by all DOSes for Atari XL/XEs, are built
of blocks where each block has its own header. There are two types of headers:

<pre class="code">
 1. dta a($ffff),a(str_adr),a(end_adr)

 2. dta a(str_adr),a(end_adr)
</pre>

<p>
<b>str_adr</b> - address at which the first byte of data will be loaded
</p>

<p>
<b>end_adr</b> - address at which the last byte of data will be loaded
</p>


<p>
The first block in the file header must be $ffff, followed by other blocks. Each block
header should of course be followed by this amount of data:
</p>

<pre class="code">
   (end_adr-str_adr)+1
</pre>

<p>

That's enough of a refresher. The developers of SpartaDOS X have kept the above standard, while
adding several new types of headers. The file is still divided into blocks, except that now there
are a lot more types of blocks. Here they are:
</p>

<h4>1. Non-relocatable block (loaded at fixed address in memory):</h4>
<pre>
    dta a($fffa),a(str_adr),a(end_adr)
</pre>
<p>
This is the same as a $ffff block - it does not matter which you use. However, $fffa
will clearly indicate that the program is designed for SDX - another DOS cannot
read the file.
</p>

<h4>2. Relocatable block (loaded starting at MEMLO):</h4>
<pre>
    dta a($fffe),b(blk_num),b(blk_id)
    dta a(blk_off),a(blk_len)
</pre>
<p>
<b>blk_num</b> - block number in the file. Each relocatable block should have its own
number. Because the load addresses of blocks are not known, blocks are just identified by number.
They may be in the range [0..7], except that in practice they are usually numbered from 1 upwards.
</p>

<b>blk_id</b> - bits 1-5 are the memory type, indicating where the block is to be loaded.
I have encountered two values:
<pre>
 $00 - main memory
 $02 - extended memory
</pre>
Also, bit 7 indicates no data block if set. In this case, SDX loads nothing, but
still reserves memory.

<p>     
<b>blk_off</b> - block base address, which is simply the address at which the code was
assembled. This is necessary when relocating addresses referring to the contents of the block.
</p>

<p> 
<b>blk_len</b> - the length of the block. There should be as much data following as indicated
by the header, unless the block is only a reserved area in which case there is no data.
</p>

When writing relocatable code, several limitations imposed by the idea of "relocatable code" must be
kept in mind. All addresses referring to program areas must be updated during load, so sequences
such as this cannot be used:

<pre class="code">
       lda &lt;something
       ldx &gt;something
       ...
      something equ *
       ...
    Instead, use something like this, for example:
       lda _something
       ldx _something+1
       ...
      _something dta a(something)
       ...
      something equ *
</pre>


<h4>3. Update addresses in a block referring to a relocatable block:</h4>
<pre>
    dta a($fffd),b(blk_num),a(blk_len)
</pre>

<p>
<b>blk_num</b> - number of block containing the reference targets
</p>

<p>
<b>blk_len</b> - update block length (without the header). This is ignored.
</p>

Addresses are updated by adding the difference between the address at which the relocatable
block was loaded and the value of blk_off (where the block was originally assembled). This
can be illustrated as follows:
<pre class="code">
       adr=adr+(blk_adr-blk_off)
</pre>

The payload of an update block contains pointers to addresses and special commands. Numbers
between $00-$fb are offsets from the last updated location. This location is stored
as an address in an update pointer. This pointer can be updated through special functions
invoked by values greater than $fb:

<p>
<b>$fc</b>
marks the end of the update block,
</p>

<p>
<b>$fd,a(addr)</b>
directly updates the address ADDR. Thus, the update pointer is set to ADDR,
which is used as the base for the next offset,
</p>

<p>
<b>$fe,b(blk_num)</b>
sets the update pointer to the base address of the block specified by blk_num, which is
then used for the next offset,
</p>

<p>
<b>$ff</b>
increases the update pointer by $fa (without updating an address).
</p>
<br />


<h4>4. Update addresses in blocks targeting procedures with defined symbols:</h4>
<pre>
    dta a($fffb),c'SMB_NAME',a(blk_len)
</pre>

<p>
<b>SMB_NAME</b> - procedure symbol name (or array, system registry, etc.) Eight characters in ATASCII code,
</p>

<p>
<b>blk_len</b> - as in a $fffd block.
</p>

<p>
After the header, there is a sequence of offsets to locations of addresses to update - the same as
in a $fffd block. Addresses are updated by adding the address of the procedure denoted
by the symbol to the existing address. This allows use in programs of procedures whose addresses
are unknown, such as procedures added by other applications running in the SDX environment. Also,
system procedures must be used this way, as they have different addresses in different versions
of SpartaDOS.
</p>


<h4>5. Symbol definition block:</h4>
<pre>
    dta a($fffc),b(blk_num),a(smb_off)
    dta c'SMB_NAME'
</pre>

<p>
<b>blk_num</b> - number of the block in which the procedure is defined. This means that the procedure must be defined in a relocatable block.
</p>

<p>
<b>smb_off</b> - procedure offset in the block, which is an offset from the start of the block (the first byte is 0) plus the value
of blk_off of the block. Basically, the address at which the procedure was assembled.
</p>

<p>
SMB_NAME - symbol name being defined for the procedure.
</p>

<p>
Block types $fffb, $fffc, and $fffd are not kept in memory. The system uses them only during program load.
</p>
</div>

<div id="programming_spartados_x">
<h2>Programming SpartaDOS X (SDX)</h2>
<p>
The syntax for handling SpartaDOS X programs, was taken from FastAssemblera
by the author Marka Goderskiego. Below is a quote from the manual that came with FA.
MADS can now assemble source files in *.FAS format without any major problems.
Relocatable commands always have two-byte arguments; it is impossible to relocate 3-byte arguments
(65816).
</p>

<p>
The most important innovation in SDX is the ability for developers to write relocatable
code. Since the MOS 6502 does not have relative addressing (except for short branches),
the ICD developers created a way to do so using special program blocks. The process is
based on loading blocks and then updating addresses within the blcok using special update blocks.
It is enough to add the value of memlo to correct addresses, but what addresses to
correct, and which ones to leave? That's the point of a special block that contains (specially
coded) offsets to those addresses. Therefore, an <b>UPDATE ADDRESS</b> operation must
be applied to each <b>RELOC</b> block before running the program. <b>UPDATE ADDRESS</b>
must also be performed on any block which refers to <b>SPARTA</b> commands or vectors.
</p>

<p>
Another innovation is the introduction of symbols. Some of the SDX service
procedures are defined by name! These names always have 8 letters (like filenames).
Instead of using arrays of vectors or jumps (like in the OS), use symbols defined
with <b>SMB</b>. After loading a block or blocks, SDX loads symbol
blocks and updates symbol addresses the same way as with relocatable addresses in
the program. Symbols can refer to items in either <b>RELOC</b> or
<b>SPARTA</b> blocks.
</p>

<p>
Programmers can define custom symbols to replace the ones in SDX or completely new ones
for use by other programs. This is done by the <b>UPDATE NEW</b> block. It should
be kept in mind that new symbols must be stored in a <b>RELOC</b> block.
</p>

<p>
The number of <b>RELOC</b> and <b>EMPTY</b> blocks is limited to 7 by SDX.
</p>

Such blocks can be combined into chains:
<pre class="code">
       blk sparta $600
       ...

       blk reloc main
       ...

       blk empty $100 main
       ...

       blk reloc extended
       ...

       blk empty $200 extended
</pre>
This means that commands for these blocks can refer to all blocks in the chain.

<p>
The chain is not interrupted by updating addresses or symbols, but is ended by the definition
of a new symbol and by other block types, e.g. DOS.
</p>

<p>
<b>Note:</b> The chain only makes sense if all blocks are loaded into the same memory,
or when a program switches to the appropriate memory references.
</p>

<p>
<b>Note:</b> Commands and vectors in <b>RELOC</b> and <b>EMPTY</b>
blocks should not refer to <b>SPARTA</b> blocks! This may cause an error when the user
loads the program using the <b>LOAD</b> command and uses it after a long time. While
<b>RELOC</b> and <b>EMPTY</b> are safe, you never know what is in memory
where a <b>SPARTA</b> block was last loaded!
</p>

<p>
Equally dangerous is the references to <b>RELOC</b> and <b>EMPTY</b> blocks by <b>SPARTA</b> blocks
(for the same reason as above), but during the installation of overlays (*.sys) using
<b>INSTALL</b> this is sometimes necessary and therefore acceptable. You can also
invoke a <b>SPARTA</b> block (through $2E2) to run immediate, then
discard it.
</p>

<p>
<b>Note:</b> Addresses can collide between <b>SPARTA</b> blocks and
<b>RELOC</b>/<b>EMPTY</b> addresses! FA recognizes references to
other blocks by address, assuming a PC for <b>RELOC</b> and <b>EMPTY</b>
blocks of $1000, so for mixed programs <b>SPARTA</b> blocks should be below
$1000 (e.g. $600) or above the last relocatable block,
$4000 using being enough. This error is not detected by the compiler!
</p>
</div>


<div id="relocatable_code">
<h1>RELOCATABLE CODE</h1>

Relocatable code is code without a fixed address, such that when loaded into
a computer it has to work regardless of the load address. SpartaDOS X (SDX)
provides a relocation facility for Atari XL/XE code, of which more than be
read in the section <a href="#sparta">Programming SpartaDOS X</a>.
<p>
A basic limitation of SDX relocatable code is that only WORD addresses are relocated
and there is no support for 65816 code. MADS provides the ability to generate code
both in SDX format and in a non-SDX format that removes the aforementioned limitations.
</p>

<p>
The MADS relocatable code format is similar to that of SDX, as there are main blocks
and then blocks with additional address relocation information. MADS uses a simpler
update block format, without the "compression" used by SDX.
</p>

Advantages of MADS relocatable code:
<ul>
<li>supports operand sizes for both 6502 and 65816 CPUs</li>
<li>can use all CPU instructions without restriction</li>
<li>supports relocation of both high and low address bytes</li>
</ul>

Limitations of MADS relocatable code:
<ul>
<li>labels defined by EQU must precede .RELOC blocks</li>
<li>new labels defined in .RELOC blocks must have its name preceded by a space or tab (global label)</li>
<li>you cannot use the ORG, RMB, LMB, or NMB pseudo-commands, or the .DS directive</li>
<li>cannot relocate the highest byte of 24-bit words, i.e. lda ^$121416</li>
</ul>

An example of how easy it is to create relocatable code is in the file "..\EXAMPLES\TETRIS_RELOC.ASM",
which uses the CPU instruction set and data definition pseudo-commands no differently than
the non-relocatable version in the file "..\EXAMPLES\TETRIS.ASM".


<div id="relocatable_blocks">
<h2>Reloctable blocks (.RELOC)</h2>

A MADS relocatable block is created using the directive:

<pre class="code">
 .RELOC [.BYTE|.WORD]
</pre>

A block for updating a relocatable MADS block is created using the BLK pseudo-command:
<pre class="code">
 BLK UPDATE ADDRESS
</pre>

After the .RELOC directive, it is possible to specify a relocation block type (.BYTE, .WORD),
with the default being .WORD type. type <b>.BYTE</b> is for blocks that must be placed
in zero page (instructions will use zero page), which MADS will assemble to address <b>$0000</b>.
Type <b>.WORD</b> means that MADS will assemble the block starting at address <b>$0100</b> and that it
can be placed anywhere in memory (except for zero page).

<p>
The .RELOC block produces a header like the famous DOS header, further expanded by 10 bytes
to a total of 16 bytes:
</p>

<pre class="code">
HEADER            .WORD = $FFFF
START_ADDRESS     .WORD = $0000
END_ADDRESS       .WORD = FILE_LENGTH-1
MADS_RELOC_HEADER .WORD = $524D
UNUSED            .BYTE = $00
CONFIG            .BYTE (bit0)
@STACK_POINTER    .WORD
@STACK_ADDRESS    .WORD    
@PROC_VARS_ADR    .WORD
</pre>

<table cellspacing="2" cellpadding="2" border="2" frame="box" rules="all">
<tr>
	<td><b>MADS_RELOC_HEADER</b></td>
	<td>always $524D, corresponding to the characters 'MR' (M-ADS R-ELOC)</td>
</tr>
<tr>
	<td><b>FILE_LENGTH</b></td>
	<td>the length of the relocatable file without the 16-byte header</td>
</tr>
<tr>
	<td><b>CONFIG</b></td>
	<td>currently only bit 0 is used, where bit0=0 means relocatable blocks are assembled starting at <b>$0000</b>, and bit0=1 means blocks are assembled at <b>$0100</b>.</td>
</tr>
</table>

<p>
The last 6 bytes contain information about the values of labels needed for
the operation of the software stack, <b>@STACK_POINTER, @STACK_ADDRESS, and @PROC_VARS_ADR</b>,
if used in relocatable blocks. If the individual .RELOC blocks were assembled with
different values of these labels, linking them together will produce an <b>Incompatible stack parameters</b>
warning. If the software stack labels are not used, the values
are zero.
</p>

<p>
The pseudo-command .RELOC switches MADS to relocatable code generation mode, taking into
account the operand sizes of 6502 and 65816 instructions. In this mode, it is impossible
to use the <b>ORG, LMB, NMB, and RMB</b> pseudo-commands or the 
<b>.DS</b> directive. It is impossible to exit MADS relocatable code generation mode,
but it is possible to have more than one .RELOC block.
</p>

<p>
Using the .RELOC directive will also increase the MADS virtual bank counter, and thus
create a local scope not visible to other blocks. For more information on virtual banks,
see the section <a href="#virtual_memory_banks">Virtual memory banks (OPT B-)</a>.
</p>


<p>
At the end of a .RELOC block it is necessary to generate an update block, using the
same BLK syntax for SDX relocatable blocks ("BLK UPDATE ADDRESS"). The
encoding format for this block is different than for SDX and is as follows:
</p>

<pre class="code">
HEADER       word ($FFEF)
TYPE         char (B-YTE, W-ORD, L-ONG, D-WORD, &lt;, &gt;)
DATA_LENGTH  word
DATA         word [byte]
</pre>


<table cellspacing="2" cellpadding="2" border="2" frame="box" rules="all">
<tr>
	<td><b>HEADER</b></td>
	<td>always set to $FFEF</td>
</tr>
<tr>
	<td><b>TYPE</b></td>
	<td>data type is stored in bits 0..6 and specifies the type of addresses to update,
	where "&lt;" means the lower address byte and "&gt;" means the upper address byte.</td>
</tr>
<tr>
	<td><b>DATA_LENGTH</b></td>
	<td>number of 2-byte data items (addresses) to modify</td>
</tr>
<tr>
	<td><b>DATA</b></td>
	<td>offsets for updating the relocatable block, where at each address a value of type TYPE is read and then updated to the final address</td>
</tr>
</table>

<p>
The exception is an update block for address high bytes "&gt;", where for such a block
an extra BYTE is stored for each address (low byte of address being modified). To
adjust the high bytes, the high byte has to be read from the WORD address in the DATA,
added to the current relocation address, and then added to the low byte in the BYTE field of the DATA.
The newly calculated byte is then store back at the WORD address in the DATA.
</p>
</div>

<div id="labels_ext">
<h2>External symbols</h2>

<p>
External symbols indicate that the represented variables and procedures are stored
somewhere outside, beyond the current program. The location need not be specified, only
the names and the types. Since the translation of instructions to appropriate machine code
depends on the type of data represented by a symbol, the assembler needs to know the
size of the data used.
</p>

<b>Currently there is no support for manipulating external symbols of type '^' (highest byte).</b>


<p>
External symbols may be used in both relocatable .RELOC blocks as well as usual DOS ones.
</p>

External symbols are declared using the pseudo-command EXT or the .EXTRN directive:
<pre class="code">
label EXT type
label .EXTRN type
.EXTRN label1,label2,label3... type
</pre>

An update block for referencing external symbols is produced using the BLK pseudo-command:
<pre class="code">
 BLK UPDATE EXTERNAL
</pre>

<b>Note:</b> This will write symbol names used by the program.
<p>
External symbols of value type can also be defined (.BYTE, .WORD, .LONG , .DWORD):
</p>
<pre class="code">
name EXT .BYTE

label_name EXT .WORD

 .EXTRN label_name .WORD

wait EXT .PROC (.BYTE delay)
</pre>

External symbol declarations of procedure (.PROC) type default to .WORD, and attempts to
reference the label will be interpreted by MADS as an attempt to call the procedure.
For more about procedure calls, see <a href="#procedures">Procedures</a>.
<p>
During the assembly process, references to external symbols are replaced with the value zero.
</p>
<p>
External symbols can be useful when assembling part of a program separately from the rest of it.
In this case, there are often references to other procedures and variables are defined
elsewhere, and only the type and not value are known. With the help of external symbols, such
a program can be assembled without the full procedure and variable definitions.
</p>
<p>
Another use for external symbols is for "plugins", or external programs connected to the
main program to add additional functionality. These are types of libraries, using the
procedures of the main program and expanding its capabilities. Creating such a plugin
requires determining what procedures the main program provides (their name + parameters
and type), and a procedure to read the file from the external symbols, which then
attaches the plugins to the main program.
</p>
<p>
The following is the format of the file header produced by BLK UPDATE EXTERNAL
for external symbols of type B-YTE, W-ORD, L-ONG, and D-WORD:
</p>

<pre class="code">
HEADER        word ($FFEE)
TYPE          char (B-YTE, W-ORD, L-ONG, D-WORD, &lt;, &gt;)
DATA_LENGTH   word
LABEL_LENGTH  word
LABEL_NAME    ATASCII string
DATA          word .. .. ..
</pre>

<table cellspacing="2" cellpadding="2" border="2" frame="box" rules="all">
<tr>
	<td><b>HEADER</b> </td>
	<td>always set to $FFEE</td>
</tr>
<tr>
	<td><b>TYPE</b> </td>
	<td>bits 0..6 contain the type of data to modify</td>
</tr>
<tr>
	<td><b>DATA_LENGTH</b> </td>
	<td>number of 2-byte data items (addresses) to modify</td>
</tr>
<tr>
	<td><b>LABEL_LENGTH</b> </td>
	<td>symbol name length in bytes</td>
</tr>
<tr>
	<td><b>LABEL_NAME</b> </td>
	<td>the symbol name, coded in ATASCII</td>
</tr>
<tr>
	<td><b>DATA</b> </td>
	<td>offset data for the relocation process. At each indicated address here, the value of type TYPE is read and then based on the actual value of the symbol.</td>
</tr>
</table>


<p id="_prz_str">
An applied example of external symbols and .STRUCT structures is the graphical
primitives library in the directory "..\EXAMPLES\LIBRARIES\GRAPHICS\LIB". Individual
modules use a fairly large number of zero page variables, and if we want to place these
in relocatable code each individual variable would have to be declared as an external
symbol by EXT (or .EXTRN). We can simplify this by using only one symbol and external
data of structure (.STRUCT) type. These structures define a "map" of variables called
ZP and one ZPAGE external symbol, of type <b>.BYTE</b> because we want it to be in zero page.
Now, when referring to the variable, we need to do it in a way that forces relocation
such as ZPAGE + ZP.DX. The result is a fully relocatable module with relocated variables
in zero page.
</p>
</div>

<div id="labels_pub">
<h2>Public symbols</h2>

<p>
Public symbols make variables and procedures available to other blocks in the rest
of the relocatable assembly program. With public symbols, you can refer to variables
and procedures from libraries.
</p>

<p>
Public symbols can be used in relocatable .RELOC blocks as well as usual DOS blocks.
</p>


<p>
MADS automatically detects whether a public label is a variable, constant, or
procedure defined by .PROC, and does not need any additional information as for
external symbols.
</p>

Public symbols are declared using the following directives:
<pre class="code">
 .PUBLIC label [,label2,...]
 .GLOBAL label [,label2,...]
 .GLOBL label [,label2,...]
</pre>

The directives .GLOBAL and .GLOBL have been added for compatibility with other
assemblers. They are identical in meaning to .PUBLIC directive.
    <p></p>

Update blocks for public symbols are created using the BLK pseudo-command:
<pre class="code">
 BLK UPDATE PUBLIC
</pre>

<p>
Below is the header format produced by BLK UPDATE PUBLIC:
</p>

<pre class="code">
HEADER        word ($FFED)
LENGTH        word
TYPE          byte (B-YTE, W-ORD, L-ONG, D-WORD)
LABEL_TYPE    char (C-ONSTANT, V-ARIABLE, P-ROCEDURE, A-RRAY, S-TRUCT)
LABEL_LENGTH  word
LABEL_NAME    ATASCII string
ADDRESS       word
</pre>

MADS automatically selects the appropriate type for public labels:
<pre class="code">>
C-ONSTANT  label is not subject to relocation
V-ARIABLE  label is subject to relocation
P-ROCEDURE procedures defined by .PROC, subject to relocation
A-RRAY     array defined by .ARRAY, subject to relocation
S-TRUCT    structure defined by .STRUCT, not subject to relocation
</pre>

If the symbol is of structure (.STRUCT) type, this additional information is saved
(the type of the structure, name of the structure, and number of elements of
the structure):

<pre class="code">
STRUCT_LABEL_TYPE    char (B-YTE, W-ORD, L-ONG, D-WORD)
STRUCT_LABEL_LENGTH  word
STRUCT_LABEL_NAME    ATASCII string
STRUCT_LABEL_REPEAT  word
</pre>

If the symbol is of array (.ARRAY) type, this additional information is saved
(maximum element index, declared element type):

<pre class="code">
ARRAY_MAX_INDEX  WORD
ARRAY_TYPE       CHAR (B-YTE, W-ORD, L-ONG, D-WORD)
</pre>

If the symbol is of procedure (.PROC) type, this additional information is saved,
regardless of whether the procedure does or does not declare parameters:

<pre class="code">
PROC_CPU_REG  BYTE (bits 00 - regA, 01 - regX, 10 - regY)
PROC_TYPE     BYTE (D-EFAULT, R-EGISTRY, V-ARIABLE)
PARAM_COUNT   WORD
</pre>

<p>
.REG symbols of the procedure are then included, of PARAM_COUNT count:
</p>

<pre class="code">
PARAM_TYPE    CHAR (B-YTE, W-ORD, L-ONG, D-WORD)
...
</pre>

<p>
.VAR symbols of the procedure are included next along with their names, where
PARAM_COUNT specifies the total length of the data:
</p>


<pre class="code">
PARAM_TYPE    char (B-YTE, W-ORD, L-ONG, D-WORD)
PARAM_LENGTH  word
PARAM_NAME    ATASCII string
...
</pre>


<table cellspacing="2" cellpadding="2" border="2" frame="box" rules="all">
<tr>
	<td><b>HEADER</b></td>
	<td>always set to $FFED</td>
</tr>
<tr>
	<td><b>LENGTH</b> </td>
	<td>number of symbols stored in the update block</td>
</tr>
<tr>
	<td><b>TYPE</b></td>
	<td>type of symbol data: B-YTE, W-ORD, L-ONG, D-WORD</td>
</tr>
<tr>
	<td><b>LABEL_TYPE</b></td>
	<td>symbol type: V-ARIABLE, C-ONSTANT, P-ROCEDURE, A-RRAY, S-TRUCT
	<br />
	For type P, additional stored information: PROC_CPU_REG, PROC_TYPE, PARAM_COUNT, PARAM_TYPE
	<br />
    For type A, additional stored information: ARRAY_MAX_INDEX, ARRAY_TYPE
   <br />
    For type S, additional stored information: STRUCT_LABEL_TYPE, STRUCT_LABEL_LENGTH, STRUCT_LABEL_NAME, STRUCT_LABEL_REPEAT 
	</td>
</tr>
<tr>
	<td><b>LABEL_LENGTH</b> </td>
	<td>public symbol name length in bytes</td>
</tr>
<tr>
	<td><b>LABEL_NAME</b> </td>
	<td>public symbol name stored as ATASCII</td>
</tr>
<tr>
	<td><b>ADDRESS</b></td>
	<td>address assigned to the symbol in the relocatable .RELOC block. This value is relocated by adding its current assembly address.</td>
</tr>
<tr>
	<td><b>PROC_CPU_REG</b></td>
	<td>information about the .REG CPU register usage records for a procedure</td>
</tr>
<tr>
	<td><b>PROC_TYPE</b></td>
	<td>type of procedure:
<ul>
<li>D-EFAULT default type: parameters passed using MADS software stack</li>

<li>R-EGISTRY: procedure parameters passed using CPU registers (.REG)</li>

<li>V-ARIABLE: procedure parameters passed by variables (.VAR)</li>
</ul></td>
</tr>
<tr>
	<td><b>PARAM_COUNT</b></td>
	<td>information about the number of register-passed parameters (.REGs) or total length of type and name data for variable-passed parameters (.VARs)</td>
</tr>
<tr>
	<td><b>PARAM_TYPE</b></td>
	<td>parameter types, recorded using the characters 'B', 'W', 'L', 'D'</td>
</tr>
<tr>
	<td><b>PARAM_LENGTH</b></td>
	<td>parameter name length (.VAR)</td>
</tr>
<tr>
	<td><b>PARAM_NAME</b></td>
	<td>parameter name coded as ATASCII (.VAR)</td>
</tr>
</table>
</div>

<div id="linking">
<h2>Linking (.LINK)</h2>

<pre class="code">
 .LINK 'filename'
</pre>

The directive .LINK requires as a parameter the filename of the file to link. Only Atari DOS files
are accepted, not SDX files.

<p>
If the file load address is different than <b>$0000</b>, it means that the file does not contain
relocatable code, but may include update blocks for external and public symbols. The .LINK directive
accepts files at any address, but only those starting at <b>$0000</b> are subject to relocation.
More information on how to construct such a file is included in the section <a href="#_reloc">Relocatable blocks (.RELOC)</a>. 
</p>

<p>
The .LINK directive allows linking of relocatable and non-relocatable code. MADS automatically
relocates the file based on all three types of update blocks (ADDRESS, EXTERNAL, PUBLIC).
</p>

There is no limit to the address at which a file can be relocated.

<p>
If a block being relocated requires the MADS software stack, the labels @STACK_POINTER,
@STACK_ADDRESS, and @PROC_VARS_ADR are automatically updated based on the .RELOC block header.
It is necessary that the main program and the .RELOC blocks operate on the same software stack.
</p>
</div>
</div>
</div>
<div id="mnemonics">
<h1>MNEMONICS</h1>

<h2 id="opcodes_8bit">Available 6502 opcodes</h2>

<pre class="code">
   LDA   LDX   LDY   STA   STX   STY   ADC   AND  
   ASL   SBC   JSR   JMP   LSR   ORA   CMP   CPY  
   CPX   DEC   INC   EOR   ROL   ROR   BRK   CLC  
   CLI   CLV   CLD   PHP   PLP   PHA   PLA   RTI  
   RTS   SEC   SEI   SED   INY   INX   DEY   DEX  
   TXA   TYA   TXS   TAY   TAX   TSX   NOP   BPL  
   BMI   BNE   BCC   BCS   BEQ   BVC   BVS   BIT  
</pre>

A mnemonic extension can be placed after a dot '.' for LDA, LDX, LDY, STA, STX, and STY:
<pre class="code">
   <b>.b</b> or <b>.z</b>                BYTE
   <b>.a</b> or <b>.w</b> or <b>.q</b>   WORD

e.g.:
   lda.w $80   ; AD 80 00
   lda   $80   ; A5 80
</pre>


<h2 id="opcodes_8bit_ill">Available illegal 6502 opcodes</h2>

<pre class="code">
   ASO   RLN   LSE   RRD   SAX   LAX   DCP   ISB
   ANC   ALR   ARR   ANE   ANX   SBX   LAS   SHA
   SHS   SHX   SHY   NPO   CIM
</pre>

<h2 id="opcodes_16bit">Available 65816 opcodes</h2>

Of course, all 6502 opcodes are available, as well as:

<pre class="code">
   STZ   SEP   REP   TRB   TSB   BRA   COP   MVN  
   MVP   PEA   PHB   PHD   PHK   PHX   PHY   PLB  
   PLD   PLX   PLY   RTL   STP   TCD   TCS   TDC  
   TSC   TXY   TYX   WAI   WDM   XBA   XCE   INA
   DEA   BRL   JSL   JML
</pre>

It is possible to use XASM-style a:, z:, and r: mnemonic extensions:
<pre class="code">
 XASM        MADS
 lda a:0     lda.a 0
 ldx z:0     lda.z 0

 org r:$40   org $40,*
</pre>

Mnemonic extensions can be placed after a dot ('.') for LDA, LDX, LDY, STA, STX, and STY:
<pre class="code">
   <b>.b</b> or <b>.z</b>                BYTE
   <b>.a</b> or <b>.w</b> or <b>.q</b>   WORD
   <b>.t</b> or <b>.l</b>                TRIPLE, LONG (24bit)

e.g.:
   lda.w #$00   ; A9 00 00
   lda   #$80   ; A9 80
</pre>

<p>
The following commands cannot have their operand given in absolute addressing form (some assemblers
do not require the '#' character, but MADS requires it):
</p>

<h3>#$xx</h3>
<pre>
   SEP   REP   COP
</pre>

<h3>#$xxxx</h3>
<pre>
   PEA
</pre>

<p>
Another exception is long indirect addressing mode, which is represented by square brackets [ ].
These brackets are used to group subexpressions, but if the assembler encounters the character
'[' first it is interpreted as the start of long indirect addressing, and if 65816 mode
is not enabled a <b>Illegal adressing mode</b> results. To "trick" the assembler, place
the character '+' before the '['.
</p>

<pre class="code">
 lda [2+4]     ; lda [6]
 lda +[2+4]    ; lda 6
</pre>
</div>

<div id="cpu_detection">
<h1>CPU DETECTION</h1>

<h2>Detecting the 6502 and 65816 CPUs</h2>

This example is taken from <a href="http://www.s-direktnet.de/homepages/k_nadj/cputest.html"> http://www.s-direktnet.de/homepages/k_nadj/cputest.html</a>.
The program is able to detect the presence of the following microprocessors: 6502, 65C02, and 65816.

<pre class="code">
/*
How to detect on which CPU the assembler code is running
(This information is from Draco, the author of SYSINFO 2.0)

You can test on plain 6502-Code if there is a 65c816 CPU, the 16-Bit processor avaible
in some XLs as a turbo-board, avaible. Draco told me how to do this:

First we make sure, whether we are running on NMOS-CPU (6502) or CMOS (65c02,65c816).
I will just show the "official" way which doesn`t uses "illegal opcodes":
*/

 org $2000

 opt c+

DetectCPU

 lda #$99
 clc
 sed
 adc #$01
 cld
 beq DetectCPU_CMOS

DetectCPU_02

 ldx #&lt;_6502
 ldy #&gt;_6502
 jsr $c642

 lda #0
 rts

DetectCPU_CMOS

 lda #0
 rep #%00000010		;reset Z bit
 bne DetectCPU_C816

DetectCPU_C02

 ldx #&lt;_65c02
 ldy #&gt;_65c02
 jsr $c642

 lda #1
 rts

DetectCPU_C816

 ldx &lt;_65816
 ldy &gt;_65816
 jsr $c642

 lda #$80
 rts

_6502   dta c'6502',$9b
_65c02  dta c'65c02',$9b
_65816  dta c'65816',$9b
</pre>

The next CPU detection example is limited to distinguishing a 6502 from a 65816
microprocessor. The program instructions are read differently by a 6502 than by a 65816.
A 6502 executes 'INC @' and a 'NOP' instead of 'XBA' followed by 'SBC #'.
With this "transparency" we can be assured that the program does not perform illegal operations and
correctly recognizes the correct CPU. The idea for this concise and very clever test comes from
Ullrich von Bassewitz.

<pre class="code">
  org $2000
 
  opt c+        ; 65816 enabled
 
  lda #0
  inc @         ; Increment accumulator
  cmp #1
  bcc cpu6502
 
 ; ultimate test for 65816 presence
 
  xba           ; Put $01 in B accu
  dec @         ; A=$00 if 65C02
  xba           ; Get $01 back if 65816
  inc @         ; Make $01/$02
  
  cmp #2
  bne cpu6502
 
cpu65816
  ldx &lt;text65816
  ldy &gt;text65816
  jsr print_text
  rts
  
cpu6502
  ldx &lt;text6502
  ldy &gt;text6502
  jsr print_text
  rts
 
text6502  dta c'6502',$9b
text65816 dta c'65816',$9b
</pre>
</div>

<div id="memory_banks">
<h1>MEMORY BANKS</h1>

For probably anyone who has ever worked with the 8-bit Atari architecture, the term "memory bank"
is associated with extended memory, divided into 16KB size banks, and switched in the address
range [$4000..$7FFF].
<p></p>

MADS can interpret banks this way (option <b>OPT B+</b>, <a href="#hardware_memory_banks">Hardware memory banks</a>),
but by default they are interpreted as virtual banks (option <b>OPT B-</b>, <a href="#virtual_memory_banks">Virtual memory banks</a>).

<p></p>
The following pseudo-commands apply to banks:
<pre class="code">
 LMB #value
 NMB
 RMB
</pre>

<h3 id="_lmb">LMB # (Load Memory Bank)</h3>
Sets the MADS bank counter to a value in the range [$00..$FF] (BANK = value):
<pre class="code">
 lmb #0
 lmb #bank
 lmb #5 , $6500      ; only with OPT B+
</pre>

<h3 id="_nmb">NMB (Next Memory Bank)</h3>
Increments the MADS bank counter (BANK = BANK + 1).

<pre class="code">
 nmb
 nmb  $6500          ; only with OPT B+
</pre>

<h3 id="_rmb">RMB (Reset Memory Bank)</h3>
Resets the MADS bank counter (BANK = 0).

<pre class="code">
 rmb
 rmb $3500           ; only with OPT B+
 rmb $8500           ; only with OPT B+
</pre>

During assembly, MADS assigns the current bank counter value to each newly defined
label. The programmer can affect the value of the bank counter through pseudo-commands.

<ul>
<li>Labels assigned with the MADS bank counter <b>=0</b> are <b>global</b>.</li>
<li>Labels assigned with the MADS bank counter <b>&gt;0</b> are <b>local</b>.</li>
</ul>

<h2 id="virtual_memory_banks">Virtual memory banks (OPT B-)</h2>

<p>
In MADS, the term "virtual memory bank" refers to any area designated by a newly defined
label set to the current value of the bank counter (the default bank counter is zero). That is,
a virtual memory bank is not necessary a memory area in the range [$4000..$7FFF],
but each label presents a code area of the program which has been assigned a code (bank counter value)
in the range <b>[$00..$FF]</b> with appropriate pseudo-commands for use by the programmer
(NMB, RMB, LMB).
</p>

<p>
The exceptions are .RELOC blocks, where the bank counter cannot be changed manually and is
automatically updated by MADS, incrementing it for each instance of the .RELOC directive.
Bank counter values are in the range <b>[$0001..$FFF7]</b>.
</p>

The programmer can read the bank counter value associated with a label using the equal operator '=':
<pre class="code">
label

 ldx #=label
</pre>

In this example, the <b>X</b> CPU register is set to the bank counter value associated
by MADS with the label LABEL.

<p></p>

Another useful operator is the colon (':') placed at the beginning of the label name,
which causes MADS to allow references to labels outside of the area specified by the
current MADS bank counter. Sometimes this may cause problems, such as if
there is more than one label with the same name in different local scopes or in areas with
a different virtual bank number.

<pre class="code">
 lmb #5

label5
 nop

 lmb #6

label6
 nop

 lda :label5
</pre>

In this example, without the operator ':' at the beginning of the label name in the instruction
'lda :label5' the error <b>ERROR: Undeclared label LABEL5 (BANK=6)</b> would result.

<p></p>
Virtual memory banks can be used to index an array containing values for the PORTB register.
This is the main use of the option <b>OPT B+</b>.

<h2 id="hardware_memory_banks">Hardware memory banks (OPT B+)</h2>

This mode of operation can be called "bank sensitive".

<p></p>
Hardware banks are an extension of virtual memory banks and are understood by MADS
as expanded memory banks in the range [$4000..$7FFF]. The pseudo-commands NMB, RMB, and LMB
are extended to call the macro @BANK_ADD, which can be found in the directory "..\EXAMPLES\MACROS\"".

<p></p>
In this mode of operation, MADS requires the definitions for the following macros:
<pre class="code">
 @BANK_ADD
 @BANK_JMP
</pre>

and requires label definitions with the names:

<pre class="code">
@TAB_MEM_BANKS
@PROC_ADD_BANK
</pre>

The <b>@TAB_MEM_BANKS</b> label specifies the address of an array with values to
write to the PORTB register for switching extended memory banks. You can take advantage
of pre-written expanded memory bank detection routines included with MADS, in the file "..\EXAMPLES\PROCEDURES\@MEM_DETECT.ASM".

<p></p>
The label <b>@PROC_ADD_BANK</b> is used by the macro @BANK_ADD and defines
the address of the code for switching extended memory banks.

<p></p>

The programmer can read the bank counter value associated with a label using the '=' operator:

<pre class="code">
label

 ldy #=label
</pre>

In this example, the Y register is set to the memory bank value associated with the
label LABEL by MADS.
<p>
If the MADS bank counter = 0:
</p>
<ul>
<li>program code must be placed outside of <b>[$4000..$7FFF]</b></li>
<li>newly defined labels in this area are global</li>
<li>all defined labels can be accessed without limitation, regardless of bank number</li>
<li>jumping into a bank is possible using the macro <b>@BANK_JMP</b> from the file "..\EXAMPLES\MACROS\@BANK_JMP.MAC");
    the parameter for this macro does not have to be preceded by the ':' operator</li>
</ul>

<p>
If the MADS bank counter &gt; 0:
</p>
<ul>
<li>program code must be within <b>[$4000..$7FFF]</b></li>
<li>newly defined labels in this area are local</li>
<li>only global labels and labels within the current bank can be accessed</li>
<li>the pseudo-commands LMB and NMB will call the macro <b>@BANK_ADD</b>, which creates a new
bank with the MADS extended memory bank counter and sets a new assembly address (defaults to <b>$4000</b>)</li>
<li>the pseudo-command RMB resets the MADS memory bank counter and sets a new assembly address outside of the bank (defaults to <b>$8000</b>)</li>
<li>jumping to another bank is possible using the macro <b>@BANK_JMP</b> from the file "..\EXAMPLES\MACROS\@BANK_JMP"; the parameter
for this macro does not have to be preceded by the ':' operator</li>
</ul>
<p>
An example of the use of MADS bank sensitive mode can be found in the file "..\EXAMPLES\XMS_BANKS.ASM".
In this example, the program code is located in two different extended memory banks and runs as if it
were a single program.
</p>
</div>

<div id="history">
<h1>HISTORY</h1>

<div class="tekst-wiekszy" id="v1.9.5">
v1.9.5
<div class="tekst">
- added pseudo-command SET to redefine labels, with a similar effect as temporary labels that begin with '?', e.g.:
<pre>
temp set 12

     lda #temp

temp set 23

     lda #temp
</pre>
</div>
<div class="tekst">
- added ability to force addressing mode in XASM-style ('a:', 'z:'):
<pre>
 XASM        MADS
 lda a:0     lda.a 0
 ldx z:0     lda.z 0
</pre>
</div>
<div class="tekst">
- added ability to specify a new code relocation address in XASM-style ('r:'):
<pre>
 XASM        MADS
 org r:$40   org $40,*
</pre>
</div>
<div class="tekst">
- improved performance of '-x Exclude unreferenced procedures' switch; .VAR variables are not allocated for unused procedures<br/>
- extended single-line syntax for :rept loops so that the loop counter can now be used as a parameter :1 (%%1):
<pre>
line0
line1
line2
line3

ladr :4 dta l(line:1)
hadr :4 dta h(line:1)
</pre>
</div>
<div class="tekst">
- added a warning message when unstable illegal 6502 opcodes are used, i.e. CIM<br/>
- added new functionality to pseudo-commands RUN and INI to retain the previous assembly address when assembling to $2E0 (RUN), $2E2 (INI)<br/>
- added support for anonymous labels @, @+[1..9] (forward), @-[1..9] (backward); for clarity, their use is limited only to conditional branches no more than 10 instances away:
<pre>
@ dex   ---- -------
  bne @+   |  --   |
  stx $80  |   |   |
@ lda #0   |  --   |
  bne @- ---       |
  bne @-1  ---------
</pre>
</div>
<div class="tekst">
- extended directives #IF and #WHILE to allow arguments declared by .VAR, whereas previously only a variable was allowed:
<pre>
 .var temp .word

 #if temp>#2100
 #end

 #if .word temp>#2100
 #end
</pre>
</div>
</div>

<div class="tekst-wiekszy" id="v1.9.4">
v1.9.4
<div class="tekst">
- dodana normalizacja cieek dla plikw, tak aby dziaay pod Unixami, znaki '\' zamieniane s na '/'<br/>
- poprawione przekazywanie dyrektyw jako parametrw do procedur i makr, dyrektywy nie byy rozpoznawane przy wczonym przeczniku -c (case sensitive)<br/>
- poprawione dziaanie .USE [.USING]<br/>
- dodana informacja w postaci ostrzeenia (WARNING) o etykiecie powodujcej nieskoczon ilo przebiegw asemblacji (INFINITE LOOP)<br/>
- dodany zapis dwch bajtw nagwka FF FF dla pliku zawierajcego blok o adresie adowania $FFFF<br/>
- komentarze po mnemonikach nie wymagajcych argumentu zostan potraktowane jako bd, wyjtkiem jest czenie rozkazw w stylu xasm poprzez znak ':', np.:
<pre>
 pla $00          -&gt; ERROR: Extra characters on line
 pha:pla $00      -&gt; OK
</pre>
</div>
<div class="tekst">
- rozszerzona skadnia makr o moliwo uywania parametrw w postaci nazw a nie tylko wartoci numerycznych-decymalnych, np.:
<pre>
.macro SetColor val,reg
 lda :val
 sta :reg
.endm

.macro SetColor2 (arg1, arg2)
 lda #:arg1
 sta :arg2
.endm
</pre>
</div>
<div class="tekst">
- naprawione definiowanie etykiet dla n/w sytuacji, pierwsza etykieta nie zostanie zignorowana
<pre>
temp  label = 100
</pre>
</div>
</div>

<div class="tekst-wiekszy" id="v1.9.3">
v1.9.3
<div class="tekst">
- poprawione przetwarzanie blokw .PROC, ktre w pewnych okolicznociach mogy zosta pominite podczas asemblacji<br/>
- poprawiony zapis BLK EMPTY dla plikw SDX jeli zastosowalimy deklaracj takiego bloku przez .DS<br/>
- poprawki dotyczce testowania koca linii<br/>
- dodane dyrektywy .FILESIZE, .SIZEOF jako odpowiednik dotychczasowej dyrektywy .LEN<br/>
- rozszerzona skadnia dla pl struktury .STRUCT, np.:
<pre>
.struct name
 .byte label0
 .byte :5 label1
 label2 .byte
 label3 :2 .word
.ends
</pre>
</div>
</div>

<div class="tekst-wiekszy" id="v1.9.2">
v1.9.2
<div class="tekst">
- moliwo okrelenia adresu dla .ZPVAR = $XX<br/>
- usprawnione odwoania do etykiet wyliczeniowych .ENUM, np. enum_label(field0, field1)<br/>
- dodana moliwo generowania bloku dla symboli zewntrznych BLK UPDATE EXTRN dla plikw DOS-a, poprzednio tylko dla plikw .RELOC, np.:
<pre>
  .extrn vbase .word
  org $2000
  lda #$80
  sta vbase+$5d

  blk update extrn
</pre>
</div>
<div class="tekst">
- dodany komunikat bdu "Could not use NAME in this context" w przypadku rozkazw odwoa do blokw .MACRO, .ENUM, .STRUCT<br/>
- poprawiony bd ktry uniemoliwia uycie 'EQU' w nazwie etykiety<br/>
- dodana dyrektywa .CB +byte,....., ostatni bajt cigu znakowego zapisywany jest w inwersie<br/>
- dodana obsuga segmentw poprzez dyrektywy .SEGDEF, .SEGMENT, .ENDSEG<br/>
- dodana nowa dyrektywa #CYCLE #N generujca kod 6502 o zadanej liczbie cykli N<br/>
- dodana obsuga nielegalnych rozkazw CPU 6502, przykad w pliku "..\EXAMPLES\TEST6502_ILLEGAL.ASM"<br/>
- uaktualnione pliki konfiguracyjne dla Notepad++ '..\syntax\Notepad++'<br/>
- poprawiony zapis pliku LST<br/>
- naprawiona alokacja pamici dla zmiennych strukturalnych, rozszerzona skadnia dla .STRUCT
<pre>
.struct LABEL
 x,y,z .word     // wiele zmiennych tego samego typu w jednej linii
 .byte a,b
.ends

.enum type
  a=1,b=2
.ende

.struct label2
  x type
  type y
.ends
</pre>
</div>
</div>

<div class="tekst-wiekszy" id="v1.9.0">
v1.9.0
<div class="tekst">
- naprawiony zapis linii z komentarzem  /* */ do pliku listingu *.LST, poprzednio takie linie nie byy zapisywane<br/>
- poprawka dla etykiet deklarowanych z linii komend -d:label, poprzednio takie etykiety widziane byy tylko w pierwszym przebiegu<br/>
- w przypadku addytywnoci blokw .LOCAL tylko pierwszy adres z takich blokw jest zapisywany<br/>
- poprawki dotyczce parsowania makr, poprzednio etykiety zaczynajce si od END mogy zosta zinterpretowane jako pseudo rozkaz END<br/>
- poprawka odczytu dla pustego pliku relokowalnego, poprzednio wystpowa bd 'Value out of range'<br/>
- poprawki dla .USING (.USE)
</div>
</div>

<div class="tekst-wiekszy" id="v1.8.8_1.8.9">
v1.8.8 - 1.8.9
<div class="tekst">
- uaktualniony silnik duchw programowych ..\EXAMPLES\SPRITES\CHARS o duchy 8x24<br/>
- w przypadku braku podania rozszerzenia pliku i braku istnienia takiego pliku dla ICL 'filename' zostanie domylnie przyjte rozszerzenie *.ASM ICL 'filename.asm'<br/>
- poprawione dziaanie komentarzy /* */ w blokach .MACRO i .REPT<br/>
- usunity bd uniemoliwiajcy poprawn asemblacj bloku #IF, #WHILE dla wyrae czonych przez .OR, .AND<br/>
- przeczniki w linii komend mog by poprzedzone tylko znakiem '-', poprzednio take '/' jednak byy problemy z dziaaniem tego znaku na MacOSX<br/>
- poprawiony zakres dziaania dyrektywy .USING, dla aktualnej przestrzeni nazw i kolejnych zawierajcych si w tej przestrzeni nazw
</div>
</div>

<div class="tekst-wiekszy" id="v1.8.6_1.8.7">
v1.8.6 - 1.8.7
<div class="tekst">
- usprawnione rozpoznawanie komentarzy /* */ w wyraeniach<br/>
- domylny adres dla .ZPVAR ustawiony na $0080, poprzednio $0000<br/>
- dodana nowa dyrektywa .ELIF jako krtszy odpowiednik dyrektywy .ELSEIF<br/>
- rozszerzone dziaanie dyrektywy .LEN o moliwo podania jako parametru nazwy pliku, zwracana jest wwczas dugo takiego pliku<br/>
- usprawnione dziaanie dyrektywy .DEF w wyraeniach warunku .IF (.IFDEF, .IFNDEF)
</div>
</div>

<div class="tekst-wiekszy" id="v1.8.5">
v1.8.5
<div class="tekst">
- dodane makro relokujce moduy RMT ...\EXAMPLES\MSX\RMT_PLAYER_RELOCATOR\<br/>
- dodany test skadni dla nie asemblowanych procedur .PROC gdy aktywny jest przecznik -x "Exclude unreferenced procedures"<br/>
- poprawione dziaanie przecznika "-d:label[=value]", podanie wartoci dla etykiety jest teraz opcjonalne, domylnie mads przypisze warto 1<br/>
- dyrektywy .DS i .ALIGN nie spowoduj alokacji zmiennych zdefiniowanych przez .VAR<br/>
- alokacja zmiennych .VAR przed nowym blokiem ORG nie nastpi jeli blok ORG znajduje si w bloku .LOCAL lub .PROC<br/>
- poprawione amanie wierszy znakiem '\' w cigach ograniczonych nawiasami ()<br/>
- usunity bd powodujcy relokowanie adresu dla wyraenia dyrektywy .ERROR (ERT)<br/>
- usunite zauwaone bdy przy parsowaniu parametrw linii komend<br/>
- usunite zauwaone bdy dotyczce optymalizacji dugoci kodu makro rozkazw MVA, MWA itp.<br/>
- poprawiony kod realizujcy zagniedanie blokw .PROC<br/>
- poprawiony kod realizujcy dziaanie pseudo rozkazw warunku IFT ELI ELS EIF<br/>
- dodany komunikat "'#' is allowed only in repeated lines" dla przypadkw uycia licznika ptli # (.R) poza ptl<br/>
- usunity bd powodujcy bdne alokowanie zmiennych zadeklarowanych przez dyrektyw .VAR podczas wykonywania makra<br/>
- w celu ujednolicenia skadni odwoania do etykiet typw wyliczeniowych moliwe s tylko poprzez znak kropki '.', poprzednio take przez '::'<br/>
- moliwe krtsze odwoania do typw wyliczeniowych enum_label(fields), np. :
<pre>
.enum typ
 val0 = 1
 val1 = 5
 val2 = 9
.ende

 lda #typ(val0|val2)  ; == "lda #typ.val0|typ.val2"
</pre>
</div>
<div class="tekst">
- rozszerzona skadnia dyrektywy .SAV, np.:
<pre>
 .sav 'filename',offset,length
 .sav 'filenema',length
 .sav [offset] 'filename',offset2,length
 .sav length
 .sav offset,length
</pre>
</div>
<div class="tekst">
- rozszerzona skadnia dyrektywy .ARRAY, w przypadku braku podania maksymalnego indeksu tablicy zostanie
  on obliczony na podstawie iloci wprowadzonych elementw, elementy mona wprowadza bez koniecznoci
  poprzedzenia ich indeksem [expression], np.:
<pre>
.array temp .byte
 1,4,6                  ; [0..2]   = 1,4,6
 [12] = 9,3             ; [12..13] = 9,3
 [5]:[8] = 10,16        ; [5..6]   = 10,16 ; [8..9] = 10,16
 0,0,\                  ; [14..17] = 0,0,1,1
 1,1
.enda                   ; 18 elementw, TEMP [0..17]
</pre>
</div>
<div class="tekst">
- dodana moliwo alokacji zmiennej typu strukturalnego przy pomocy dyrektyw .VAR i .ZPVAR, np.:
<pre>
.struct Point
 x .byte
 y .byte
.ends

 .var a,b,c Point
 .zpvar Point f,g,i
</pre>
</div>
<div class="tekst">
- dodana moliwo alokacji zmiennej typu wyliczeniowego przy pomocy dyrektyw .VAR i .ZPVAR, np.:
<pre>
.enum Boolean
 false = 0
 true = 1
.ende

 .var test Boolean
 .zpvar Boolean test
</pre>
</div>
<div class="tekst">
- dodana moliwo deklaracji pl struktury przy pomocy typw wyliczeniowych, np.:
<pre>
.enum EState
  DONE, DIRECTORY_SEARCH, INIT_LOADING, LOADING
.ende
 
.struct SLoader
    m_file_start .word
    m_file_length .word
 
    m_state EState
.ends
</pre>
</div>
</div>

<div class="tekst-wiekszy" id="v1.8.3_1.8.4">
v1.8.3 - 1.8.4
<div class="tekst">
- nowy silnik duchw programowych z minimalnymi wymaganiami pamici, bez dodatkowych buforw pamici obrazu ...EXAMPLES\SPRITES\CHARS_NG<br/>
- nowa wersja pakera Huffmana (kompatybilna z Free Pascal Compiler-em, "fpc -MDelphi sqz15.pas") i dekompresora Huffmana SQZ15 ...EXAMPLES\COMPRESSION\SQUASH<br/>
- poprawiony kod generowany dla rozkazw MVP, MVN, PEA, BRA (CPU 65816)<br/>
- dodane nowe rozkazy BRL, JSL, JML (CPU 65816), jako odpowiedniki rozkazw dugich skokw BRA, JSR, JMP<br/>
- blok aktualizacji etykiet zewntrznych (external) zosta rozszerzony o zapis modszego i starszego bajtu adresu takiej etykiety<br/>
- poprawione dziaanie dyrektywy .USE (.USING), dziaa niezalenie od przestrzeni nazw w ktrej zostanie uyta<br/>
- usunity bd, ktry powodowa w pewnych sytuacjach pomijanie asemblacji bloku #IF, #WHILE<br/>
- dodana moliwo definiowania zmiennych poprzez dyrektyw .DS lub pseudo rozkaz ORG przed blokiem .RELOC<br/>
- dodana dodatkowa forma skadni dla dyrektywy .VAR, z tym e dla takiego przypadku nie ma moliwoci okrelenia adresu umiejscowienia zmiennych w pamici
<pre>
 .VAR .TYPE lab1 lab2 lab3 .TYPE lab4 .TYPE lab5 lab6 ...

 .var .byte a,b,c .dword i j
</pre>
</div>
<div class="tekst">
- dodana moliwo definicji pojedyczych zmiennych typu strukturalnego w krtszy sposb anieli dotd przez DTA
<pre>
.struct @point
 x .byte
 y .byte
.ends

pointA	@point		; pointA dta @point [0] &lt;=&gt; pointA dta @point
pointB	@point		; pointB dta @point [0] &lt;=&gt; pointB dta @point

points	dta @point [100]
</pre>
</div>
<div class="tekst">
- dodana nowa dyrektywa .ZPVAR umoliwiajca automatyczne przydzielenie miejsca zmiennym na stronie zerowej
<pre>
 .ZPVAR TYPE label1, label2 label3 = $80	; LABEL1=$80, LABEL2=LABEL1+TYPE, LABEL3=LABEL2+TYPE
 .ZPVAR label4, label5 TYPE			; LABEL4=LABEL3+TYPE, LABEL5=LABEL4+TYPE

 .print .zpvar
</pre>
</div>
<div class="tekst">
- poprawione dziaanie dyrektywy .ERROR i pseudo rozkazu ERT, moliwe jest umieszczenie dodatkowych informacji w wierszu podobnie jak dla .PRINT (.ECHO) np.:
<pre>
  ERT *>$6000 , 'BUUU przekroczylimy zakres pamici o ' , *-$6000 , ' bajtw'
</pre>
</div>
<div class="tekst">
- dodana moliwo zagniedania blokw procedur .PROC, ten sam kod moe by wywoywany z rnymi parametrami np.:
<pre>
.proc copySrc (.word src+1) .var

 .proc ToDst (.word src+1, dst+1) .var
 .endp

	ldy #0
src	lda $ffff,y
dst	sta $ffff,y
	iny
	bne src

	rts
.endp

	copySrc.ToDst #$a080 #$b000

	copySrc #$a360
</pre>
</div>
<div class="tekst">
- dodane nowe dyrektywy .ENUM i .ENDE (.EEND)
<pre>
.enum	dni_tygodnia

	poniedzialek = 1
	wtorek, sroda = 5, czwartek = 7
	piatek
	sobota
	niedziela

.ende

	ift dzien==dni_tygodnia::wtorek
	.print 'wtorek'
	eif
</pre>
</div>
<div class="tekst">
- rozszerzona funkcjonalno komentarzy wieloliniowych /* */ o moliwo umieszczania ich gdziekolwiek
<pre>
 lda #12+ /* komentarz */ 23
</pre>
</div>
<div class="tekst">
- umoliwiona relokacja adresw definiowanych dyrektyw .DEF
<pre>
 .reloc 
 .def label=*
 lda label
</pre>
</div>
<div class="tekst">
- dodana moliwo uycia znakw { } do oznaczenia bloku (z wyjtkiem blokw .MACRO), znak '{','}' zostaje rozpoznany na pocztku nowego wiersza, np.:
<pre>
#while .word ad+1&lt;=#$bc40+39
{
ad	sta $bc40

	inw ad+1
}

.proc lab
{
	.local temp2
	{
	}

	.array tab [255] .long
	{}
}
</pre>
</div>
</div>

<div class="tekst-wiekszy" id="v1.8.2">
v1.8.2
<div class="tekst">
- zniesione ograniczenie dugoci pliku dla pseudo rozkazu INS (poprzednio dugo wczytywanego pliku ograniczona bya do 65536 bajtw)<br/>
- dodany komunikat bdu 'The referenced label ... has not previously been defined properly' w przypadku etykiet, ktre nie zostay zdefiniowane do koca, np. tylko w pierwszym przebiegu wartoci nieokrelon<br/>
- dodana nowa dyrektywa .ECHO jako odpowiednik dyrektywy .PRINT, dodatkowo informacje generowane przez .PRINT (.ECHO) zapisywane s teraz take w listingu *.LST<br/>
- dodana nowa dyrektywa .ALIGN pozwalajca na wyrwnanie do zadanego zakresu pamici, dodatkowo mona okreli warto jak wypeni pami
<pre>
  [label] .ALIGN N[,fill]
</pre>
</div>
<div class="tekst">
- dodany nowy przecznik -U (Warn of unused labels)<br/>
</div>
</div>

<div class="tekst-wiekszy" id="v1.8.1">
v1.8.1
<div class="tekst">
- rozszerzone dziaanie znaku backslash '\', umieszczenie go na kocu wiersza oznacza kontynuacj aktualnego wiersza od nowego wiersza, np.:
<pre>
  macro_temp \
  _____________________________________parametr1_________________________________________________\
  _____________________________________parametr2_________________________________________________\
  _____________________________________parametr3_________________________________________________

  lda\
  #____________________________________label________________________________________\
  +__________________________________expression___________________________________
</pre>
</div>
<div class="tekst">
- zmienione testowanie niekoczcego wywoywania si makr po ktrym wystpi bd 'Infinite loop'<br/>
- naprawiony zapis etykiet do pliku *.LAB, bd powsta po dodaniu addytywnoci obszarw LOCAL<br/>
- poprawione dziaanie pseudo rozkazu SIN (kod zapoyczony z XASM)<br/>
- poprawione rozpoznawanie dyrektyw przy wczonym przeczniku -C (Case sensitive)<br/>
- usprawniony odczyt blokw .REPT (wskazanie prawidowej linii z bdem) i .MACRO<br/>
- zablokowane uycie .VAR w bloku .REPT<br/>
- umoliwione zagniedanie oraz wielokrotne uruchamianie (poprzez makra) ptli .REPT i :repeat (poprzednio wystpowa komunikat 'Use .REPT directive')<br/>
- umoliwione przekazywanie parametrw do bloku .REPT, np.
<pre>
.REPT 10, #
label:1           ; LABEL0, LABEL1, LABEL2 ... LABEL9
.ENDR

.REPT 5, $12,$33,$44,$55,$66
 dta :1,:2,:3,:4,:5            ; $12,$33,$44,$55,$66
 dta :5,:4,:3,:2,:1            ; $66,$55,$44,$33,$12
.ENDR
</pre>
</div>
</div>

<div class="tekst-wiekszy" id="v1.7.9_1.8.0">
v1.7.9 - 1.8.0
<div class="tekst">
- poprawiony bd w opisie przecznika -F, poprzednio 'Label at first column', prawidowy opis to 'CPU command at first column'<br/>
- przepisana od nowa obsuga dyrektywy .DS i opcji OPT F+ (dodana moliwo uycia blokw RUN i INI)<br/>
- przepisana od nowa obsuga opcji OPT ?+ (etykiety lokalne w standardzie MAE)<br/>
- dodana moliwo upublicznienia w blokach PUBLIC tablic zadeklarowanych przez .ARRAY oraz deklaracji struktur .STRUCT<br/>
- dyrektywa generujca kod 6502 dla decyzji .TEST zastpiona zostaa przez dyrektyw #IF, dyrektywa .ENDT przez #END, dodatkowo moliwe jest uycie dyrektywy #ELSE np.:
<pre>
 # if .byte i&gt;#8 .and .byte i&lt;#200
 # else
       #if .word j = #12
       #end
 # end
</pre>
</div>
<div class="tekst">
- dyrektywa generujca kod 6502 dla iteracji .WHILE zastpiona zostaa przez dyrektyw #WHILE, dyrektywa .ENDW przez #END, np.:
<pre>
 lda 20               -&gt;      lda 20
 # while .byte @=20   -&gt; wait cmp 20
 # end                -&gt;      sne
                      -&gt;      jmp wait
</pre>
</div>
<div class="tekst">
- dyrektywy #IF i #WHILE akceptuj dwa dodatkowe operatory '==' i '!='<br/>
- dodana dyrektywa .EXITM jako odpowiednik .EXIT<br/>
- dodana dyrektywa .FI jako odpowiednik .ENDIF<br/>
- dodana dyrektywa .IFDEF jako krtszy odpowiednik dyrektyw .IF .DEF<br/>
- dodana dyrektywa .IFNDEF jako krtszy odpowiednik dyrektyw .IF .NOT .DEF<br/>
- umoliwione zostao definiowanie makr w obszarze procedury .PROC, podsumowujc aktualnie dopuszczalne jest zdefiniowanie makra w obszarze .LOCAL i .PROC<br/>
- wystpienie jakiegokolwiek ostrzeenia podczas asemblacji nie zmieni kodu wyjcia (exit_code=0), zmiana podyktowana potrzeb kompatybilnoci z linuxowym makefile<br/>
- ujednolicony sposb deklaracji etykiet lokalnych i globalnych, "biae znaki" przed nazw etykiety nie wymusz zdefiniowania takiej etykiety jako globalnej, umoliwi to tylko dyrektywa .DEF :LABEL<br/>
- poprawione makra @CALL.MAC i @CALL_2.MAC, zmienna tymczasowa globalna ?@stack_offset modyfikowana jest teraz przez dyrektyw .DEF<br/>
- rezygnacja z opcji -E (Eat White spaces), aktualnie jest ta opcja zawsze wczona<br/>
- poprawione wywietlanie numeru linii z bdem w aktualnie wykonywanym makrze<br/>
- skrcone nazwy etykiet tworzonych podczas wykonywania makr (atwiejsza ich identyfikacja w pliku *.LAB)<br/>
- poprawione dziaanie opcji OPT H-<br/>
- dodane nowe makro rozkazy INL (increse LONG), IND (increse DWORD), DEL (decrese LONG), DED (decrese DWORD)<br/>
- dodane nowe makro rozkazy CPB (compare BYTE), CPW (compare WORD), CPL (compare LONG), CPD (compare DWORD)<br/>
- usprawnione i rozszerzone dziaanie dyrektyw #TEST i #WHILE w oparciu o kod generowany przez makro rozkazy CPB, CPW, CPL, CPD, dyrektywy #TEST i #WHILE dla wyrae '=#0' i '&lt;&gt;#0' generuj najkrtszy kod wynikowy<br/>
- dodana optymalizacja dugoci generowanego kodu dla makro rozkazw MWA, MWX, MWY<br/>
- dodana nowa opcja OPT R optymalizujca kod makro rozkazw MWA, MWX, MWY, MVA, MVX, MVY ze wzgldu na zawarto rejestrw, np.:
<pre>
                    opt r-        opt r+
    mva #0 $80  -&gt; lda #$00  -&gt; lda #0 
    mva #0 $81  -&gt; sta $80   -&gt; sta $80
                    lda #$00  -&gt; sta $81
                    sta $81   -&gt;
</pre>
</div>
<div class="tekst">
- rozszerzona funkcjonalno dyrektywy .DEF o moliwo przypisania wartoci nowo deklarowanej etykiecie, np.:
<pre>
 .def label = 1
</pre>
</div>
<div class="tekst">
- rozszerzona funkcjonalno dyrektywy .DEF o moliwo zdefiniowania etykiety globalnej niezalenie od aktulnego obszaru lokalnego, np.:
<pre>
 .def :label
</pre>
</div>
<div class="tekst">
- umoliwiona zostaa addytywno obszarw .LOCAL, tzn. moe istnie wiele obszarw lokalnych o tej samej nazwie, symbole zawarte w takich obszarach nalee bd do wsplnej przestrzeni nazw, np.:
<pre>
.local namespace

 .proc proc1
 .endp

.endl

.local namespace

 .proc proc2
 .endp

.endl
</pre>
</div>
</div>

<div class="tekst-wiekszy" id="v1.7.8">
v1.7.8
<div class="tekst">
- dodane dyrektywy .MEND, .PGEND, .REND jako odpowiedniki .ENDM, .ENDPG, .ENDR<br/>
- obecnie deklaracja makra musi koczy si dyrektyw .ENDM lub .MEND (poprzednio dopuszczalne byo uycie dyrektywy .END)<br/>
- poprawiony sposb wykonywania makr dziki czemu umoliwione zostao wykonanie dyrektywy .ENDL z poziomu  wykonywanego makra<br/>
- poprawione zauwaone bdy dotyczce starszych bajtw relokowanego adresu oraz bloku aktualizacji symboli publicznych<br/>
- dodana nowa dyrektywa .USING (.USE) pozwalajca okreli ciek poszukiwa dla nazw etykiet<br/>
- poprawione dziaanie dyrektyw .LOCAL, .DEF, ktrych bdne dziaanie objawiao si w szczeglnych przypadkach<br/>
- poprawione dziaanie makro rozkazw skokw (SNE, RNE itp.), ktrych bdne dziaanie objawiao si w szczeglnych przypadkach<br/>
- rozszerzona skadnia dyrektywy .TEST (kod 6502 dla warunku) o dowoln ilo wyrae poczonych przez .OR lub .AND (brak moliwoci zmiany piorytetu wartociowania przy pomocy nawiasw), np.:
<pre>
 .test .byte k&gt;#10+1 .or .word j&gt;#100 .and .word j&lt;#105 .or .byte k&lt;=#5
 ...
 ...
 .endt
</pre>
</div>
<div class="tekst">
- rozszerzona skadnia dyrektywy .WHILE (kod 6502 dla ptli) o dowoln ilo wyrae poczonych przez .OR lub .AND (brak moliwoci zmiany piorytetu wartociowania przy pomocy nawiasw), np.:
<pre>
 .while .byte k&gt;#4 .and .byte k&lt;#39
 ...
 ...
 .endw
</pre>
</div>
</div>

<div class="tekst-wiekszy" id="v1.7.6_1.7.7">
v1.7.6 - 1.7.7
<div class="tekst">
- dodany nowy przecznik -B:ADDRESS umoliwiajcy asemblacje od zadanego adresu<br/>
- dodany nowa opcja OPT F+- pozwalajca tworzy bloki cigej pamici (przydatne dla cartw)<br/>
- dodana obsuga parametrw typu .LONG i .DWORD przekazywanych do procedur .PROC typu .VAR (poprzednio akceptowanymi typami parametrw by tylko .BYTE i .WORD)<br/>
- dodana nowa dyrektywa .FL realizujca zapis liczb rzeczywistych REAL w formacie FP Atari, np.:
<pre>
pi .fl 3.1415926535897932384626433832795  ; 40 03 14 15 92 65
tb .fl 0.5 12.34 -2.30 0.00002
tb .fl 0.5, 12.34, -2.30, 0.00002
</pre>
</div>
<div class="tekst">
- umoliwiony zosta zapis wartoci innych typw ni tylko .BYTE w bloku .ARRAY<br/>
- dodana obsuga typw wielokrotnych dla .STRUCT, poprzednio takie typy byy akceptowane jednak pami nie bya waciwie dla nich rezerwowana, np.:
<pre>
  .struct test
   x :200 .byte
   y :999 .long
  .ends

buf dta test [0]
</pre>
</div>
<div class="tekst">
- poprawione bdy dotyczce generowania kodu relokowalnego zauwaone przez Laoo, np.:
<pre>
  .reloc

   lda temp
temp .long $aabbcc
</pre>
</div>
<div class="tekst">
- bd 'Addres relocation overload' wystpi teraz tylko gdy wyraenie bdzie dotyczy wicej ni jednej etykiety relokowalnej, poprzednio kade wyraenie z udziaem etykiety relokowalnej powodowao wywietlenie tego komunikatu bdu<br/>
- blok aktualizacji symboli plublicznych rozszerzony zosta o moliwo przekazywania staych rnych typw B-YTE, W-ORD, L-ONG, D-WORD, poprzednio przekazywanym typem by tylko W-ORD<br/>
- zmienione dziaanie dyrektywy .VAR w blokach .LOCAL znajdujcych si w bloku .PROC, zmienne takie zawsze odkadane s na kocu bloku przed dyrektyw .ENDP, w pozostaych przypadkach na kocu bloku .LOCAL przed dyrektyw .ENDL<br/>
- umoliwiona zostaa relokowalno kodu generowanego przez dyrektywy .WHILE i .TEST<br/>
- poprawione dziaanie testowania wartoci typu .WORD w kodzie generowanym przez dyrektywy .WHILE i .TEST<br/>
- dodana nowa dyrektywa .ADR zwracajca adres etykiety przed zmian adresu asemblacji<br/>
- dodana nowa dyrektywa .LEN zwracajca dugo blokw zdefiniowanych przez .PROC i .ARRAY<br/>
- poprawione dziaanie operacji dzielenia, mnoenia i modulo, poprzednio bdnie by interpretowany piorytet dla tych operacji<br/>
- komentarze z koca linii nie poprzedzone znakiem komentarza bd powodowa wystpienie bdu 'Unexpected end of line'<br/>
- dodana moliwo przypisania zmiennej pl zdefiniowanych przez strukture, np.:
<pre>
@point .struct
       x .byte
       y .byte
       .ends

a @point
b @point
c @point
</pre>
</div>
<div class="tekst">
- rozszerzona skadnia .STRUCT o moliwo dodania nowych pl bez definiowania nazwy pola, np.:
<pre>
 .struct @id
  id .word
 .ends

 .struct @mem
  @id
  adr .word
 .ends
</pre>
</div>
<div class="tekst">
- rozszerzona skadnia makro rozkazu MWA o moliwo uycia adresowania poredniego strony zerowej  postindeksowanego Y, np.:
<pre>
  mwa ($80),y $a000,x
  mwa $bc40,y ($f0),y
  mwa ($80),y ($82),y
</pre>
</div>
<div class="tekst">
- rozszerzona skadnia dyrektywy .EXTRN, obecnie moliwe jest zapowiedzenie wikszej iloci etykiet rnych typw w jednym wierszu, zapowiedzenie procedury .PROC w takim wierszu musi znajdowa si na jego kocu, np.:
<pre>
  .extrn a,b,c,d .byte  x y z .word  line .proc(.byte x,y) .reg
</pre>
</div>
<div class="tekst">
- rozszerzona skadnia dyrektywy .VAR, obecnie moliwe jest zadeklarowanie wikszej iloci etykiet rnych typw w jednym wierszu oraz przypisanie im adresu od ktrego zostan odoone w pamici, np.:
<pre>
  .var x y z .byte bit :2 .dword = $80
</pre>
</div>
<div class="tekst">
- rozszerzona skadnia dla parametrw procedur przekazywanych przez zmienne .VAR, moliwe jest podanie przesunicia np.:
<pre>
move .proc (.word src+1,dst+1) .var

src lda $ffff
dst sta $ffff

     .endp
</pre>
</div>
<div class="tekst">
- dodana nowa dyrektywa .NOWARN wyczajca wywietlenie ostrzeenia dla aktualnie asemblowanego wiersza, np.:
<pre>
 .nowarn PROCNAME
</pre>
</div>
<div class="tekst">
- dodane nowe makro rozkazy PHR, PLR, realizujce odkadanie i zdejmowanie wartoci rejestrw z udziaem stosu sprztowego, np.:
<pre>
  phr -&gt; pha         plr -&gt; pla
         txa                tay
         pha                pla
         tya                tax
         pha                pla
</pre>
</div>
<div class="tekst">
- dodane nowe makro rozkazy ADB, SBB realizujce dodawanie i odejmowanie wartoci typu .BYTE, np.:
<pre>
 ADB $80 #12 $b000  -&gt; lda $80
                        clc
                        adc #12
                        sta $b000

 SBB #200 $a000     -&gt; lda #200
                        sec
                        sbc $a000
                        sta $a000
</pre>
<div class="tekst">
- dodana moliwo uycia skadni C dla liczb szestnastkowych, np.:
<pre>
 lda 0x2000
 ldx #0x12

temp = 0x8000
</pre>
</div>
</div>
</div>

<div class="tekst-wiekszy" id="v1.7.5">
v1.7.5
<div class="tekst">
- dyrektywa .DS w blokach relokowalnych SDX RELOC i MADS RELOC deklaruje od teraz pusty blok<br/>
- dodany nowy przecznik -F, ktry umoliwia umieszczanie rozkazw CPU i pseudo rozkazw od pierwszej kolumny w wierszu<br/>
- przepisane od nowa procedury odczytu blokw .MACRO, .REPT oraz procedura realizujca dzielenie wiersza przy pomocy znaku '\'<br/>
- dodane nowe pseudo rozkazy ADW, SBW realizujce dodawanie i odejmowanie wartoci typu WORD dla CPU6502, np.:
<pre>
  adw hlp #40        ; hlp=hlp+40
  adw hlp #20 pom    ; pom=hlp+20
</pre>
</div>
<div class="tekst">
- rozszerzone dziaanie dyrektywy .DEF o moliwo zdefiniowania etykiety, np.: .DEF label<br/>
- zwikszona liczba przebiegw dla deklaracji etykiet przez EQU dla pewnych szczeglnych przypadkw<br/>
</div>
</div>

<div class="tekst-wiekszy" id="v1.7.4">
v1.7.4
<div class="tekst">
- naprawione dziaanie dyrektywy .PRINT, dotd moga nie wywietli wartoci etykiet zaczynajcej si na liter 'A','B','C','D','E','F','G','H','L','T','V'<br/>
- zablokowane dziaanie dyrektywy .DS w blokach .RELOC i SDX oraz naprawione jej dziaanie z instrukcj warunkow .IF (IFT)<br/>
- usprawnione przeszukiwanie cieek dostpu -i:path (mona odwoywa si do podkatalogw tam zawartych)<br/>
- w przypadku wystpienia bdw podczas asemblacji wywietlane s one wszystkie a nie tylko pierwszy z bdw<br/>
- poprawione zauwaone bdy, m.in. uycie makra w pliku .RELOC mogo spowodowa w pewnych sytuacjach zapis bdnej informacji o relokownych adresach<br/>
- uproszczony zosta sposb koczenia procedur wykorzystujcych stos programowy MADS-a, nie ma potrzeby uywania dyrektywy .EXIT, a dyrektywa .ENDP nie powoduje ju dodatkowych dziaa na stosie programowym<br/>
- dodana nowa dyrektywa .SYMBOL jako odpowiednik bloku aktualizacji BLK UPDATE NEW SYMBOL 'SYMBOL', dyrektyw .SYMBOL mona uy w dowolnym miejscu programu<br/>
- dodane automatyczne wywoywanie blokw aktualizacji (ADDRESS, EXTERNAL, PUBLIC, SYMBOL) dla .RELOC i SDX<br/>
- dodane nowe dyrektywy .BY, .WO, .HE, .EN, .SB (zapoyczone z MAE)<br/>
- dodany nowy przecznik OPT ?- (domylnie) etykiety ze znakiem zapytania (?labels) traktowane s jako etykiety tymczasowe, OPT ?+ etykiety ze znakiem zapytania (?labels) traktowane s jako lokalne i tymczasowe, nazw obszaru lokalnego jest ostatnio uyta etykieta bez znaku zapytania<br/>
- dodane dyrektywy .LEND, .PEND, .AEND, .WEND, .TEND, .SEND jako odpowiedniki dyrektyw .ENDL, .ENDP, .ENDW, ENDW, .ENDT, .ENDS<br/>
- dodane nowe dyrektywy .GLOBAL i .GLOBL jako odpowiednik (zamiennik) dyrektywy .PUBLIC<br/>
- dodana optymalizacja skokw warunkowych JEQ, JNE, JPL, JMI, JCC, JCS, JVC, JVS, jeli jest taka moliwo wybierany jest skok krtki typu BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS<br/>
- dodany nowy domylny separator znak spacji dla przekazywanych parametrw do .PROC, .MACRO, dotd by to tylko znak przecinka<br/>
- usprawnienia dotyczce przekazywania parametrw do makr i procedur, np. paramatrem makra moe by dyrektywa zwracajca warto wyraenia lub symbol licznika ptli '#'
<pre>
  :12 makro #
</pre>
</div>
<div class="tekst">
- dodana moliwo uycia znaku spacji jako separatora dla .VAR, .EXTRN, np.
<pre>
  .EXTRN a b c d .word
  .VAR i = 1  j = 2 .byte
  .VAR a b c d .byte
</pre>
</div>
<div class="tekst">
- rozszerzona skadnia dla .VAR umoliwiajca zaincjowanie zmiennych sta, np.:
<pre>
 .var i = 10  j = 12 .byte
 .var a , b = 2 .byte
</pre>
</div>
<div class="tekst">
- dodane nowe dyrektywy .WHILE, .ENDW pozwalajce na automatyczne wygenerowanie kodu dla ptli WHILE, np.:
<pre>
         ldx #$ff
 .while .word adr &lt; #$bc40+40*24
         stx $bc40
    adr: equ *-2
         inw adr
 .endw
</pre><div class="tekst">
- dodane nowe dyrektywy .TEST, .ENDT pozwalajce na automatyczne wygenerowanie kodu dla warunku, np.:
<pre>
 .test .byte (@>=#'a')
  .test .byte (@&lt;=#'z')
      
  .endt
 .endt
</pre>
</div>
</div>
</div>

<div class="tekst-wiekszy" id="v1.7.3">
v1.7.3
<div class="tekst">
- dodana moliwo zmiany adresu asemblacji .PROC lub .LOCAL bez zmiany adresu adowania<br/>
- usunito optymalizacj kodu dla makro rozkazw MWA itp., ktra moga powodowa w szczeglnych przypadkach zaptlenie si MADS-a<br/>
- dodane dyrektywy .REG, .VAR pozwalajce okreli sposb przekazywania parametrw do procedur (.REG przez rejestry CPU, .VAR przez zmienne)<br/>
- dodana dyrektywa .VAR pozwalajca na deklaracj zmiennych w blokach .PROC, .LOCAL, zadeklarowane zmiennne s fizycznie odkadane na kocu takiego bloku<br/>
- rozszerzona skadnia dla dyrektywy .EXTRN, np. EXTRN label1,label2,label3... TYPE<br/>
- jesli brak deklaracji etykiet dla stosu programowego MADS-a, przyjmowane s domylne wartoci @PROC_VARS_ADR=$0500, @STACK_ADDRESS=$0600, @STACK_POINTER=$FE<br/>
- dodany repeat_counter #, ktry mona uywa zamiennie z dyrektyw .R<br/>
- wystapi bd '^ not relocatable' przy prbie relokacji rozkazu 'lda ^label'<br/>
- dodana obsuga symboli publicznych dla staych (C-ONSTANT) w blokach PUBLIC<br/>
- poprawiona relokowalnosc dla tablic .ARRAY, danych stworzonych przez .STRUCT, parametrw przekazywanych do procedur przez staa #
</div>
</div>

<div class="tekst-wiekszy" id="v1.7.2">
v1.7.2
<div class="tekst">
- przepisana na nowo obsuga pseudo rozkazw REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS, SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS<br/>
- poprawione dziaanie dyrektywy .LINK dla blokw o staych adresach<br/>
- poprawione testowanie sw zarezerwowanych (mona uywa nazw zarezerwowanych dla 65816 gdy uywamy tylko 6502)<br/>
- zmiany w listingu, wywietla informacje o numerze banku tylko gdy bank &gt; 0<br/>
- dodana obsuga makro rozkazw MWA, MWX, MWY, MVA, MVX, MVY, ADD, SUB, INW, DEW (do ich obsugi nie s ju potrzebne makra)
</div>
</div>

<div class="tekst-wiekszy" id="v1.7.1">
v1.7.1
<div class="tekst">
- dodana moliwo uywania nazw mnemonikw 65816 w trybie pracy 6502, w trybie 65816 wystpi ju bd <b>Reserved word</b><br/>
- poprawione dziaanie pseudo rozkazw skokw SCC, RNE itp. w makrach<br/>
- usprawnione wykonywanie wielu makr rozdzielonych znakiem dwukropka ':'
</div>
</div>

<div class="tekst-wiekszy" id="v1.7.0">
v1.7.0
<div class="tekst">
- usunity bd, ktry powodowa zbyt maa liczb przebiegw asemblacji<br/>
- dodana obsuga pseudo rozkazw JEQ, JNE, JPL, JMI, JCC, JCS, JVC, JVS (makra nie s ju potrzebne do ich obsugi)
</div>
</div>

<div class="tekst-wiekszy" id="v1.6.9">
v1.6.9
<div class="tekst">
- rozszerzona skadnia dla .ARRAY, .PUT<br/>
- dodany pseudo rozkaz EXT pozwalajcy na deklaracje etykiety external<br/>
- dodane makra JEQ, JNE, JPL, JMI, JCC, JCS<br/>
- dodane dyrektywy .PAGES i .ENDPG<br/>
- dodana dyrektywa .END zastepujaca inne dyrektywy .END?<br/>
- przecznik -H zastpiony zosta przez -HC (generuje plik nagwkowy dla CC65)<br/>
- dodany nowy przecznik -HM generujcy plik nagwkowy dla MADS-a z sortowaniem na etykiety typu CONSTANTS, VARIABLES, PROCEDURES<br/>
- dodana nowa dyrektywa .RELOC generujca kod relokowalny w formacie MADS-a
</div>
</div>

<div class="tekst-wiekszy" id="v1.6.8">
v1.6.8
<div class="tekst">
- dodana nowa dyrektywa .PUT oraz rozszerzona skadnia dla dyrektywy .GET (../EXAMPLES/MSX/MPT_PLAYER/MPT_RELOCATOR.MAC , ../EXAMPLES/MSX/TMC_PLAYER/TMC_RELOCATOR.MAC)<br/>
- dodana obsuga pseudo rozkazw XASM-a REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS, SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS<br/>
- dodana moliwo czenia dowolnej liczby znanych MADS-owi mnemonikw przy pomocy znaku ':' (styl XASM-a), np.: 
<pre>
  lda:cmp:req 20
  ldx:ldy:lda:iny label
</pre>
</div>
</div>

<div class="tekst-wiekszy" id="v1.6.6_1.6.7">
v1.6.6 - 1.6.7
<div class="tekst">
- rdo MADS-a kompatybilne z Free Pascal Compiler, po kompilacji moliwe jest jego uywanie na innych platformach systemowych, jak np. Linux, Mac OS, OS/2 itp.<br/>
- od teraz MADS sam dobiera odpowiedni liczb przebiegw asemblacji, przecznik '/3' nie jest ju potrzebny<br/>
- poprawiony i rozbudowany zosta mechanizm przekazywania parametrw do MADS-a (rozdzia 'Przeczniki assemblera')<br/>
- poprawione zostao wywoanie makra w linii rozdzielanej znakiem '\' oraz usprawnione rozpoznawanie i wykonywanie linii rozdzielanych znakami '\'<br/>
- poprawiony bd, w ktrym MADS myli dyrektyw .ENDM z pseudorozkazem IFT<br/>
- poprawione dziaanie instrukcji warunkowych .ELSEIF, .ELSE<br/>
- poprawione testowanie poprawnoci instrukcji warunkowych w makrach<br/>
- obsuga procedur .PROC zostaa rozbudowana o nowe makra i mechanizmy, dziki ktrym podobna jest w dziaaniu jak i atwoci uycia do procedur z jzykw wyszego poziomu<br/>
- dla procedur .PROC z zadeklarowanymi parametrami potrzebna jest teraz dodatkowa deklaracja @PROC_VARS_ADR<br/>
- brak ogranicze w liczbie parametrw przekazywanych do procedur, jedynym ograniczeniem jest dostpna pami<br/>
- dodany nowy przecznik /d:label=value pozwalajcy zdefiniowa now etykiet MADS-a z poziomu linii polece<br/>
- dodany nowy przecznik /x "Exclude unreferenced procedures" pozwalajcy pomin podczas asemblacji nie uywane w programie procedury zadeklarowane dyrektyw .PROC<br/>
- nowa opcja OPT T+ (track sep, rep) ledzca zmiany rozmiaru rejestrw A,X,Y dokonywane przez rozkazy SEP, REP (CPU 65816)<br/>
- nowe biblioteki w katalogu ..\EXAMPLES\LIBRARIES<br/>
- w deklaracji obszaru lokalnego .LOCAL nie jest wymagane podanie nazwy obszaru<br/>
- nowe operatory '-=', '+=', '++', '--' pozwalajce zmniejszy/zwikszy warto etykiety tymczasowej, np.:
<pre>
  ?label --      -&gt;  ?label=?label-1
  ?lab ++        -&gt;  ?lab=?lab+1
  ?temp += 3     -&gt;  ?temp=?temp+3
  ?ofset -= 5    -&gt;  ?ofset=?ofset-5
</pre>
</div>
<div class="tekst">
- rozszerzona o znak przecinka skadnia deklaracji parametrw procedur, np.:
<pre>
 .proc nazwa (.byte a,b,c .word d,e)
 .endp
</pre>
</div>
</div>
</div>

</body>
</html>