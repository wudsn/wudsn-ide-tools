mads 2.1.0 build 8 (23 Dec 19)
Source: roaddli.a65
     1 				; ------------------------------------------------------------
     2 				; Mad Pascal Compiler version 1.6.4 [2020/04/23] for 6502
     3 				; ------------------------------------------------------------
     4
     5 = 0010			STACKWIDTH	= 16
     6 = 3000			CODEORIGIN	= $3000
     7
     8 = 0001			TRUE		= 1
     9 = 0000			FALSE		= 0
    10
    11 				; ------------------------------------------------------------
    12
    13 					org $80
    14
    15 = 0080			fxptr	.ds 2						; VBXE pointer
    16 = 0082			psptr	.ds 2						; PROGRAMSTACK Pointer
    17
    18 = 0084			eax	.ds 4						;8 bytes (aex + edx) -> divREAL
    19 = 0088			edx	.ds 4
    20 = 008C			ecx	.ds 4
    21 = 0090			bp	.ds 2
    22 = 0092			bp2	.ds 2
    23
    24 				ztmp
    25 = 0094			ztmp8	.ds 1
    26 = 0095			ztmp9	.ds 1
    27 				TMP
    28 = 0096			ztmp10	.ds 1
    29 = 0097			ztmp11	.ds 1
    30
    31 = 0098			STACKORIGIN	.ds STACKWIDTH*4
    32 				zpend
    33
    34 				; ------------------------------------------------------------
    35
    36 = 0084			ax	= eax
    37 = 0084			al	= eax
    38 = 0085			ah	= eax+1
    39
    40 = 008C			cx	= ecx
    41 = 008C			cl	= ecx
    42 = 008D			ch	= ecx+1
    43
    44 = 0088			dx	= edx
    45 = 0088			dl	= edx
    46 = 0089			dh	= edx+1
    47
    48 					org eax
    49
    50 = 0084			FP1MAN0	.ds 1
    51 = 0085			FP1MAN1	.ds 1
    52 = 0086			FP1MAN2	.ds 1
    53 = 0087			FP1MAN3	.ds 1
    54
    55 					org ztmp8
    56
    57 = 0094			FP1SGN	.ds 1
    58 = 0095			FP1EXP	.ds 1
    59
    60 					org edx
    61
    62 = 0088			FP2MAN0	.ds 1
    63 = 0089			FP2MAN1	.ds 1
    64
    65 = 008A			FP2MAN2	.ds 1
    66 = 008B			FP2MAN3	.ds 1
    67
    68 					org ztmp10
    69
    70 = 0096			FP2SGN	.ds 1
    71 = 0097			FP2EXP	.ds 1
    72
    73 					org ecx
    74
    75 = 008C			FPMAN0	.ds 1
    76 = 008D			FPMAN1	.ds 1
    77 = 008E			FPMAN2	.ds 1
    78 = 008F			FPMAN3	.ds 1
    79
    80 					org bp2
    81
    82 = 0092			FPSGN	.ds 1
    83 = 0093			FPEXP	.ds 1
    84
    85 				.local	RESOURCE
    86 					icl 'atari\resource.asm'
Source: resource.asm
     1
  1148 					opt l+
    87 = 0000				?EXTDETECT = 0
    88 = 0000				?VBXDETECT = 0
    89
    90 3075				RCASM 'dlist.asm' DISPLAY_LIST_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: resource.asm]
     2 3075				org RESORIGIN
     4 = 00C8			len = .sizeof(_DISPLAY_LIST_ADDRESS)
     6 				mcpy	ift main.DISPLAY_LIST_ADDRESS+len >= $bc20
    11 3075 20 41 30			jsr sys.off
    13 3078 A9 96 85 88 A9 30 +  MWA #DATA EDX
    13 3080 A9 00 85 8C A9 70 +  MWA #MAIN.DISPLAY_LIST_ADDRESS ECX
    13 3088 A9 C8 85 84 A9 00 +  MWA #LEN EAX
    13 3090 20 00 30		 JSR RESOURCE.MEMCPY
    15 3093 4C 65 30			jmp sys.on
    16 3096			data
Source: dlist.asm
     4 = 0000			DL_BLANK1 = 0; // 1 blank line
     5 = 0010			DL_BLANK2 = %00010000; // 2 blank lines
     6 = 0020			DL_BLANK3 = %00100000; // 3 blank lines
     7 = 0030			DL_BLANK4 = %00110000; // 4 blank lines
     8 = 0040			DL_BLANK5 = %01000000; // 5 blank lines
     9 = 0050			DL_BLANK6 = %01010000; // 6 blank lines
    10 = 0060			DL_BLANK7 = %01100000; // 7 blank lines
    11 = 0070			DL_BLANK8 = %01110000; // 8 blank lines
    13 = 0080			DL_DLI = %10000000; // Order to run DLI
    14 = 0040			DL_LMS = %01000000; // Order to set new memory address
    15 = 0020			DL_VSCROLL = %00100000; // Turn on vertical scroll on this line
    16 = 0010			DL_HSCROLL = %00010000; // Turn on horizontal scroll on this line
    18 = 0002			DL_MODE_40x24T2 = 2; // Antic Modes
    19 = 0004			DL_MODE_40x24T5 = 4;
    20 = 0005			DL_MODE_40x12T5 = 5;
    21 = 0006			DL_MODE_20x24T5 = 6;
    22 = 0007			DL_MODE_20x12T5 = 7;
    23 = 0008			DL_MODE_40x24G4 = 8;
    24 = 0009			DL_MODE_80x48G2 = 9;
    25 = 000A			DL_MODE_80x48G4 = $A;
    26 = 000B			DL_MODE_160x96G2 = $B;
    27 = 000C			DL_MODE_160x192G2 = $C;
    28 = 000D			DL_MODE_160x96G4 = $D;
    29 = 000E			DL_MODE_160x192G4 = $E;
    30 = 000F			DL_MODE_320x192G2 = $F;
    32 = 0001			DL_JMP = %00000001; // Order to jump
    33 = 0041			DL_JVB = %01000001; // Jump to begining
Source: const.inc
     7 = 6000			FREE_BOTTOM = $6000;  // and sometimes I like to do some relative addressing
     9 = 6000			VIDEO_RAM_ADDRESS = FREE_BOTTOM; 
    10 = 7000			DISPLAY_LIST_ADDRESS = VIDEO_RAM_ADDRESS + $1000; 
    18 = 00FF			NONE = $ff;
    41 7000			dl_start
    42 7000 F0			    dta DL_BLANK8 + DL_DLI  ; 8 blank lines and display list interrupt call
    43 7001 70 70		    :2 dta DL_BLANK8        ; 16 blank lines
    44 7003 4E 00 60 4E 00 60 +     :64 dta DL_MODE_160x192G4 + DL_LMS, a(VIDEO_RAM_ADDRESS) ; first text line
    46 70C3 70 70		    :2 dta DL_BLANK8        ; 16 blanks
    47 70C5 41 00 70		    dta DL_JVB, a(dl_start) ; jump to start
    23 					.print '$R RCASM   ',main.DISPLAY_LIST_ADDRESS,'..',main.DISPLAY_LIST_ADDRESS+len-1," 'dlist.asm'"
    23 				$R RCASM   $7000..$70C7 'dlist.asm'
    25 02E2-02E3> 75 30			ini mcpy
Source: roaddli.a65
    91 				.endl
    92
    93 				; ------------------------------------------------------------
    94
    95 315E				org CODEORIGIN
    96
    97 3000				STATICDATA
Macro: STATICDATA [Source: roaddli.a65]
Source: roaddli.a65
    98
    99 				; ------------------------------------------------------------
   100
   101 3000			RTLIB
   102 3000				icl 'rtl6502.asm'
Source: rtl6502.asm
   376 					opt l+
   103
   104 				.print 'ZPAGE: ',fxptr,'..',zpend
   104 				ZPAGE: $0080..$00D8
   105
   106 				.print 'RTLIB: ',RTLIB,'..',*
   106 				RTLIB: $3000..$3143
   107
   108 				; ------------------------------------------------------------
   109
   110 3143			START
   111 3143 BA				tsx
   112 3144 8E 97 37			stx MAIN.@halt+1
   113
   114 					.ifdef fmulinit
   115 					fmulinit
   116 					eif
   117
   118 = 0B8B			VLEN	= VARDATASIZE-VARINITSIZE
   119 = 37C4			VADR	= DATAORIGIN+VARINITSIZE
   120
   121 					ift VADR > $BFFF
   122 					ert 'Invalid memory address range ',VADR
   123 					eli (VLEN>0) && (VLEN<=256)
   124 					ldx #256-VLEN
   125 					lda #0
   126 					sta:rne VADR+VLEN-256,x+
   127 					eli VLEN>0
   128 					@fill #VADR #VLEN #0
   128 				 MWA #VADR @FILL.PTR1\ MWA #VLEN @FILL.PTR3\ MVA #0 @FILL.PTR2\ JSR @FILL
   128 3147 A9 C4 85 88 A9 37 +  MWA #VADR @FILL.PTR1
   128 314F A9 8B 85 8C A9 0B +  MWA #VLEN @FILL.PTR3
   128 3157 A9 00 85 84		 MVA #0 @FILL.PTR2
   128 315B 20 A7 30		 JSR @FILL
   129 					eif
   130
   131 315E A9 4F 85 82 A9 43 + 	mwa #PROGRAMSTACK psptr
   132
   133 3166 A2 0F			ldx #$0f					; DOS II+/D ParamStr
   134 3168 BD 40 03 9D 9A 37 + 	mva:rpl $340,x MAIN.IOCB@COPY,x-
   135
   136 3171 E8				inx						; X = 0
   137 3172 86 90			stx bp						; BP = 0
   138
   139 3174 8E 08 D2			stx audctl					; reset POKEY
   140 3177 A9 03			lda #3
   141 3179 8D 0F D2			sta skctl
   142
   143 317C CA				dex						; X = 255
   144
   145 317D				UNITINITIALIZATION
Macro: UNITINITIALIZATION [Source: roaddli.a65]
Source: roaddli.a65
   146
   147 317D			.local	MAIN						; PROCEDURE
   148
   149 317D 4C C1 35			jmp l_0007
   150
   151 				; ------------------------------------------------------------
   152
   153 3180			.local	SYSTEM						; UNIT
   154
   155 3180			.local	DPOKE						; PROCEDURE | ASSEMBLER | REGISTER
   156
   157 				; ------------------------------------------------------------
   158
   159 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   160 				; as Pointer
   161 3180 B5 98 85 8C			mva :STACKORIGIN,x VALUE
   162 3184 B5 A8 85 8D			mva :STACKORIGIN+STACKWIDTH,x VALUE+1
   163 3188 CA				dex						; sub bx, 1
   164
   165 				; ------------------------------------------------------------
   166
   167 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   168 				; as Pointer
   169 3189 B5 98 85 88			mva :STACKORIGIN,x A
   170 318D B5 A8 85 89			mva :STACKORIGIN+STACKWIDTH,x A+1
   171 3191 CA				dex						; sub bx, 1
   172
   173 				; ---------------------  ASM Block 022  ---------------------
   174
   175 3192 A0 00			ldy #0
   176 3194 A5 8C 91 88			mva value (edx),y
   177 3198 C8				iny
   178 3199 A5 8D 91 88			mva value+1 (edx),y
   179
   180
   181 				; ------------------------------------------------------------
   182
   183 = 0088			A	= edx
   184 = 008C			VALUE	= ecx
   185 319D			@exit
   186 					.ifdef @new
   187 					lda <@VarData
   188 					sta :ztmp
   189 					lda >@VarData
   190 					ldy #@VarDataSize-1
   191 					jmp @FreeMem
   192 					eif
   193 319D 60				rts						; ret
   194 				.endl
   195
   196 319E			.local	PAUSE_005A					; PROCEDURE | ASSEMBLER | OVERLOAD
   197
   198 				; ---------------------  ASM Block 039  ---------------------
   199
   200 319E A5 14 C5 14 F0 FC		lda:cmp:req :rtclok+2
   201
   202 31A4			@exit
   203 					.ifdef @new
   204 					lda <@VarData
   205 					sta :ztmp
   206 					lda >@VarData
   207 					ldy #@VarDataSize-1
   208 					jmp @FreeMem
   209 					eif
   210 31A4 60				rts						; ret
   211 				.endl
   212
   213 				; ------------------------------------------------------------
   214
   215 = 0101			__PORTB_BANKS	= $0101
   216 = 0648			M_PI_2	= $0648
   217 = 0192			D_PI_2	= $0192
   218 = 0004			D_PI_180	= $04
   219 = 0000			MGTIA	= $00
   220 = 0080			MVBXE	= $80
   221 = 0000			VBXE_XDLADR	= $00
   222 = 0100			VBXE_BCBADR	= $0100
   223 = 1000			VBXE_MAPADR	= $1000
   224 = 5000			VBXE_OVRADR	= $5000
   225 = B000			VBXE_WINDOW	= $B000
   226 = 0000			IDLI	= $00
   227 = 0001			IVBL	= $01
   228 = 00FE			CH_DELCHR	= $FE
   229 = 009B			CH_ENTER	= $9B
   230 = 001B			CH_ESC	= $1B
   231 = 001C			CH_CURS_UP	= $1C
   232 = 001D			CH_CURS_DOWN	= $1D
   233 = 001E			CH_CURS_LEFT	= $1E
   234 = 001F			CH_CURS_RIGHT	= $1F
   235 = 007F			CH_TAB	= $7F
   236 = 009B			CH_EOL	= $9B
   237 = 007D			CH_CLR	= $7D
   238 = 00FD			CH_BELL	= $FD
   239 = 007E			CH_DEL	= $7E
   240 = 009C			CH_DELLINE	= $9C
   241 = 009D			CH_INSLINE	= $9D
   242 = 0000			COLOR_BLACK	= $00
   243 = 000E			COLOR_WHITE	= $0E
   244 = 0032			COLOR_RED	= $32
   245 = 0096			COLOR_CYAN	= $96
   246 = 0068			COLOR_VIOLET	= $68
   247 = 00C4			COLOR_GREEN	= $C4
   248 = 0074			COLOR_BLUE	= $74
   249 = 00EE			COLOR_YELLOW	= $EE
   250 = 0028			COLOR_ORANGE	= $28
   251 = 00E4			COLOR_BROWN	= $E4
   252 = 003C			COLOR_LIGHTRED	= $3C
   253 = 0004			COLOR_GRAY1	= $04
   254 = 0006			COLOR_GRAY2	= $06
   255 = 000A			COLOR_GRAY3	= $0A
   256 = 00CC			COLOR_LIGHTGREEN	= $CC
   257 = 007C			COLOR_LIGHTBLUE	= $7C
   258 = 0004			FMOPENREAD	= $04
   259 = 0008			FMOPENWRITE	= $08
   260 = 0009			FMOPENAPPEND	= $09
   261 = 000C			FMOPENREADWRITE	= $0C
   262 = 37B0			SCREENWIDTH	= DATAORIGIN+$0000
   263 = 37B2			SCREENHEIGHT	= DATAORIGIN+$0002
   264 = 37B4			DATESEPARATOR	= DATAORIGIN+$0004
   265 = D014			TVSYSTEM	= $D014
   266 = 02C0			adr.PALETTE	= $02C0
   267 31A5			.var PALETTE	= adr.PALETTE .word
   268 = D012			adr.HPALETTE	= $D012
   269 31A5			.var HPALETTE	= adr.HPALETTE .word
   270 = 37B5			FILEMODE	= DATAORIGIN+$0005
   271 = 37B6			GRAPHMODE	= DATAORIGIN+$0006
   272 = 37B7			IORESULT	= DATAORIGIN+$0007
   273 = 37B8			EOLN	= DATAORIGIN+$0008
   274 = 37B9			RNDSEED	= DATAORIGIN+$0009
   275
   276 = 31A5 C0 02		PALETTE
   276 = 31A7 12 D0		HPALETTE
   276 				.endl							; UNIT SYSTEM
   277
   278 				; ------------------------------------------------------------
   279
   280 31A9			.local	ATARI						; UNIT
   281
   282 				; ------------------------------------------------------------
   283
   284 = 0012			RTCLOK	= $12
   285 = 004D			ATRACT	= $4D
   286 = 0052			LMARGIN	= $52
   287 = 0053			RMARGIN	= $53
   288 = 0054			ROWCRS	= $54
   289 = 0055			COLCRS	= $55
   290 = 0057			DINDEX	= $57
   291 = 0058			SAVMSC	= $58
   292 = 0062			PALNTS	= $62
   293 = 006A			RAMTOP	= $6A
   294 = 0200			VDSLST	= $0200
   295 = 0230			SDLSTL	= $0230
   296 = 0290			TXTROW	= $0290
   297 = 0291			TXTCOL	= $0291
   298 = 0293			TINDEX	= $0293
   299 = 0294			TXTMSC	= $0294
   300 = 022F			SDMCTL	= $022F
   301 = 026F			GPRIOR	= $026F
   302 = 02F0			CRSINH	= $02F0
   303 = 02F3			CHACT	= $02F3
   304 = 02F4			CHBAS	= $02F4
   305 = 02FC			CH	= $02FC
   306 = 02C0			PCOLR0	= $02C0
   307 = 02C1			PCOLR1	= $02C1
   308 = 02C2			PCOLR2	= $02C2
   309 = 02C3			PCOLR3	= $02C3
   310 = 02C4			COLOR0	= $02C4
   311 = 02C5			COLOR1	= $02C5
   312 = 02C6			COLOR2	= $02C6
   313 = 02C7			COLOR3	= $02C7
   314 = 02C8			COLOR4	= $02C8
   315 = 02C8			COLBAKS	= $02C8
   316 = D000			HPOSP0	= $D000
   317 = D001			HPOSP1	= $D001
   318 = D002			HPOSP2	= $D002
   319 = D003			HPOSP3	= $D003
   320 = D004			HPOSM0	= $D004
   321 = D005			HPOSM1	= $D005
   322 = D006			HPOSM2	= $D006
   323 = D007			HPOSM3	= $D007
   324 = D008			SIZEP0	= $D008
   325 = D009			SIZEP1	= $D009
   326 = D00A			SIZEP2	= $D00A
   327 = D00B			SIZEP3	= $D00B
   328 = D00C			SIZEM	= $D00C
   329 = D00D			GRAFP0	= $D00D
   330 = D00E			GRAFP1	= $D00E
   331 = D00F			GRAFP2	= $D00F
   332 = D010			GRAFP3	= $D010
   333 = D011			GRAFM	= $D011
   334 = D004			P0PF	= $D004
   335 = D014			PAL	= $D014
   336 = D012			COLPM0	= $D012
   337 = D013			COLPM1	= $D013
   338 = D014			COLPM2	= $D014
   339 = D015			COLPM3	= $D015
   340 = D016			COLPF0	= $D016
   341 = D017			COLPF1	= $D017
   342 = D018			COLPF2	= $D018
   343 = D019			COLPF3	= $D019
   344 = D01A			COLBK	= $D01A
   345 = D01B			PRIOR	= $D01B
   346 = D01D			GRACTL	= $D01D
   347 = D01E			HITCLR	= $D01E
   348 = D200			AUDF1	= $D200
   349 = D201			AUDC1	= $D201
   350 = D202			AUDF2	= $D202
   351 = D203			AUDC2	= $D203
   352 = D204			AUDF3	= $D204
   353 = D205			AUDC3	= $D205
   354 = D206			AUDF4	= $D206
   355 = D207			AUDC4	= $D207
   356 = D208			AUDCTL	= $D208
   357 = D20F			SKSTAT	= $D20F
   358 = D301			PORTB	= $D301
   359 = D400			DMACTL	= $D400
   360 = D401			CHACTL	= $D401
   361 = D402			DLISTL	= $D402
   362 = D404			HSCROL	= $D404
   363 = D405			VSCROL	= $D405
   364 = D407			PMBASE	= $D407
   365 = D409			CHBASE	= $D409
   366 = D40A			WSYNC	= $D40A
   367 = D40B			VCOUNT	= $D40B
   368 = D40C			PENH	= $D40C
   369 = D40D			PENV	= $D40D
   370 = D40E			NMIEN	= $D40E
   371
   372 				.endl							; UNIT ATARI
   373
   374 				; ------------------------------------------------------------
   375
   376 31A9			.local	CRT						; UNIT
   377
   378 31A9			.local	READKEY						; FUNCTION | ASSEMBLER
   379
   380 				; ---------------------  ASM Block 049  ---------------------
   381
   382 31A9 8A 48			txa:pha
   383
   384 31AB 20 00 30			@GetKey
   385
   386 31AE 8D BC 37			sta Result
   387
   388 31B1 68 AA			pla:tax
   389
   390 31B3			@exit
   391
   392 				; ------------------------------------------------------------
   393
   394 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   395 				; as Pointer
   396
   397 31B3 E8				inx						; add bx, 1
   398 31B4 AD BC 37 95 98		mva RESULT :STACKORIGIN,x
   399
   400 					.ifdef @new
   401 					lda <@VarData
   402 					sta :ztmp
   403 					lda >@VarData
   404 					ldy #@VarDataSize-1
   405 					jmp @FreeMem
   406 					eif
   407
   408 				; ------------------------------------------------------------
   409
   410 = 37BC			RESULT	= DATAORIGIN+$000C
   411
   412 = 37BC			@VarData	= RESULT
   413 = 0001			@VarDataSize	= 1
   414
   415 31B9 60				rts						; ret
   416 				.endl
   417
   418 				; ------------------------------------------------------------
   419
   420 = 37BB			TEXTATTR	= DATAORIGIN+$000B
   421 = D01F			CONSOL	= $D01F
   422 = 0000			CN_START_SELECT_OPTION	= $00
   423 = 0001			CN_SELECT_OPTION	= $01
   424 = 0002			CN_START_OPTION	= $02
   425 = 0003			CN_OPTION	= $03
   426 = 0004			CN_START_SELECT	= $04
   427 = 0005			CN_SELECT	= $05
   428 = 0006			CN_START	= $06
   429 = 0007			CN_NONE	= $07
   430 = 0000			BW40	= $00
   431 = 0001			CO40	= $01
   432 = 0002			BW80	= $02
   433 = 0003			CO80	= $03
   434 = 0007			MONO	= $07
   435 = 0001			C40	= $01
   436 = 0003			C80	= $03
   437 = 0000			BLACK	= $00
   438 = 0001			BLUE	= $01
   439 = 0002			GREEN	= $02
   440 = 0003			CYAN	= $03
   441 = 0004			RED	= $04
   442 = 0005			MAGENTA	= $05
   443 = 0006			BROWN	= $06
   444 = 0007			LIGHTGRAY	= $07
   445 = 0008			DARKGRAY	= $08
   446 = 0009			LIGHTBLUE	= $09
   447 = 000A			LIGHTGREEN	= $0A
   448 = 000B			LIGHTCYAN	= $0B
   449 = 000C			LIGHTRED	= $0C
   450 = 000D			LIGHTMAGENTA	= $0D
   451 = 000E			YELLOW	= $0E
   452 = 000F			WHITE	= $0F
   453 = 0080			BLINK	= $80
   454
   455 				.endl							; UNIT CRT
   456
   457 				; ------------------------------------------------------------
   458
   459 31BA			.local	TYPES						; UNIT
   460
   461 				; ------------------------------------------------------------
   462
   463 				.endl							; UNIT TYPES
   464
   465 				; ------------------------------------------------------------
   466
   467 31BA			.local	FASTGRAPH					; UNIT
   468
   469 31BA			.local	SETCOLOR					; PROCEDURE | ASSEMBLER
   470
   471 				; ------------------------------------------------------------
   472
   473 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   474 				; as Pointer
   475 31BA B5 98 8D D9 3E		mva :STACKORIGIN,x COLOR
   476 31BF CA				dex						; sub bx, 1
   477
   478 				; ---------------------  ASM Block 062  ---------------------
   479
   480 31C0 8D C6 37			sta GetColor
   481
   482 31C3 4C 09 32			jmp gr8
   483 = 31C4			mode	equ *-2
   484
   485 31C6 AD D9 3E		gr15	lda color
   486 31C9 29 03			and #3
   487 31CB A8				tay
   488
   489 31CC 4C 0F 32			jmp toend
   490
   491 31CF 8A 48		gr9	txa:pha
   492
   493 31D1 AD D9 3E			lda color
   494 31D4 29 0F			and #$0f
   495 31D6 8D 02 32			sta c9+1
   496 31D9 0A 0A 0A 0A			:4 asl @
   497 31DD 8D 01 32			sta c9
   498
   499 31E0 A0 00			ldy #0
   500 31E2 98			lp	tya
   501 31E3 29 01			and #1
   502 31E5 AA				tax
   503 31E6 BD 03 32			lda c9_,x
   504 31E9 99 D3 37			sta adr.color_bits,y
   505 31EC BD 01 32			lda c9,x
   506 31EF 99 D3 38			sta adr.color_bits+$100,y
   507 31F2 C8				iny
   508 31F3 D0 ED			bne lp
   509
   510 31F5 68 AA			pla:tax
   511
   512 31F7 AC D9 3E			ldy color
   513 31FA F0 13			beq toend
   514
   515 31FC A0 01			ldy #1
   516 31FE 4C 0F 32			jmp toend
   517
   518 3201 00 00		c9	dta 0,0
   519 3203 0F F0		c9_	dta $0f, $f0
   520
   521 3205 37 38 39 3A		colorHi	dta h(adr.color_bits, adr.color_bits+$100, adr.color_bits+$200, adr.color_bits+$300)
   522
   523 3209 AD D9 3E		gr8	lda color
   524 320C 29 01			and #1
   525 320E A8				tay
   526
   527 320F			toend
   528 					.ifdef fLine
   529 320F B9 05 32			lda colorHi,y
   530 3212 8D A9 32			sta fLine.urr_color+2
   531 3215 8D DC 32			sta fLine.uur_color+2
   532 3218 8D 1A 33			sta fLine.drr_color+2
   533 321B 8D 4D 33			sta fLine.ddr_color+2
   534
   535 321E A9 1D			lda #$1d		; ora *,x
   536 3220 C0 00			cpy #0
   537 3222 D0 02			sne
   538 3224 A9 3D			lda #$3d		; and *,x
   539
   540 3226 8D A7 32			sta fLine.urr_color
   541 3229 8D DA 32			sta fLine.uur_color
   542 322C 8D 18 33			sta fLine.drr_color
   543 322F 8D 4B 33			sta fLine.ddr_color
   544 					.endif
   545
   546 					.ifdef PutPixel
   547 					mva colorHi,y PutPixel.acol+2
   548
   549 					lda #$1d		; ora *,x
   550 					cpy #0
   551 					sne
   552 					lda #$3d		; and *,x
   553
   554 					sta PutPixel.acol
   555 					.endif
   556
   557
   558 				; ------------------------------------------------------------
   559
   560 = 3ED9			COLOR	= DATAORIGIN+$0729
   561
   562 = 3ED9			@VarData	= COLOR
   563 = 0001			@VarDataSize	= 1
   564
   565 3232			@exit
   566 					.ifdef @new
   567 					lda <@VarData
   568 					sta :ztmp
   569 					lda >@VarData
   570 					ldy #@VarDataSize-1
   571 					jmp @FreeMem
   572 					eif
   573 3232 60				rts						; ret
   574 				.endl
   575
   576 3233			.local	FLINE						; PROCEDURE | ASSEMBLER
   577
   578 				; ------------------------------------------------------------
   579
   580 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   581 				; as Pointer
   582 3233 B5 98 8D DD 3E		mva :STACKORIGIN,x Y1
   583 3238 CA				dex						; sub bx, 1
   584
   585 				; ------------------------------------------------------------
   586
   587 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   588 				; as Pointer
   589 3239 B5 98 8D DC 3E		mva :STACKORIGIN,x X1
   590 323E CA				dex						; sub bx, 1
   591
   592 				; ------------------------------------------------------------
   593
   594 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   595 				; as Pointer
   596 323F B5 98 8D DB 3E		mva :STACKORIGIN,x Y0
   597 3244 CA				dex						; sub bx, 1
   598
   599 				; ------------------------------------------------------------
   600
   601 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   602 				; as Pointer
   603 3245 B5 98 8D DA 3E		mva :STACKORIGIN,x X0
   604 324A CA				dex						; sub bx, 1
   605
   606 				; ---------------------  ASM Block 066  ---------------------
   607
   608
   609 = 0094			dx	= ztmp
   610 = 0095			dy	= ztmp+1
   611 = 0096			tmp	= ztmp+2
   612 = 0097			todo	= ztmp+3
   613
   614 				PIXEL	.MACRO
   615 					ldy adr.div4,x
   616 					lda (:bp2),y
   617 					.def :1 = *
   618 					ora adr.color_bits,x
   619 					sta (:bp2),y
   620 					.ENDM
   621
   622 				PREPARE	.MACRO
   623 					sta todo
   624 					inc todo
   625 					lsr @
   626 					sta tmp
   627 					.ENDM
   628
   629 				; ==========================================================================
   630 324B			drawto
   631 324B 8A 48			txa:pha
   632
   633 				; check if going right (x1 <= x0)
   634 324D AE DC 3E			ldx x1
   635 3250 EC DA 3E			cpx x0
   636 3253 B0 16			bcs right
   637 				; going left, swap points
   638 3255 AD DA 3E			lda x0
   639 3258 8E DA 3E			stx x0
   640 325B 8D DC 3E			sta x1
   641 325E AA				tax
   642 325F AC DB 3E			ldy y0
   643 3262 AD DD 3E			lda y1
   644 3265 8C DD 3E			sty y1
   645 3268 8D DB 3E			sta y0
   646 326B			right
   647 				; compute X delta
   648 326B 8A				txa
   649 326C 38				sec
   650 326D ED DA 3E			sbc x0
   651 3270 85 94			sta dx
   652 				; set initial line address
   653 3272 AC DB 3E			ldy y0
   654 3275 B9 D3 3B			lda adr.lineLo,y
   655 3278 18 69 00			add #0
   656 = 327A			lfb	equ *-1
   657 327B 85 92			sta :bp2
   658 327D B9 D3 3C			lda adr.lineHi,y
   659 3280 69 00			adc #0
   660 = 3281			hfb	equ *-1
   661 3282 85 93			sta :bp2+1
   662
   663 				; remember x0 in X
   664 3284 AE DA 3E			ldx x0
   665 				; check if going up or down
   666 3287 CC DD 3E			cpy y1
   667 328A 90 71			jcc down
   668
   669 				; ----------------------------- UP ----------------------------------
   670 328C			up
   671 				; compute Y delta
   672 328C AD DB 3E			lda y0
   673 328F 38				sec
   674 3290 ED DD 3E			sbc y1
   675 3293 85 95			sta dy
   676 				; check if UP UP RIGHT or UP RIGHT RIGHT
   677 3295 C5 94			cmp dx
   678 3297 B0 33			bcs up_up_right
   679 3299			up_right_right
   680 3299 A5 94			lda dx
   681 329B				PREPARE urr_color
Macro: MAIN.FASTGRAPH.FLINE.PREPARE [Source: roaddli.a65]
     1 329B 85 97			sta todo
     2 329D E6 97			inc todo
     3 329F 4A				lsr @
     4 32A0 85 96			sta tmp
Source: roaddli.a65
   682 32A2			urr_loop
   683 32A2				PIXEL urr_color
Macro: MAIN.FASTGRAPH.FLINE.PIXEL [Source: roaddli.a65]
     1 32A2 BC D3 3D			ldy adr.div4,x
     2 32A5 B1 92			lda (:bp2),y
     3 = 32A7				.def URR_COLOR = *
     4 32A7 1D D3 37			ora adr.color_bits,x
     5 32AA 91 92			sta (:bp2),y
Source: roaddli.a65
   684 32AC E8				inx			; go 1 pixel right
   685 32AD A5 96			lda tmp
   686 32AF 38				sec
   687 32B0 E5 95			sbc dy
   688 32B2 85 96			sta tmp
   689 32B4 B0 0F			bcs urr_skip
   690 32B6 65 94			adc dx
   691 32B8 85 96			sta tmp
   692 32BA A5 92			lda :bp2		; go 1 line up
   693 32BC 38				sec
   694 32BD E9 00			sbc #0
   695 = 32BE			w0	equ *-1
   696 32BF 85 92			sta :bp2
   697 32C1 B0 02			bcs *+4
   698 32C3 C6 93			dec :bp2+1
   699 32C5			urr_skip
   700 32C5 C6 97			dec todo
   701 32C7 D0 D9			bne urr_loop
   702
   703 32C9 4C 6B 33		stop_	jmp stop
   704
   705 32CC			up_up_right
   706 32CC A5 95			lda dy
   707 32CE				PREPARE uur_color
Macro: MAIN.FASTGRAPH.FLINE.PREPARE [Source: roaddli.a65]
     1 32CE 85 97			sta todo
     2 32D0 E6 97			inc todo
     3 32D2 4A				lsr @
     4 32D3 85 96			sta tmp
Source: roaddli.a65
   708 32D5			uur_loop
   709 32D5				PIXEL uur_color
Macro: MAIN.FASTGRAPH.FLINE.PIXEL [Source: roaddli.a65]
     1 32D5 BC D3 3D			ldy adr.div4,x
     2 32D8 B1 92			lda (:bp2),y
     3 = 32DA				.def UUR_COLOR = *
     4 32DA 1D D3 37			ora adr.color_bits,x
     5 32DD 91 92			sta (:bp2),y
Source: roaddli.a65
   710 32DF A5 92			lda :bp2		; go 1 line up
   711 32E1 38				sec
   712 32E2 E9 00			sbc #0
   713 = 32E3			w1	equ *-1
   714 32E4 85 92			sta :bp2
   715 32E6 B0 02			bcs *+4
   716 32E8 C6 93			dec :bp2+1
   717 32EA A5 96			lda tmp
   718 32EC 38				sec
   719 32ED E5 94			sbc dx
   720 32EF B0 03			bcs uur_skip
   721 32F1 65 95			adc dy
   722 32F3 E8				inx			; go 1 pixel right
   723 32F4			uur_skip
   724 32F4 85 96			sta tmp
   725 32F6 C6 97			dec todo
   726 32F8 D0 DB			bne uur_loop
   727
   728 32FA 4C 6B 33			jmp stop
   729
   730 				; ----------------------------- DOWN ----------------------------------
   731 32FD			down
   732 				; compute Y delta
   733 32FD AD DD 3E			lda y1
   734 3300 38				sec
   735 3301 ED DB 3E			sbc y0
   736 3304 85 95			sta dy
   737 				; check if DOWN DOWN RIGHT or DOWN RIGHT RIGHT
   738 3306 C5 94			cmp dx
   739 3308 B0 33			bcs down_down_right
   740 330A			down_right_right
   741 330A A5 94			lda dx
   742 330C				PREPARE drr_color
Macro: MAIN.FASTGRAPH.FLINE.PREPARE [Source: roaddli.a65]
     1 330C 85 97			sta todo
     2 330E E6 97			inc todo
     3 3310 4A				lsr @
     4 3311 85 96			sta tmp
Source: roaddli.a65
   743 3313			drr_loop
   744 3313				PIXEL drr_color
Macro: MAIN.FASTGRAPH.FLINE.PIXEL [Source: roaddli.a65]
     1 3313 BC D3 3D			ldy adr.div4,x
     2 3316 B1 92			lda (:bp2),y
     3 = 3318				.def DRR_COLOR = *
     4 3318 1D D3 37			ora adr.color_bits,x
     5 331B 91 92			sta (:bp2),y
Source: roaddli.a65
   745 331D E8				inx			; go 1 pixel right
   746 331E A5 96			lda tmp
   747 3320 38				sec
   748 3321 E5 95			sbc dy
   749 3323 85 96			sta tmp
   750 3325 B0 0F			bcs drr_skip
   751 3327 65 94			adc dx
   752 3329 85 96			sta tmp
   753 332B A5 92			lda :bp2		; go 1 line down
   754 332D 18				clc
   755 332E 69 00			adc #0
   756 = 332F			w2	equ *-1
   757 3330 85 92			sta :bp2
   758 3332 90 02			bcc *+4
   759 3334 E6 93			inc :bp2+1
   760 3336			drr_skip
   761 3336 C6 97			dec todo
   762 3338 D0 D9			bne drr_loop
   763
   764 333A 4C 6B 33			jmp stop
   765
   766 333D			down_down_right
   767 333D A5 95			lda dy
   768 333F				PREPARE ddr_color
Macro: MAIN.FASTGRAPH.FLINE.PREPARE [Source: roaddli.a65]
     1 333F 85 97			sta todo
     2 3341 E6 97			inc todo
     3 3343 4A				lsr @
     4 3344 85 96			sta tmp
Source: roaddli.a65
   769 3346			ddr_loop
   770 3346				PIXEL ddr_color
Macro: MAIN.FASTGRAPH.FLINE.PIXEL [Source: roaddli.a65]
     1 3346 BC D3 3D			ldy adr.div4,x
     2 3349 B1 92			lda (:bp2),y
     3 = 334B				.def DDR_COLOR = *
     4 334B 1D D3 37			ora adr.color_bits,x
     5 334E 91 92			sta (:bp2),y
Source: roaddli.a65
   771 3350 A5 92			lda :bp2		; go 1 line down
   772 3352 18				clc
   773 3353 69 00			adc #0
   774 = 3354			w3	equ *-1
   775 3355 85 92			sta :bp2
   776 3357 90 02			bcc *+4
   777 3359 E6 93			inc :bp2+1
   778 335B A5 96			lda tmp
   779 335D 38				sec
   780 335E E5 94			sbc dx
   781 3360 B0 03			bcs ddr_skip
   782 3362 65 95			adc dy
   783 3364 E8				inx			; go 1 pixel right
   784 3365			ddr_skip
   785 3365 85 96			sta tmp
   786 3367 C6 97			dec todo
   787 3369 D0 DB			bne ddr_loop
   788
   789 336B 68 AA		stop	pla:tax
   790
   791
   792 				; ------------------------------------------------------------
   793
   794 = 3EDA			X0	= DATAORIGIN+$072A
   795 = 3EDB			Y0	= DATAORIGIN+$072B
   796 = 3EDC			X1	= DATAORIGIN+$072C
   797 = 3EDD			Y1	= DATAORIGIN+$072D
   798
   799 = 3EDA			@VarData	= X0
   800 = 0004			@VarDataSize	= 4
   801
   802 336D			@exit
   803 					.ifdef @new
   804 					lda <@VarData
   805 					sta :ztmp
   806 					lda >@VarData
   807 					ldy #@VarDataSize-1
   808 					jmp @FreeMem
   809 					eif
   810 336D 60				rts						; ret
   811 				.endl
   812
   813 336E			.local	FRAMEBUFFER_0093				; PROCEDURE | ASSEMBLER | OVERLOAD
   814
   815 				; ------------------------------------------------------------
   816
   817 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   818 				; as Pointer
   819 336E B5 98 8D DE 3E		mva :STACKORIGIN,x A
   820 3373 B5 A8 8D DF 3E		mva :STACKORIGIN+STACKWIDTH,x A+1
   821 3378 CA				dex						; sub bx, 1
   822
   823 				; ---------------------  ASM Block 069  ---------------------
   824
   825 3379 AD DE 3E			lda a
   826 337C AC DF 3E			ldy a+1
   827 					
   828 337F 8D D7 3E			sta VideoRam
   829 3382 8C D8 3E			sty VideoRam+1
   830
   831 					.ifdef PutPixel
   832 					sta PutPixel.lfb
   833 					sty PutPixel.hfb
   834 					eif
   835
   836 					.ifdef GetPixel
   837 					sta GetPixel.lfb
   838 					sty GetPixel.hfb
   839 					eif
   840
   841 					.ifdef HLine
   842 					sta HLine.lfb
   843 					sty HLine.hfb
   844 					eif
   845
   846 					.ifdef fLine
   847 3385 8D 7A 32			sta fLine.lfb
   848 3388 8C 81 32			sty fLine.hfb
   849 					eif
   850
   851
   852 				; ------------------------------------------------------------
   853
   854 = 3EDE			A	= DATAORIGIN+$072E
   855
   856 = 3EDE			@VarData	= A
   857 = 0002			@VarDataSize	= 2
   858
   859 338B			@exit
   860 					.ifdef @new
   861 					lda <@VarData
   862 					sta :ztmp
   863 					lda >@VarData
   864 					ldy #@VarDataSize-1
   865 					jmp @FreeMem
   866 					eif
   867 338B 60				rts						; ret
   868 				.endl
   869
   870 338C			.local	INITGRAPH_0097					; PROCEDURE | OVERLOAD
   871
   872 				; ------------------------------------------------------------
   873
   874 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   875 				; as Pointer
   876 338C B5 98 8D E0 3E		mva :STACKORIGIN,x MODE
   877 3391 CA				dex						; sub bx, 1
   878
   879 				; optimize OK (FASTGRAPH), line = 967
   880
   881 3392 AD E0 3E 8D B6 37		mva MODE SYSTEM.GRAPHMODE
   882
   883 				; optimize OK (FASTGRAPH), line = 969
   884
   885 3398 AD E0 3E			lda MODE
   886 339B 29 0F			and #$0F
   887 339D 8D E1 3E			sta WIDTH
   888
   889 				; ------------------------------------------------------------
   890
   891 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   892 				; as Pointer
   893
   894 33A0 E8				inx						; add bx, 1
   895 33A1 AD E1 3E 95 98		mva WIDTH :STACKORIGIN,x
   896
   897 				; GenerateCaseProlog
   898 33A6 CA				dex						; sub bx, 1
   899
   900 				; GenerateCaseEqualityCheck
   901 33A7 B5 99			lda :STACKORIGIN+1,x
   902 33A9 C9 06			cmp #6
   903 33AB F0 06			beq @+
   904
   905 				; GenerateCaseEqualityCheck
   906 33AD B5 99			lda :STACKORIGIN+1,x
   907 33AF C9 08			cmp #8
   908 33B1 D0 0D			jne l_00BB
   909 33B3			@
   910
   911 				; ---------------------  ASM Block 070  ---------------------
   912
   913 					.ifdef SetColor
   914 33B3 A9 09 8D C4 31 A9 + 	mwa #SetColor.gr8 SetColor.mode
   915 					.endif
   916
   917 					.ifdef PutPixel
   918 					mwa #PutPixel.gr8 PutPixel.mode
   919 					.endif
   920 					
   921 					.ifdef GetPixel
   922 					mwa #GetPixel.gr8 GetPixel.mode
   923 					.endif
   924
   925
   926 				; GenerateCaseStatementEpilog
   927 33BD 4C E5 33			jmp a_0002
   928 33C0			l_00BB
   929
   930 33C0 B5 99			lda :STACKORIGIN+1,x
   931 33C2 18				clc						; clear carry for add
   932 33C3 69 F4			adc #$FF-11					; make m = $FF
   933 33C5 69 03			adc #11-9+1					; carry set if in range n to m
   934 33C7 90 12			jcc l_00C4
   935 33C9			@
   936
   937 				; ---------------------  ASM Block 071  ---------------------
   938
   939 					.ifdef SetColor
   940 33C9 A9 CF 8D C4 31 A9 + 	mwa #SetColor.gr9 SetColor.mode
   941 					.endif
   942
   943 					.ifdef PutPixel
   944 					mwa #PutPixel.gr9 PutPixel.mode
   945 					.endif
   946 					
   947 					.ifdef GetPixel
   948 					mwa #GetPixel.gr9 GetPixel.mode
   949 					.endif
   950
   951 					.ifdef fLine
   952 33D3 A9 EA 8D CA 34		mva #$ea _nop
   953 					.endif
   954
   955
   956 				; GenerateCaseStatementEpilog
   957 33D8 4C E5 33			jmp a_0002
   958 33DB			l_00C4
   959
   960 				; ---------------------  ASM Block 072  ---------------------
   961
   962 					.ifdef SetColor
   963 33DB A9 C6 8D C4 31 A9 + 	mwa #SetColor.gr15 SetColor.mode
   964 					.endif
   965
   966 					.ifdef PutPixel
   967 					mwa #PutPixel.gr15 PutPixel.mode
   968 					.endif
   969 					
   970 					.ifdef GetPixel
   971 					mwa #GetPixel.gr15 GetPixel.mode
   972 					.endif		
   973
   974
   975 				; GenerateCaseEpilog
   976 33E5			a_0002
   977
   978 				; ---------------------  ASM Block 073  ---------------------
   979
   980 33E5 8A 48			txa:pha
   981
   982 33E7 AD E0 3E			lda mode
   983 33EA 29 0F			and #$0f
   984 33EC A8				tay
   985
   986 33ED A2 60			ldx #$60	; 6*16
   987 33EF AD E0 3E			lda mode	; %00010000 with text window
   988 33F2 29 10			and #$10
   989 33F4 49 10			eor #$10
   990 33F6 09 02			ora #2		; read
   991
   992 					.nowarn @graphics
   992 33F8 20 41 30		 JSR @GRAPHICS
   993
   994
   995 				; Fox/TQA
   996
   997 = 0057			dindex	equ $57
   998 = EE7D			tmccn	equ $ee7d
   999 = EE8D			tmrcn	equ $ee8d
  1000
  1001 33FB A6 57			ldx dindex
  1002 33FD BD 7D EE			lda tmccn,x
  1003 3400 BC 8D EE			ldy tmrcn,x
  1004 3403 A2 00			ldx #0
  1005 3405 C9 40			cmp #<320
  1006 3407 D0 01 E8			sne:inx
  1007
  1008 				; X:A = horizontal resolution
  1009 				; Y = vertical resolution
  1010
  1011 340A 8D B0 37			sta MAIN.SYSTEM.ScreenWidth
  1012 340D 8E B1 37			stx MAIN.SYSTEM.ScreenWidth+1
  1013 					
  1014 3410 38 E9 01			sub #1
  1015 3413 8D BF 37			sta WIN_RIGHT
  1016 3416 8A				txa
  1017 3417 E9 00			sbc #0
  1018 3419 8D C0 37			sta WIN_RIGHT+1
  1019 					
  1020 341C 8C B2 37			sty MAIN.SYSTEM.ScreenHeight
  1021 341F A9 00			lda #0
  1022 3421 8D B3 37			sta MAIN.SYSTEM.ScreenHeight+1
  1023 					
  1024 3424 8D BD 37			sta WIN_LEFT
  1025 3427 8D BE 37			sta WIN_LEFT+1
  1026 342A 8D C1 37			sta WIN_TOP
  1027 342D 8D C2 37			sta WIN_TOP+1
  1028
  1029 3430 8D C4 37			sta WIN_BOTTOM+1	
  1030 3433 88				dey
  1031 3434 8C C3 37			sty WIN_BOTTOM
  1032
  1033
  1034 = EE6D			tlshc	equ $ee6d
  1035
  1036 3437 A6 57			ldx dindex
  1037 3439 BC 6D EE			ldy tlshc,x
  1038 343C A9 05			lda #5
  1039 343E 0A			shift	asl @
  1040 343F 88				dey
  1041 3440 D0 FC			bne shift
  1042
  1043 3442 8D E1 3E			sta width
  1044
  1045 					.ifdef fLine
  1046 				;	lda width
  1047 3445 8D BE 32			sta fLine.w0
  1048 3448 8D E3 32			sta fLine.w1
  1049 344B 8D 2F 33			sta fLine.w2
  1050 344E 8D 54 33			sta fLine.w3
  1051 					.endif
  1052
  1053
  1054 				; ---	init_tabs
  1055
  1056 3451 A0 00			ldy #0
  1057 3453 84 92			sty :bp2
  1058 3455 84 93			sty :bp2+1
  1059 3457			it1
  1060 3457 A5 93			lda :bp2+1
  1061 3459 99 D3 3C			sta adr.lineHi,y
  1062 345C A5 92			lda :bp2
  1063 345E 99 D3 3B			sta adr.lineLo,y
  1064 3461 18				clc
  1065 3462 6D E1 3E			adc width
  1066 3465 85 92			sta :bp2
  1067 3467 90 02			scc
  1068 3469 E6 93			inc :bp2+1
  1069
  1070 346B C8				iny
  1071 346C D0 E9			bne it1
  1072
  1073 346E A9 55 8D B4 34		mva #$55 _col+1
  1074
  1075 3473 A2 03			ldx #3
  1076 3475 8E A6 34			stx _and+1
  1077 3478 8A				txa
  1078 3479 9D D4 34		l0	sta __oras,x
  1079 347C 0A				asl @
  1080 347D 0A				asl @
  1081 347E CA				dex
  1082 347F 10 F8			bpl l0
  1083
  1084 3481 AD E0 3E			lda mode
  1085 3484 29 0F			and #$0f
  1086 3486 C9 08			cmp #8
  1087 3488 F0 07			beq x8
  1088 348A C9 06			cmp #6
  1089 348C F0 03			beq x8
  1090 					
  1091 348E 4C A4 34			jmp it2
  1092 3491			x8
  1093 3491 A9 FF 8D B4 34		mva #$ff _col+1
  1094
  1095 3496 A2 07			ldx #7
  1096 3498 8E A6 34			stx _and+1
  1097 349B A9 01			lda #1
  1098 349D 9D D4 34		l1	sta __oras,x
  1099 34A0 0A				asl @
  1100 34A1 CA				dex
  1101 34A2 10 F9			bpl l1
  1102
  1103 34A4 98			it2	tya
  1104 34A5 29 03		_and	and #3
  1105 34A7 AA				tax
  1106 34A8 BD D4 34			lda __oras,x
  1107 34AB 49 FF			eor #$ff
  1108 34AD 99 D3 37			sta adr.color_bits+$000,y ; color0
  1109 34B0 BD D4 34			lda __oras,x
  1110 34B3 29 55		_col	and #$55
  1111 34B5 99 D3 38			sta adr.color_bits+$100,y ; color1
  1112 34B8 BD D4 34			lda __oras,x
  1113 34BB 29 AA			and #$aa
  1114 34BD 99 D3 39			sta adr.color_bits+$200,y ; color2
  1115 34C0 BD D4 34			lda __oras,x
  1116 34C3 29 FF			and #$ff
  1117 34C5 99 D3 3A			sta adr.color_bits+$300,y ; color3
  1118 34C8 98				tya
  1119 34C9 4A				lsr @
  1120 34CA 4A			_nop	lsr @
  1121 34CB 99 D3 3D			sta adr.div4,y
  1122 34CE C8				iny
  1123 34CF D0 D3			bne it2
  1124
  1125 34D1 4C DC 34			jmp stop
  1126
  1127 34D4 C0 30 0C 03		__oras	dta $c0,$30,$0c,$03
  1128 34D8 00 00 00 00			dta 0,0,0,0
  1129
  1130 34DC 68 AA		stop	pla:tax
  1131
  1132
  1133 				; optimize FAIL ('FRAMEBUFFER_0093', FASTGRAPH), line = 1178
  1134 34DE E8				inx
  1135 34DF A5 58 95 98			mva ATARI.SAVMSC :STACKORIGIN,x
  1136 34E3 A5 59 95 A8			mva ATARI.SAVMSC+1 :STACKORIGIN+STACKWIDTH,x
  1137 34E7 20 6E 33			jsr FRAMEBUFFER_0093
  1138
  1139 				; ------------------------------------------------------------
  1140
  1141 = 3EE0			MODE	= DATAORIGIN+$0730
  1142 = 3EE1			WIDTH	= DATAORIGIN+$0731
  1143
  1144 = 3EE0			@VarData	= MODE
  1145 = 0002			@VarDataSize	= 2
  1146
  1147 34EA			@exit
  1148 					.ifdef @new
  1149 					lda <@VarData
  1150 					sta :ztmp
  1151 					lda >@VarData
  1152 					ldy #@VarDataSize-1
  1153 					jmp @FreeMem
  1154 					eif
  1155 34EA 60				rts						; ret
  1156 				.endl
  1157
  1158 				; ------------------------------------------------------------
  1159
  1160 = 0080			CURRENTDRIVER	= $80
  1161 = 0000			DETECT	= $00
  1162 = 0001			CGA	= $01
  1163 = 0002			MCGA	= $02
  1164 = 0003			EGA	= $03
  1165 = 0004			EGA64	= $04
  1166 = 0005			EGAMONO	= $05
  1167 = 0006			LOWRES	= $06
  1168 = 0007			HERCMONO	= $07
  1169 = 0009			VGA	= $09
  1170 = 000A			VESA	= $0A
  1171 = 000B			D1BIT	= $0B
  1172 = 000C			D2BIT	= $0C
  1173 = 000D			D4BIT	= $0D
  1174 = 000E			D6BIT	= $0E
  1175 = 000F			D8BIT	= $0F
  1176 = 0010			D12BIT	= $10
  1177 = 0018			M640X400	= $18
  1178 = 0018			M640X480	= $18
  1179 = 0001			GROK	= $01
  1180 = 00FF			GRNOINITGRAPH	= $FF
  1181 = 00FE			GRNOTDETECTED	= $FE
  1182 = 00FD			GRFILENOTFOUND	= $FD
  1183 = 00FC			GRINVALIDDRIVER	= $FC
  1184 = 00FB			GRNOLOADMEM	= $FB
  1185 = 00FA			GRNOSCANMEM	= $FA
  1186 = 00F9			GRNOFLOODMEM	= $F9
  1187 = 00F8			GRFONTNOTFOUND	= $F8
  1188 = 00F7			GRNOFONTMEM	= $F7
  1189 = 00F6			GRINVALIDMODE	= $F6
  1190 = 00F5			GRERROR	= $F5
  1191 = 00F4			GRIOERROR	= $F4
  1192 = 00F3			GRINVALIDFONT	= $F3
  1193 = 00F2			GRINVALIDFONTNUM	= $F2
  1194 = 00EE			GRINVALIDVERSION	= $EE
  1195 = 0000			CGAC0	= $00
  1196 = 0001			CGAC1	= $01
  1197 = 0002			CGAC2	= $02
  1198 = 0003			CGAC3	= $03
  1199 = 0004			CGAHI	= $04
  1200 = 0000			MCGAC0	= $00
  1201 = 0001			MCGAC1	= $01
  1202 = 0002			MCGAC2	= $02
  1203 = 0003			MCGAC3	= $03
  1204 = 0004			MCGAMED	= $04
  1205 = 0005			MCGAHI	= $05
  1206 = 0000			EGALO	= $00
  1207 = 0001			EGAHI	= $01
  1208 = 0000			EGA64LO	= $00
  1209 = 0001			EGA64HI	= $01
  1210 = 0003			EGAMONOHI	= $03
  1211 = 000A			VGALO	= $0A
  1212 = 001F			VGAMED	= $1F
  1213 = 0018			VGAHI	= $18
  1214 = 37BD			WIN_LEFT	= DATAORIGIN+$000D
  1215 = 37BF			WIN_RIGHT	= DATAORIGIN+$000F
  1216 = 37C1			WIN_TOP	= DATAORIGIN+$0011
  1217 = 37C3			WIN_BOTTOM	= DATAORIGIN+$0013
  1218 = 37C5			GRAPHRESULT	= DATAORIGIN+$0015
  1219 = 37C6			GETCOLOR	= DATAORIGIN+$0016
  1220 = 37C7			adr.LASTARCCOORDS	= DATAORIGIN+$0017
  1221 34EB			.var LASTARCCOORDS	= adr.LASTARCCOORDS .word
  1222 = 37C7			LASTARCCOORDS.X	= DATAORIGIN+$0017
  1223 = 37C9			LASTARCCOORDS.Y	= DATAORIGIN+$0019
  1224 = 37CB			LASTARCCOORDS.XSTART	= DATAORIGIN+$001B
  1225 = 37CD			LASTARCCOORDS.YSTART	= DATAORIGIN+$001D
  1226 = 37CF			LASTARCCOORDS.XEND	= DATAORIGIN+$001F
  1227 = 37D1			LASTARCCOORDS.YEND	= DATAORIGIN+$0021
  1228 = 37D3			adr.COLOR_BITS	= DATAORIGIN+$0023
  1229 34EB			.var COLOR_BITS	= adr.COLOR_BITS .word
  1230 = 3BD3			adr.LINELO	= DATAORIGIN+$0423
  1231 34EB			.var LINELO	= adr.LINELO .word
  1232 = 3CD3			adr.LINEHI	= DATAORIGIN+$0523
  1233 34EB			.var LINEHI	= adr.LINEHI .word
  1234 = 3DD3			adr.DIV4	= DATAORIGIN+$0623
  1235 34EB			.var DIV4	= adr.DIV4 .word
  1236 = 3ED3			CURRENTX	= DATAORIGIN+$0723
  1237 = 3ED5			CURRENTY	= DATAORIGIN+$0725
  1238 = 3ED7			VIDEORAM	= DATAORIGIN+$0727
  1239
  1240 = 34EB C7 37		LASTARCCOORDS
  1240 = 34ED D3 37		COLOR_BITS
  1240 = 34EF D3 3B		LINELO
  1240 = 34F1 D3 3C		LINEHI
  1240 = 34F3 D3 3D		DIV4
  1240 				.endl							; UNIT FASTGRAPH
  1241
  1242 34F5			.local	DLI						; PROCEDURE | ASSEMBLER | INTERRUPT
  1243
  1244 				; ---------------------  ASM Block 081  ---------------------
  1245
  1246
  1247 34F5 48 8A 48 98 48	    phr ; store registers
  1248
  1249 				    
  1250 34FA A9 00 85 FE 85 FF	    mwa #0 $fe
  1251 3500 AD E6 3E		    lda borderlinePos
  1252 3503 29 0F		    and #15
  1253 3505 0A 0A 0A 0A		    asl:asl:asl:asl
  1254 3509 0A			    asl
  1255 350A 26 FF		    rol $ff
  1256 350C 0A			    asl
  1257 350D 26 FF		    rol $ff
  1258 350F 85 FE		    sta $fe
  1259 3511 18 A5 FE 69 0B 85 +     adw $fe #adr.borderlines
  1260
  1261 351E A9 0E		    lda #14 ; wait this number of lines
  1262 3520 CD 0B D4		@   cmp vcount
  1263 3523 10 FB		    bpl @-
  1264 				   
  1265 3525 A0 3F		    ldy #63
  1266 3527 8C 0A D4		    sty wsync
  1267 352A			@
  1268 352A B1 FE		    lda ($fe),y
  1269 352C AA			    tax
  1270 352D 29 02		    and #2
  1271 352F 09 C4		    ora #$c4
  1272 3531 8D 0A D4		    sta wsync
  1273 3534 8E 17 D0		    stx atari.colpf1
  1274 3537 8D 1A D0		    sta atari.colbk
  1275 353A 88			    dey
  1276 353B 10 ED		    bpl @-
  1277 353D A9 00		    lda #0
  1278 353F 8D 0A D4		    sta wsync
  1279 3542 8D 1A D0		    sta atari.colbk
  1280 				    
  1281 3545 68 A8 68 AA 68	    plr ; restore registers
  1282
  1283 354A 40				rti						; ret
  1284 				.endl
  1285
  1286 354B			.local	VBL						; PROCEDURE | ASSEMBLER | INTERRUPT
  1287
  1288 				; ---------------------  ASM Block 082  ---------------------
  1289
  1290
  1291 354B 48 8A 48 98 48	    phr ; store registers
  1292 				    
  1293 				;   *** example test routine    
  1294 				;    mva 20 atari.colbk // blink background
  1295 				    
  1296 				;   *** RMT play routine
  1297 				;    lda MSX
  1298 				;    ldy MSX+1
  1299 				;    jsr RMT.TRMT.PLAY
  1300
  1301 3550 68 A8 68 AA 68	    plr ; restore registers
  1302 3555 4C 62 E4		    jmp $E462 ; jump to system VBL handler
  1303
  1304 3558 40				rti						; ret
  1305 				.endl
  1306
  1307 3559			.local	SETDLIOFFSET					; PROCEDURE
  1308
  1309 				; optimize OK (roaddli.pas), line = 27
  1310
  1311 3559 A9 00 8D 4B 43		mva #$00 V
  1312 355E A9 60 8D 4C 43		mva #$60 V+1
  1313
  1314 				; optimize OK (roaddli.pas), line = 28
  1315
  1316 3563 A9 04 8D 4D 43		mva #$04 DL
  1317 3568 A9 70 8D 4E 43		mva #$70 DL+1
  1318 				; --- For
  1319
  1320 				; optimize OK (roaddli.pas), line = 29
  1321
  1322 356D A9 00 8D E2 3E		mva #$00 B
  1323
  1324 				; optimize OK (roaddli.pas), line = 29
  1325
  1326 3572			l_012B
  1327 				; --- ForToDoCondition
  1328
  1329 				; optimize OK (roaddli.pas), line = 29
  1330
  1331 3572 AD E2 3E			lda B
  1332 3575 C9 40			cmp #$40
  1333 3577 B0 47			jcs l_0139
  1334
  1335 				; optimize OK (roaddli.pas), line = 30
  1336
  1337 3579 AC E2 3E			ldy B
  1338 357C AD 4B 43			lda V
  1339 357F 18 79 0B 43			add adr.ROADOFFSETS,y
  1340 3583 8D 4B 43			sta V
  1341 3586 90 03			scc
  1342 3588 EE 4C 43			inc V+1
  1343
  1344 				; optimize OK (roaddli.pas), line = 31
  1345
  1346 358B AC 4D 43 84 92 AC + 	mwy DL :bp2
  1347 3595 A0 00			ldy #$00
  1348 3597 91 92			sta (:bp2),y
  1349 3599 C8				iny
  1350 359A AD 4C 43			lda V+1
  1351 359D 91 92			sta (:bp2),y
  1352
  1353 				; optimize OK (roaddli.pas), line = 32
  1354
  1355 359F AD 4D 43			lda DL
  1356 35A2 18 69 03			add #$03
  1357 35A5 8D 4D 43			sta DL
  1358 35A8 90 03			scc
  1359 35AA EE 4E 43			inc DL+1
  1360
  1361 				; optimize OK (roaddli.pas), line = 33
  1362
  1363 35AD AD 4B 43			lda V
  1364 35B0 18 69 28			add #$28
  1365 35B3 8D 4B 43			sta V
  1366 35B6 90 03			scc
  1367 35B8 EE 4C 43			inc V+1
  1368
  1369 				; --- ForToDoEpilog
  1370 35BB EE E2 3E			inc B						; inc ptr byte [CounterAddress]
  1371 35BE D0 B2			jne l_012B
  1372 35C0			l_0139
  1373
  1374 				; ------------------------------------------------------------
  1375
  1376 = 434B			V	= DATAORIGIN+$0B9B
  1377 = 434D			DL	= DATAORIGIN+$0B9D
  1378 = 003F			@FORTMP_0128	= $3F
  1379
  1380 = 434B			@VarData	= V
  1381 = 0004			@VarDataSize	= 4
  1382
  1383 35C0			@exit
  1384 					.ifdef @new
  1385 					lda <@VarData
  1386 					sta :ztmp
  1387 					lda >@VarData
  1388 					ldy #@VarDataSize-1
  1389 					jmp @FreeMem
  1390 					eif
  1391 35C0 60				rts						; ret
  1392 				.endl
  1393 35C1			l_0007
  1394
  1395 				; optimize FAIL ('FASTGRAPH.INITGRAPH_0097', roaddli.pas), line = 41
  1396 35C1 E8				inx
  1397 35C2 A9 0F 95 98			mva #$0F :STACKORIGIN,x
  1398 35C6 20 8C 33			jsr FASTGRAPH.INITGRAPH_0097
  1399
  1400 				; optimize FAIL ('SYSTEM.PAUSE_005A', roaddli.pas), line = 44
  1401 35C9 20 9E 31			jsr SYSTEM.PAUSE_005A
  1402
  1403 				; optimize OK (roaddli.pas), line = 45
  1404
  1405 35CC A9 00 8D 30 02		mva #$00 ATARI.SDLSTL
  1406 35D1 A9 70 8D 31 02		mva #$70 ATARI.SDLSTL+1
  1407
  1408 				; optimize FAIL ('FASTGRAPH.FRAMEBUFFER_0093', roaddli.pas), line = 47
  1409 35D6 E8				inx
  1410 35D7 A9 00 95 98			mva #$00 :STACKORIGIN,x
  1411 35DB A9 60 95 A8			mva #$60 :STACKORIGIN+STACKWIDTH,x
  1412 35DF 20 6E 33			jsr FASTGRAPH.FRAMEBUFFER_0093
  1413
  1414 				; optimize OK (roaddli.pas), line = 56
  1415
  1416 35E2 A9 F5 8D 00 02		mva <DLI VDSLST
  1417 35E7 A9 34 8D 01 02		mva >DLI VDSLST+1
  1418
  1419 				; optimize OK (roaddli.pas), line = 57
  1420
  1421 35EC A9 C0 8D 0E D4		mva #$C0 ATARI.NMIEN
  1422
  1423 				; optimize OK (roaddli.pas), line = 61
  1424
  1425 35F1 A9 0F 8D C5 02		mva #$0F ATARI.COLOR1
  1426
  1427 				; optimize OK (roaddli.pas), line = 62
  1428
  1429 35F6 A9 00 8D C6 02		mva #$00 ATARI.COLOR2
  1430
  1431 				; optimize OK (roaddli.pas), line = 63
  1432
  1433 35FB A9 74 8D C8 02		mva #$74 ATARI.COLOR4
  1434 				; --- For
  1435
  1436 				; optimize OK (roaddli.pas), line = 67
  1437
  1438 3600 A9 00 8D E2 3E		mva #$00 B
  1439
  1440 				; optimize OK (roaddli.pas), line = 67
  1441
  1442 3605			l_0176
  1443 				; --- ForToDoCondition
  1444
  1445 				; optimize OK (roaddli.pas), line = 67
  1446
  1447 3605 AD E2 3E			lda B
  1448 3608 C9 40			cmp #$40
  1449 360A B0 7F			jcs l_0184
  1450
  1451 				; optimize FAIL ('FASTGRAPH.SETCOLOR', roaddli.pas), line = 69
  1452 360C E8				inx
  1453 360D A9 02 95 98			mva #$02 :STACKORIGIN,x
  1454 3611 20 BA 31			jsr FASTGRAPH.SETCOLOR
  1455
  1456 				; optimize OK (roaddli.pas), line = 70
  1457
  1458 3614 AD E2 3E			lda B
  1459 3617 4A				lsr @
  1460 3618 4A				lsr @
  1461 3619 4A				lsr @
  1462 361A 4A				lsr @
  1463 361B 18 69 01			add #$01
  1464 361E 8D E3 3E			sta O
  1465
  1466 				; optimize FAIL ('FASTGRAPH.FLINE', roaddli.pas), line = 71
  1467 3621 E8				inx
  1468 3622 A9 50			lda #$50
  1469 3624 38 ED E2 3E			sub B
  1470 3628 95 98			sta :STACKORIGIN,x
  1471 362A E8				inx
  1472 362B AD E3 3E 95 98		mva O :STACKORIGIN,x
  1473 3630 20 94 30			jsr subAL_CL
  1474 3633 AD E2 3E 95 98		mva B :STACKORIGIN,x
  1475 3638 E8				inx
  1476 3639 A9 50			lda #$50
  1477 363B 18 6D E2 3E			add B
  1478 363F 95 98			sta :STACKORIGIN,x
  1479 3641 E8				inx
  1480 3642 AD E3 3E 95 98		mva O :STACKORIGIN,x
  1481 3647 20 81 30			jsr addAL_CL
  1482 364A AD E2 3E 95 98		mva B :STACKORIGIN,x
  1483 364F 20 33 32			jsr FASTGRAPH.FLINE
  1484
  1485 				; optimize FAIL ('FASTGRAPH.SETCOLOR', roaddli.pas), line = 73
  1486 3652 E8				inx
  1487 3653 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1488 3657 20 BA 31			jsr FASTGRAPH.SETCOLOR
  1489
  1490 				; optimize FAIL ('FASTGRAPH.FLINE', roaddli.pas), line = 74
  1491 365A E8				inx
  1492 365B A9 50			lda #$50
  1493 365D 38 ED E2 3E			sub B
  1494 3661 95 98			sta :STACKORIGIN,x
  1495 3663 E8				inx
  1496 3664 AD E2 3E 95 98		mva B :STACKORIGIN,x
  1497 3669 E8				inx
  1498 366A A9 50			lda #$50
  1499 366C 18 6D E2 3E			add B
  1500 3670 95 98			sta :STACKORIGIN,x
  1501 3672 E8				inx
  1502 3673 AD E2 3E 95 98		mva B :STACKORIGIN,x
  1503 3678 20 33 32			jsr FASTGRAPH.FLINE
  1504
  1505 				; optimize OK (roaddli.pas), line = 76
  1506
  1507 367B AC E2 3E			ldy B
  1508 367E A9 00 99 0B 43		mva #$00 adr.ROADOFFSETS,y
  1509
  1510 				; --- ForToDoEpilog
  1511 3683 EE E2 3E			inc B						; inc ptr byte [CounterAddress]
  1512 3686 F0 03 4C 05 36		jne l_0176
  1513 368B			l_0184
  1514
  1515 				; optimize OK (roaddli.pas), line = 82
  1516
  1517 368B A9 00 8D E8 3E		mva #$00 W
  1518 3690 8D E9 3E			sta W+1
  1519
  1520 				; optimize OK (roaddli.pas), line = 83
  1521
  1522 3693 A9 08 8D E3 3E		mva #$08 O
  1523
  1524 				; optimize OK (roaddli.pas), line = 84
  1525
  1526 3698 A9 00 8D E4 3E		mva #$00 OC
  1527
  1528 				; --- RepeatUntilProlog
  1529 369D			l_01E5
  1530
  1531 				; optimize OK (roaddli.pas), line = 86
  1532
  1533 369D AD E3 3E 8D E5 3E		mva O C
  1534
  1535 				; optimize OK (roaddli.pas), line = 87
  1536
  1537 36A3 AD E4 3E			lda OC
  1538 36A6 29 01			and #$01
  1539 36A8 8D E7 3E			sta BCOLOR
  1540 				; --- For
  1541
  1542 				; optimize OK (roaddli.pas), line = 88
  1543
  1544 36AB A9 00 8D E2 3E		mva #$00 B
  1545
  1546 				; optimize OK (roaddli.pas), line = 88
  1547
  1548 36B0			l_01FE
  1549 				; --- ForToDoCondition
  1550
  1551 				; optimize OK (roaddli.pas), line = 88
  1552
  1553 36B0 AD E2 3E			lda B
  1554 36B3 C9 40			cmp #$40
  1555 36B5 90 03 4C 64 37		jcs l_020C
  1556
  1557 				; optimize OK (roaddli.pas), line = 89
  1558
  1559 36BA AD E5 3E			lda C
  1560 36BD D0 41			jne l_021E
  1561
  1562 				; optimize FAIL (0, roaddli.pas), line = 90
  1563 36BF EE E7 3E			inc BCOLOR
  1564
  1565 				; optimize OK (roaddli.pas), line = 91
  1566
  1567 36C2 A9 00			lda #$00
  1568 36C4 85 85			sta :eax+1
  1569 36C6 AD E2 3E			lda B
  1570 36C9 0A				asl @
  1571 36CA 26 85			rol :eax+1
  1572 36CC 0A				asl @
  1573 36CD 26 85			rol :eax+1
  1574 36CF 18 6D E2 3E			add B
  1575 36D3 85 84			sta :eax
  1576 36D5 A5 85			lda :eax+1
  1577 36D7 69 00			adc #$00
  1578 36D9 85 85			sta :eax+1
  1579 36DB 06 84			asl :eax
  1580 36DD 26 85			rol :eax+1
  1581 36DF A5 84			lda :eax
  1582 36E1 85 84			sta :ax
  1583 36E3 A5 85			lda :eax+1
  1584 36E5 85 85			sta :ax+1
  1585 36E7 A9 46			lda #$46
  1586 36E9 85 8C			sta :cx
  1587 36EB 20 20 31			jsr idivAX_CL
  1588 36EE A9 08			lda #$08
  1589 36F0 38 E5 84			sub :eax
  1590 36F3 8D E5 3E			sta C
  1591
  1592 				; optimize OK (roaddli.pas), line = 92
  1593
  1594 36F6 10 05			jpl l_0249
  1595
  1596 				; optimize OK (roaddli.pas), line = 92
  1597
  1598 36F8 A9 00 8D E5 3E		mva #$00 C
  1599 36FD			l_0249
  1600 36FD 4C 03 37			jmp l_0259
  1601 3700			l_021E
  1602
  1603 				; optimize FAIL (0, roaddli.pas), line = 93
  1604 3700 CE E5 3E			dec C
  1605 3703			l_0259
  1606
  1607 				; optimize OK (roaddli.pas), line = 95
  1608
  1609 3703 AD E7 3E			lda BCOLOR
  1610 3706 29 01			and #$01
  1611 3708 F0 17			jeq l_0273
  1612
  1613 				; optimize OK (roaddli.pas), line = 95
  1614
  1615 370A AD AC 37			lda BORDERLINES
  1616 370D 18 6D E8 3E			add W
  1617 3711 A8				tay
  1618 3712 AD AD 37			lda BORDERLINES+1
  1619 3715 6D E9 3E			adc W+1
  1620 3718 85 91			sta :bp+1
  1621 371A A9 0F			lda #$0F
  1622 371C 91 90			sta (:bp),y
  1623 371E 4C 35 37			jmp l_0283
  1624 3721			l_0273
  1625
  1626 				; optimize OK (roaddli.pas), line = 96
  1627
  1628 3721 AD AC 37			lda BORDERLINES
  1629 3724 18 6D E8 3E			add W
  1630 3728 A8				tay
  1631 3729 AD AD 37			lda BORDERLINES+1
  1632 372C 6D E9 3E			adc W+1
  1633 372F 85 91			sta :bp+1
  1634 3731 A9 24			lda #$24
  1635 3733 91 90			sta (:bp),y
  1636 3735			l_0283
  1637
  1638 				; optimize FAIL (0, roaddli.pas), line = 97
  1639 3735 EE E8 3E			inc W
  1640 3738 D0 03			sne
  1641 373A EE E9 3E			inc W+1
  1642
  1643 				; optimize OK (roaddli.pas), line = 99
  1644
  1645 373D AD E8 3E			lda W
  1646 3740 85 84			sta :ax
  1647 3742 AD E9 3E			lda W+1
  1648 3745 85 85			sta :ax+1
  1649 3747 A9 00			lda #$00
  1650 3749 85 8C			sta :cx
  1651 374B A9 04			lda #$04
  1652 374D 85 8D			sta :cx+1
  1653 374F 20 EF 30			jsr idivAX_CX.MOD
  1654 3752 A5 94			lda :ztmp8
  1655 3754 8D E8 3E			sta W
  1656 3757 A5 95			lda :ztmp9
  1657 3759 8D E9 3E			sta W+1
  1658
  1659 				; --- ForToDoEpilog
  1660 375C EE E2 3E			inc B						; inc ptr byte [CounterAddress]
  1661 375F F0 03 4C B0 36		jne l_01FE
  1662 3764			l_020C
  1663
  1664 				; optimize OK (roaddli.pas), line = 101
  1665
  1666 3764 AD E3 3E			lda O
  1667 3767 F0 06			jeq l_02B2
  1668
  1669 				; optimize FAIL (0, roaddli.pas), line = 101
  1670 3769 CE E3 3E			dec O
  1671 376C 4C 77 37			jmp l_02C0
  1672 376F			l_02B2
  1673
  1674 				; optimize OK (roaddli.pas), line = 103
  1675
  1676 376F A9 08 8D E3 3E		mva #$08 O
  1677
  1678 				; optimize FAIL (0, roaddli.pas), line = 104
  1679 3774 EE E4 3E			inc OC
  1680 3777			l_02C0
  1681
  1682 				; optimize OK (roaddli.pas), line = 107
  1683
  1684 3777 AD E4 3E			lda OC
  1685 377A C9 02			cmp #$02
  1686 377C F0 03 4C 9D 36		jne l_01E5
  1687
  1688 				; optimize FAIL ('SETDLIOFFSET', roaddli.pas), line = 109
  1689 3781 20 59 35			jsr SETDLIOFFSET
  1690
  1691 				; optimize OK (roaddli.pas), line = 111
  1692
  1693 3784 A9 00 8D E6 3E		mva #$00 BORDERLINEPOS
  1694
  1695 				; --- RepeatUntilProlog
  1696 3789			l_02DB
  1697
  1698 				; optimize FAIL ('SYSTEM.PAUSE_005A', roaddli.pas), line = 113
  1699 3789 20 9E 31			jsr SYSTEM.PAUSE_005A
  1700
  1701 				; optimize FAIL (0, roaddli.pas), line = 114
  1702 378C EE E6 3E			inc BORDERLINEPOS
  1703
  1704 				; optimize OK (roaddli.pas), line = 115
  1705
  1706 378F 4C 89 37			jmp l_02DB
  1707
  1708 3792 20 A9 31			jsr CRT.READKEY					; call Entry
  1709
  1710 3795 CA				dex						; sub bx, 1
  1711
  1712 				; ------------------------------------------------------------
  1713
  1714 = 6000			FREE_BOTTOM	= $6000
  1715 = 6000			VIDEO_RAM_ADDRESS	= $6000
  1716 = 7000			DISPLAY_LIST_ADDRESS	= $7000
  1717 = 00FF			NONE	= $FF
  1718 = 3EE2			B	= DATAORIGIN+$0732
  1719 = 3EE3			O	= DATAORIGIN+$0733
  1720 = 3EE4			OC	= DATAORIGIN+$0734
  1721 = 3EE5			C	= DATAORIGIN+$0735
  1722 = 3EE6			BORDERLINEPOS	= DATAORIGIN+$0736
  1723 = 3EE7			BCOLOR	= DATAORIGIN+$0737
  1724 = 3EE8			W	= DATAORIGIN+$0738
  1725 = 3EEA			adr.S	= DATAORIGIN+$073A
  1726 3796			.var S	= adr.S .word
  1727 = 3F0B			adr.BORDERLINES	= DATAORIGIN+$075B
  1728 3796			.var BORDERLINES	= adr.BORDERLINES .word
  1729 = 430B			adr.ROADOFFSETS	= DATAORIGIN+$0B5B
  1730 3796			.var ROADOFFSETS	= adr.ROADOFFSETS .word
  1731 = 003F			@FORTMP_0173	= $3F
  1732 = 003F			@FORTMP_01FB	= $3F
  1733 3796			@exit
  1734
  1735 3796 A2 00		@halt	ldx #0
  1736 3798 9A				txs
  1737
  1738 3799 60				rts
  1739
  1740 				; ------------------------------------------------------------
  1741
  1742 379A 00 00 00 00 00 00 + IOCB@COPY	:16 brk
  1743
  1744 				; ------------------------------------------------------------
  1745
  1746 37AA			.local	@DEFINES
  1747 37AA			ATARI
  1748 				.endl
  1749
  1750 = 37AA EA 3E		S
  1750 = 37AC 0B 3F		BORDERLINES
  1750 = 37AE 0B 43		ROADOFFSETS
  1750 				.endl							; MAIN
  1751
  1752 				; ------------------------------------------------------------
  1753 				; ------------------------------------------------------------
  1754
  1755 				.macro	UNITINITIALIZATION
  1756 				
  1757 					.ifdef MAIN.SYSTEM.@UnitInit
  1758 					jsr MAIN.SYSTEM.@UnitInit
  1759 					eif
  1760 				
  1761 					.ifdef MAIN.ATARI.@UnitInit
  1762 					jsr MAIN.ATARI.@UnitInit
  1763 					eif
  1764 				
  1765 					.ifdef MAIN.CRT.@UnitInit
  1766 					jsr MAIN.CRT.@UnitInit
  1767 					eif
  1768 				
  1769 					.ifdef MAIN.TYPES.@UnitInit
  1770 					jsr MAIN.TYPES.@UnitInit
  1771 					eif
  1772 				
  1773 					.ifdef MAIN.FASTGRAPH.@UnitInit
  1774 					jsr MAIN.FASTGRAPH.@UnitInit
  1775 					eif
  1776 				.endm
  1777
  1778 				; ------------------------------------------------------------
  1779
  1780 					ift .SIZEOF(MAIN.SYSTEM) > 0
  1781 					.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
  1781 				SYSTEM: $3180..$31A8
  1782 					eif
  1783
  1784 					ift .SIZEOF(MAIN.ATARI) > 0
  1785 					.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
  1786 					eif
  1787
  1788 					ift .SIZEOF(MAIN.CRT) > 0
  1789 					.print 'CRT: ',MAIN.CRT,'..',MAIN.CRT+.SIZEOF(MAIN.CRT)-1
  1789 				CRT: $31A9..$31B9
  1790 					eif
  1791
  1792 					ift .SIZEOF(MAIN.TYPES) > 0
  1793 					.print 'TYPES: ',MAIN.TYPES,'..',MAIN.TYPES+.SIZEOF(MAIN.TYPES)-1
  1794 					eif
  1795
  1796 					ift .SIZEOF(MAIN.FASTGRAPH) > 0
  1797 					.print 'FASTGRAPH: ',MAIN.FASTGRAPH,'..',MAIN.FASTGRAPH+.SIZEOF(MAIN.FASTGRAPH)-1
  1797 				FASTGRAPH: $31BA..$34F4
  1798 					eif
  1799
  1800 					.print 'CODE: ',CODEORIGIN,'..',*-1
  1800 				CODE: $3000..$37AF
  1801
  1802 				; ------------------------------------------------------------
  1803
  1804 37B0			DATAORIGIN
  1805 37B0 28 00 18 00 2D 0C + .by  $28 $00 $18 $00 $2D $0C $00 $00  $00 $00 $00 $00 $00 $00 $00 $27  $00 $00 $00 $17
  1806
  1807 = 0014			VARINITSIZE	= *-DATAORIGIN
  1808 = 0B9F			VARDATASIZE	= 2975
  1809
  1810 = 434F			PROGRAMSTACK	= DATAORIGIN+VARDATASIZE
  1811
  1812 					.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK
  1812 				DATA: $37B0..$434F
  1813
  1814 02E0-02E1> 43 31			run START
  1815
  1816 				; ------------------------------------------------------------
  1817
  1818 				.macro	STATICDATA
  1819 				.endm
  1820
  1821 					end
